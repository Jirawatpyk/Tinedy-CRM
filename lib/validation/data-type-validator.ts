// Data Type & Enum Validation for Tinedy CRM
// Generated by Database Agent (Alex)

import { z } from 'zod';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// =============================================================================
// ENUM DEFINITIONS & VALIDATION
// =============================================================================

/**
 * Comprehensive enum validation schemas
 */
export const EnumValidators = {
  CustomerStatus: z.enum(['ACTIVE', 'INACTIVE', 'BLOCKED'], {
    errorMap: () => ({ message: 'Customer status must be ACTIVE, INACTIVE, or BLOCKED' })
  }),

  JobStatus: z.enum(['NEW', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'ON_HOLD'], {
    errorMap: () => ({ message: 'Job status must be NEW, IN_PROGRESS, COMPLETED, CANCELLED, or ON_HOLD' })
  }),

  Priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT'], {
    errorMap: () => ({ message: 'Priority must be LOW, MEDIUM, HIGH, or URGENT' })
  }),

  UserRole: z.enum(['ADMIN', 'OPERATIONS', 'TRAINING', 'QC_MANAGER'], {
    errorMap: () => ({ message: 'User role must be ADMIN, OPERATIONS, TRAINING, or QC_MANAGER' })
  }),

  QCStatus: z.enum(['PENDING', 'IN_PROGRESS', 'PASSED', 'FAILED', 'NEEDS_REVIEW'], {
    errorMap: () => ({ message: 'QC status must be PENDING, IN_PROGRESS, PASSED, FAILED, or NEEDS_REVIEW' })
  }),

  TrainingStatus: z.enum(['AWAITING_DOCUMENTS', 'DOCUMENTS_RECEIVED', 'TRAINING_IN_PROGRESS', 'TRAINING_COMPLETED', 'COMPLETED'], {
    errorMap: () => ({ message: 'Training status must be AWAITING_DOCUMENTS, DOCUMENTS_RECEIVED, TRAINING_IN_PROGRESS, TRAINING_COMPLETED, or COMPLETED' })
  }),

  WebhookStatus: z.enum(['RECEIVED', 'PROCESSING', 'PROCESSED', 'FAILED', 'RETRY_NEEDED'], {
    errorMap: () => ({ message: 'Webhook status must be RECEIVED, PROCESSING, PROCESSED, FAILED, or RETRY_NEEDED' })
  })
};

/**
 * Enum transition validation rules
 */
export const EnumTransitions = {
  CustomerStatus: {
    'ACTIVE': ['INACTIVE', 'BLOCKED'],
    'INACTIVE': ['ACTIVE', 'BLOCKED'],
    'BLOCKED': ['ACTIVE', 'INACTIVE']
  },

  JobStatus: {
    'NEW': ['IN_PROGRESS', 'CANCELLED'],
    'IN_PROGRESS': ['COMPLETED', 'ON_HOLD', 'CANCELLED'],
    'ON_HOLD': ['IN_PROGRESS', 'CANCELLED'],
    'COMPLETED': [], // Final state
    'CANCELLED': []  // Final state
  },

  QCStatus: {
    'PENDING': ['IN_PROGRESS', 'PASSED', 'FAILED'],
    'IN_PROGRESS': ['PASSED', 'FAILED', 'NEEDS_REVIEW'],
    'PASSED': [], // Final state
    'FAILED': ['NEEDS_REVIEW'],
    'NEEDS_REVIEW': ['PASSED', 'FAILED']
  },

  TrainingStatus: {
    'AWAITING_DOCUMENTS': ['DOCUMENTS_RECEIVED'],
    'DOCUMENTS_RECEIVED': ['TRAINING_IN_PROGRESS'],
    'TRAINING_IN_PROGRESS': ['TRAINING_COMPLETED'],
    'TRAINING_COMPLETED': ['COMPLETED'],
    'COMPLETED': [] // Final state
  },

  WebhookStatus: {
    'RECEIVED': ['PROCESSING', 'FAILED'],
    'PROCESSING': ['PROCESSED', 'FAILED'],
    'PROCESSED': [], // Final state
    'FAILED': ['RETRY_NEEDED'],
    'RETRY_NEEDED': ['PROCESSING', 'FAILED']
  }
};

// =============================================================================
// DATA TYPE VALIDATORS
// =============================================================================

/**
 * Custom data type validation schemas
 */
export const DataTypeValidators = {
  // ID validation (CUID format)
  id: z.string().cuid('Invalid ID format'),

  // LINE User ID validation
  lineUserId: z.string()
    .regex(/^U[a-fA-F0-9]{32}$/, 'LINE User ID must start with U followed by 32 hex characters')
    .optional(),

  // Thai phone number validation
  thaiPhone: z.string()
    .regex(/^(\+66|0)[0-9]{8,9}$/, 'Invalid Thai phone number format')
    .optional(),

  // Email validation with Thai domain support
  email: z.string()
    .email('Invalid email format')
    .max(255, 'Email address too long')
    .optional(),

  // Thai name validation (supports Thai and English characters)
  thaiName: z.string()
    .min(1, 'Name is required')
    .max(255, 'Name too long')
    .regex(/^[\u0E00-\u0E7Fa-zA-Z\s\-\.]+$/, 'Name contains invalid characters'),

  // Service type validation
  serviceType: z.string()
    .min(1, 'Service type is required')
    .max(255, 'Service type too long')
    .regex(/^[\u0E00-\u0E7Fa-zA-Z0-9\s\-\.\(\)]+$/, 'Service type contains invalid characters'),

  // Address validation (Thai format)
  thaiAddress: z.string()
    .max(1000, 'Address too long')
    .regex(/^[\u0E00-\u0E7Fa-zA-Z0-9\s\-\.\,\/]+$/, 'Address contains invalid characters')
    .optional(),

  // Notes/Description validation
  notes: z.string()
    .max(2000, 'Notes too long')
    .optional(),

  // JSON validation for webhook data
  jsonData: z.record(z.any()).optional(),

  // DateTime validation
  dateTime: z.date().optional(),

  // Boolean validation
  boolean: z.boolean().default(false),

  // Integer validation
  integer: z.number().int().min(0),

  // Retry count validation
  retryCount: z.number().int().min(0).max(10, 'Retry count cannot exceed 10'),

  // URL validation (for webhooks)
  url: z.string().url('Invalid URL format').optional(),

  // Workflow ID validation
  workflowId: z.string()
    .max(255, 'Workflow ID too long')
    .regex(/^[a-zA-Z0-9\-_]+$/, 'Workflow ID can only contain alphanumeric characters, hyphens, and underscores')
    .optional()
};

// =============================================================================
// COMPOSITE VALIDATION SCHEMAS
// =============================================================================

/**
 * Complete entity validation schemas with data types
 */
export const EntityValidators = {
  customer: z.object({
    id: DataTypeValidators.id.optional(),
    lineUserId: DataTypeValidators.lineUserId,
    name: DataTypeValidators.thaiName,
    phone: DataTypeValidators.thaiPhone,
    email: DataTypeValidators.email,
    address: DataTypeValidators.thaiAddress,
    notes: DataTypeValidators.notes,
    status: EnumValidators.CustomerStatus.default('ACTIVE'),
    createdAt: DataTypeValidators.dateTime.optional(),
    updatedAt: DataTypeValidators.dateTime.optional()
  }),

  job: z.object({
    id: DataTypeValidators.id.optional(),
    customerId: DataTypeValidators.id,
    serviceType: DataTypeValidators.serviceType,
    description: DataTypeValidators.notes,
    status: EnumValidators.JobStatus.default('NEW'),
    priority: EnumValidators.Priority.default('MEDIUM'),
    scheduledAt: DataTypeValidators.dateTime,
    completedAt: DataTypeValidators.dateTime,
    assignedToId: DataTypeValidators.id.optional(),
    n8nWorkflowId: DataTypeValidators.workflowId,
    webhookData: DataTypeValidators.jsonData,
    createdAt: DataTypeValidators.dateTime.optional(),
    updatedAt: DataTypeValidators.dateTime.optional()
  }),

  user: z.object({
    id: DataTypeValidators.id.optional(),
    email: DataTypeValidators.email.refine(val => val !== undefined, 'Email is required'),
    name: DataTypeValidators.thaiName,
    role: EnumValidators.UserRole.default('OPERATIONS'),
    isActive: DataTypeValidators.boolean.default(true),
    createdAt: DataTypeValidators.dateTime.optional(),
    updatedAt: DataTypeValidators.dateTime.optional()
  }),

  qualityCheck: z.object({
    id: DataTypeValidators.id.optional(),
    jobId: DataTypeValidators.id,
    checklistId: DataTypeValidators.id,
    status: EnumValidators.QCStatus.default('PENDING'),
    completedBy: DataTypeValidators.id.optional(),
    completedAt: DataTypeValidators.dateTime,
    notes: DataTypeValidators.notes,
    createdAt: DataTypeValidators.dateTime.optional(),
    updatedAt: DataTypeValidators.dateTime.optional()
  }),

  trainingWorkflow: z.object({
    id: DataTypeValidators.id.optional(),
    jobId: DataTypeValidators.id,
    status: EnumValidators.TrainingStatus.default('AWAITING_DOCUMENTS'),
    documentsReceived: DataTypeValidators.boolean.default(false),
    trainingCompleted: DataTypeValidators.boolean.default(false),
    notes: DataTypeValidators.notes,
    createdAt: DataTypeValidators.dateTime.optional(),
    updatedAt: DataTypeValidators.dateTime.optional()
  }),

  webhookLog: z.object({
    id: DataTypeValidators.id.optional(),
    source: z.string().min(1, 'Source is required').max(100, 'Source too long'),
    workflowId: DataTypeValidators.workflowId,
    executionId: z.string().max(255, 'Execution ID too long').optional(),
    payload: DataTypeValidators.jsonData.refine(val => val !== undefined, 'Payload is required'),
    status: EnumValidators.WebhookStatus.default('RECEIVED'),
    processedAt: DataTypeValidators.dateTime,
    errorMessage: z.string().max(2000, 'Error message too long').optional(),
    createdJobId: DataTypeValidators.id.optional(),
    retryCount: DataTypeValidators.retryCount.default(0),
    createdAt: DataTypeValidators.dateTime.optional(),
    updatedAt: DataTypeValidators.dateTime.optional()
  })
};

// =============================================================================
// VALIDATION ENGINE
// =============================================================================

/**
 * Data type validation engine
 */
export class DataTypeValidator {
  /**
   * Validate enum value and transitions
   */
  static validateEnumTransition(
    enumType: keyof typeof EnumTransitions,
    currentValue: string,
    newValue: string
  ): { valid: boolean; message?: string } {
    // Validate enum value first
    const enumValidator = EnumValidators[enumType];
    const validation = enumValidator.safeParse(newValue);

    if (!validation.success) {
      return {
        valid: false,
        message: validation.error.errors[0].message
      };
    }

    // Check transition rules
    const transitions = EnumTransitions[enumType];
    const allowedTransitions = transitions[currentValue] || [];

    if (currentValue === newValue) {
      return { valid: true }; // No transition needed
    }

    if (!allowedTransitions.includes(newValue)) {
      return {
        valid: false,
        message: `Invalid ${enumType} transition from ${currentValue} to ${newValue}`
      };
    }

    return { valid: true };
  }

  /**
   * Validate data type constraints
   */
  static validateDataType(
    validatorName: keyof typeof DataTypeValidators,
    value: any
  ): { valid: boolean; message?: string; formattedValue?: any } {
    try {
      const validator = DataTypeValidators[validatorName];
      const result = validator.safeParse(value);

      if (result.success) {
        return {
          valid: true,
          formattedValue: result.data
        };
      } else {
        return {
          valid: false,
          message: result.error.errors[0].message
        };
      }

    } catch (error) {
      return {
        valid: false,
        message: `Data type validation error: ${(error as Error).message}`
      };
    }
  }

  /**
   * Validate complete entity with all data types
   */
  static validateEntity(
    entityType: keyof typeof EntityValidators,
    data: any
  ): { valid: boolean; data?: any; errors?: string[] } {
    try {
      const validator = EntityValidators[entityType];
      const result = validator.safeParse(data);

      if (result.success) {
        return {
          valid: true,
          data: result.data
        };
      } else {
        const errors = result.error.errors.map(err =>
          `${err.path.join('.')}: ${err.message}`
        );
        return {
          valid: false,
          errors
        };
      }

    } catch (error) {
      return {
        valid: false,
        errors: [`Entity validation error: ${(error as Error).message}`]
      };
    }
  }

  /**
   * Validate business logic rules for data types
   */
  static validateBusinessLogic(
    entityType: keyof typeof EntityValidators,
    data: any
  ): { valid: boolean; violations?: string[] } {
    const violations: string[] = [];

    switch (entityType) {
      case 'job':
        // Validate completion date logic
        if (data.status === 'COMPLETED' && !data.completedAt) {
          violations.push('Completed jobs must have a completion date');
        }

        if (data.completedAt && data.status !== 'COMPLETED') {
          violations.push('Only completed jobs should have a completion date');
        }

        // Validate scheduled date logic
        if (data.scheduledAt && data.status === 'NEW') {
          const now = new Date();
          if (data.scheduledAt < now) {
            violations.push('Scheduled date cannot be in the past for new jobs');
          }
        }

        // Validate assignment logic
        if (data.status === 'NEW' && data.assignedToId) {
          violations.push('New jobs should not be assigned until status changes');
        }

        break;

      case 'qualityCheck':
        // Validate completion requirements
        if (['PASSED', 'FAILED'].includes(data.status)) {
          if (!data.completedBy) {
            violations.push('Completed quality checks must have a completedBy user');
          }
          if (!data.completedAt) {
            violations.push('Completed quality checks must have a completion date');
          }
        }

        if (data.status === 'FAILED' && !data.notes) {
          violations.push('Failed quality checks must include notes explaining the failure');
        }

        break;

      case 'trainingWorkflow':
        // Validate training progression logic
        if (['DOCUMENTS_RECEIVED', 'TRAINING_IN_PROGRESS', 'TRAINING_COMPLETED', 'COMPLETED'].includes(data.status) &&
            !data.documentsReceived) {
          violations.push('documentsReceived must be true for status >= DOCUMENTS_RECEIVED');
        }

        if (['TRAINING_COMPLETED', 'COMPLETED'].includes(data.status) &&
            !data.trainingCompleted) {
          violations.push('trainingCompleted must be true for status >= TRAINING_COMPLETED');
        }

        break;

      case 'webhookLog':
        // Validate retry logic
        if (data.retryCount > 0 && !['FAILED', 'RETRY_NEEDED'].includes(data.status)) {
          violations.push('Retry count should only be > 0 for failed or retry-needed webhooks');
        }

        if (data.status === 'FAILED' && !data.errorMessage) {
          violations.push('Failed webhooks should include an error message');
        }

        if (data.status === 'PROCESSED' && !data.processedAt) {
          violations.push('Processed webhooks must have a processed date');
        }

        break;
    }

    return {
      valid: violations.length === 0,
      violations: violations.length > 0 ? violations : undefined
    };
  }

  /**
   * Comprehensive data validation
   */
  static async validateComplete(
    entityType: keyof typeof EntityValidators,
    data: any,
    options?: {
      checkTransitions?: boolean;
      currentData?: any;
      checkBusinessLogic?: boolean;
    }
  ): Promise<{
    valid: boolean;
    data?: any;
    errors?: {
      dataType?: string[];
      enumTransitions?: string[];
      businessLogic?: string[];
    };
  }> {
    const errors: any = {};

    // 1. Validate data types and structure
    const entityValidation = this.validateEntity(entityType, data);
    if (!entityValidation.valid) {
      errors.dataType = entityValidation.errors;
    }

    // 2. Validate enum transitions (if current data provided)
    if (options?.checkTransitions && options.currentData) {
      const transitionErrors: string[] = [];

      // Check each enum field for valid transitions
      const enumFields = {
        customer: ['status'],
        job: ['status'],
        qualityCheck: ['status'],
        trainingWorkflow: ['status'],
        webhookLog: ['status']
      };

      const fieldsToCheck = enumFields[entityType] || [];

      for (const field of fieldsToCheck) {
        if (data[field] && options.currentData[field] && data[field] !== options.currentData[field]) {
          const enumType = field === 'status' ? `${entityType.charAt(0).toUpperCase() + entityType.slice(1)}Status` : field;

          if (EnumTransitions[enumType as keyof typeof EnumTransitions]) {
            const transitionValidation = this.validateEnumTransition(
              enumType as keyof typeof EnumTransitions,
              options.currentData[field],
              data[field]
            );

            if (!transitionValidation.valid) {
              transitionErrors.push(transitionValidation.message!);
            }
          }
        }
      }

      if (transitionErrors.length > 0) {
        errors.enumTransitions = transitionErrors;
      }
    }

    // 3. Validate business logic
    if (options?.checkBusinessLogic !== false) {
      const businessValidation = this.validateBusinessLogic(entityType, data);
      if (!businessValidation.valid) {
        errors.businessLogic = businessValidation.violations;
      }
    }

    const valid = Object.keys(errors).length === 0;

    return {
      valid,
      data: entityValidation.data,
      errors: valid ? undefined : errors
    };
  }
}

// =============================================================================
// VALIDATION HELPERS
// =============================================================================

/**
 * Quick validation helpers for common use cases
 */
export const ValidationHelpers = {
  /**
   * Validate Thai phone number
   */
  isValidThaiPhone: (phone: string): boolean => {
    return DataTypeValidators.thaiPhone.safeParse(phone).success;
  },

  /**
   * Validate LINE User ID
   */
  isValidLineUserId: (lineUserId: string): boolean => {
    return DataTypeValidators.lineUserId.safeParse(lineUserId).success;
  },

  /**
   * Validate email
   */
  isValidEmail: (email: string): boolean => {
    return DataTypeValidators.email.safeParse(email).success;
  },

  /**
   * Check if enum transition is valid
   */
  isValidEnumTransition: (
    enumType: keyof typeof EnumTransitions,
    from: string,
    to: string
  ): boolean => {
    return DataTypeValidator.validateEnumTransition(enumType, from, to).valid;
  },

  /**
   * Format phone number to Thai standard
   */
  formatThaiPhone: (phone: string): string => {
    const cleaned = phone.replace(/\D/g, '');
    if (cleaned.startsWith('66')) {
      return `+${cleaned}`;
    } else if (cleaned.startsWith('0')) {
      return `+66${cleaned.slice(1)}`;
    }
    return phone;
  },

  /**
   * Sanitize and validate Thai name
   */
  sanitizeThaiName: (name: string): string => {
    return name.trim().replace(/\s+/g, ' ');
  }
};

export default {
  EnumValidators,
  EnumTransitions,
  DataTypeValidators,
  EntityValidators,
  DataTypeValidator,
  ValidationHelpers
};