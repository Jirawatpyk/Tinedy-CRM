// Validation Middleware for API Endpoints
// Generated by Database Agent (Alex)

import { NextRequest, NextResponse } from 'next/server';
import { DataTypeValidator } from './data-type-validator';
import { ConstraintValidator } from './database-constraints';
import { validateEntity } from './schema-validator';

// =============================================================================
// VALIDATION MIDDLEWARE
// =============================================================================

/**
 * Request validation middleware decorator
 */
export function validateRequest(
  entityType: 'customer' | 'job' | 'user' | 'qualityCheck' | 'trainingWorkflow' | 'webhookLog',
  options?: {
    requireId?: boolean;
    checkConstraints?: boolean;
    checkTransitions?: boolean;
    skipFields?: string[];
  }
) {
  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
    const method = descriptor.value!;

    descriptor.value = async function (request: NextRequest, ...args: any[]) {
      try {
        // Parse request body
        let body: any = {};

        if (['POST', 'PUT', 'PATCH'].includes(request.method)) {
          try {
            body = await request.json();
          } catch (error) {
            return NextResponse.json(
              { error: 'Invalid JSON in request body' },
              { status: 400 }
            );
          }
        }

        // Extract ID from URL params if needed
        if (options?.requireId && request.method !== 'POST') {
          const url = new URL(request.url);
          const pathSegments = url.pathname.split('/');
          const id = pathSegments[pathSegments.length - 1];

          if (!id || id === entityType) {
            return NextResponse.json(
              { error: 'Entity ID is required' },
              { status: 400 }
            );
          }

          body.id = id;
        }

        // Skip validation for GET requests without body
        if (request.method === 'GET' && Object.keys(body).length === 0) {
          return method.apply(this, [request, ...args]);
        }

        // Remove fields that should be skipped
        if (options?.skipFields) {
          options.skipFields.forEach(field => {
            delete body[field];
          });
        }

        // 1. Basic data type validation
        const dataValidation = await DataTypeValidator.validateComplete(
          entityType,
          body,
          {
            checkBusinessLogic: true,
            checkTransitions: options?.checkTransitions
          }
        );

        if (!dataValidation.valid) {
          return NextResponse.json(
            {
              error: 'Validation failed',
              details: dataValidation.errors
            },
            { status: 400 }
          );
        }

        // 2. Database constraint validation (if enabled)
        if (options?.checkConstraints) {
          const constraintValidation = await ConstraintValidator.validateAll(
            entityType,
            body
          );

          if (!constraintValidation.valid) {
            return NextResponse.json(
              {
                error: 'Constraint validation failed',
                details: constraintValidation.errors
              },
              { status: 400 }
            );
          }
        }

        // Attach validated data to request
        (request as any).validatedData = dataValidation.data;

        // Call original method
        return method.apply(this, [request, ...args]);

      } catch (error) {
        console.error('Validation middleware error:', error);
        return NextResponse.json(
          { error: 'Validation error occurred' },
          { status: 500 }
        );
      }
    };
  };
}

/**
 * Enum transition validation middleware
 */
export function validateEnumTransition(
  entityType: 'customer' | 'job' | 'qualityCheck' | 'trainingWorkflow' | 'webhookLog',
  statusField: string = 'status'
) {
  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
    const method = descriptor.value!;

    descriptor.value = async function (request: NextRequest, ...args: any[]) {
      try {
        // Only validate on UPDATE operations
        if (request.method !== 'PUT' && request.method !== 'PATCH') {
          return method.apply(this, [request, ...args]);
        }

        const body = await request.json();

        if (!body[statusField]) {
          return method.apply(this, [request, ...args]);
        }

        // Extract entity ID
        const url = new URL(request.url);
        const pathSegments = url.pathname.split('/');
        const id = pathSegments[pathSegments.length - 1];

        if (!id) {
          return NextResponse.json(
            { error: 'Entity ID is required for status updates' },
            { status: 400 }
          );
        }

        // Get current entity data to check transition
        // This would need to be implemented based on the specific entity type
        // For now, we'll skip the current data lookup and just validate the new status

        // Validate new status value
        const enumType = `${entityType.charAt(0).toUpperCase() + entityType.slice(1)}Status`;

        // This is a simplified validation - in production you'd want to fetch current data
        console.log(`Validating ${enumType} transition for ${id}`);

        return method.apply(this, [request, ...args]);

      } catch (error) {
        console.error('Enum transition validation error:', error);
        return NextResponse.json(
          { error: 'Status transition validation failed' },
          { status: 500 }
        );
      }
    };
  };
}

/**
 * Batch validation middleware for bulk operations
 */
export function validateBatch(
  entityType: 'customer' | 'job' | 'user' | 'qualityCheck' | 'trainingWorkflow' | 'webhookLog',
  maxBatchSize: number = 100
) {
  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
    const method = descriptor.value!;

    descriptor.value = async function (request: NextRequest, ...args: any[]) {
      try {
        const body = await request.json();

        if (!Array.isArray(body.data)) {
          return NextResponse.json(
            { error: 'Batch operations require data array' },
            { status: 400 }
          );
        }

        if (body.data.length > maxBatchSize) {
          return NextResponse.json(
            { error: `Batch size cannot exceed ${maxBatchSize} items` },
            { status: 400 }
          );
        }

        if (body.data.length === 0) {
          return NextResponse.json(
            { error: 'Batch cannot be empty' },
            { status: 400 }
          );
        }

        // Validate each item in the batch
        const validationResults = await Promise.all(
          body.data.map(async (item: any, index: number) => {
            const validation = await DataTypeValidator.validateComplete(
              entityType,
              item,
              { checkBusinessLogic: true }
            );

            return {
              index,
              valid: validation.valid,
              data: validation.data,
              errors: validation.errors
            };
          })
        );

        // Check if any validation failed
        const failedValidations = validationResults.filter(r => !r.valid);

        if (failedValidations.length > 0) {
          return NextResponse.json(
            {
              error: 'Batch validation failed',
              details: {
                totalItems: body.data.length,
                failedItems: failedValidations.length,
                failures: failedValidations
              }
            },
            { status: 400 }
          );
        }

        // Attach validated data to request
        (request as any).validatedBatch = validationResults.map(r => r.data);

        return method.apply(this, [request, ...args]);

      } catch (error) {
        console.error('Batch validation error:', error);
        return NextResponse.json(
          { error: 'Batch validation error occurred' },
          { status: 500 }
        );
      }
    };
  };
}

// =============================================================================
// VALIDATION HELPERS
// =============================================================================

/**
 * Manual validation helper for use in API routes
 */
export async function validateRequestData(
  entityType: 'customer' | 'job' | 'user' | 'qualityCheck' | 'trainingWorkflow' | 'webhookLog',
  data: any,
  options?: {
    checkConstraints?: boolean;
    checkTransitions?: boolean;
    currentData?: any;
  }
): Promise<{
  valid: boolean;
  data?: any;
  errors?: any;
}> {
  try {
    // 1. Data type validation
    const dataValidation = await DataTypeValidator.validateComplete(
      entityType,
      data,
      {
        checkBusinessLogic: true,
        checkTransitions: options?.checkTransitions,
        currentData: options?.currentData
      }
    );

    if (!dataValidation.valid) {
      return {
        valid: false,
        errors: dataValidation.errors
      };
    }

    // 2. Constraint validation (if enabled)
    if (options?.checkConstraints) {
      const constraintValidation = await ConstraintValidator.validateAll(
        entityType,
        data,
        { currentData: options?.currentData }
      );

      if (!constraintValidation.valid) {
        return {
          valid: false,
          errors: {
            ...dataValidation.errors,
            constraints: constraintValidation.errors
          }
        };
      }
    }

    return {
      valid: true,
      data: dataValidation.data
    };

  } catch (error) {
    return {
      valid: false,
      errors: {
        system: [`Validation error: ${(error as Error).message}`]
      }
    };
  }
}

/**
 * Response validation helper
 */
export function validateResponse(data: any, entityType?: string): any {
  if (!data) return data;

  // Remove sensitive fields from response
  const sensitiveFields = ['password', 'token', 'secret', 'key'];

  if (Array.isArray(data)) {
    return data.map(item => validateResponse(item, entityType));
  }

  if (typeof data === 'object') {
    const cleaned = { ...data };

    sensitiveFields.forEach(field => {
      delete cleaned[field];
    });

    // Entity-specific field removal
    if (entityType === 'user') {
      // Don't expose internal user fields in API responses
      delete cleaned.passwordHash;
      delete cleaned.resetToken;
    }

    if (entityType === 'webhookLog') {
      // Limit webhook payload size in responses
      if (cleaned.payload && JSON.stringify(cleaned.payload).length > 1000) {
        cleaned.payload = '[LARGE_PAYLOAD_TRUNCATED]';
      }
    }

    return cleaned;
  }

  return data;
}

export default {
  validateRequest,
  validateEnumTransition,
  validateBatch,
  validateRequestData,
  validateResponse
};