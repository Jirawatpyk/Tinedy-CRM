// Database Schema Validation System for Tinedy CRM
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import { z } from 'zod';

const prisma = new PrismaClient();

// =============================================================================
// SCHEMA VALIDATION RULES
// =============================================================================

/**
 * Validation schemas for all database entities
 */
export const ValidationSchemas = {
  // Customer validation
  customer: z.object({
    id: z.string().cuid().optional(),
    lineUserId: z.string().regex(/^U[a-fA-F0-9]{32}$/, 'Invalid LINE User ID format').optional(),
    name: z.string()
      .min(1, 'Customer name is required')
      .max(255, 'Customer name too long')
      .regex(/^[\u0E00-\u0E7Fa-zA-Z\s\-\.]+$/, 'Invalid characters in name'),
    phone: z.string()
      .regex(/^(\+66|0)[0-9]{8,9}$/, 'Invalid Thai phone number format')
      .optional(),
    email: z.string()
      .email('Invalid email format')
      .max(255, 'Email too long')
      .optional(),
    address: z.string()
      .max(1000, 'Address too long')
      .optional(),
    notes: z.string()
      .max(2000, 'Notes too long')
      .optional(),
    status: z.enum(['ACTIVE', 'INACTIVE', 'BLOCKED'])
  }),

  // Job validation
  job: z.object({
    id: z.string().cuid().optional(),
    customerId: z.string().cuid('Invalid customer ID'),
    serviceType: z.string()
      .min(1, 'Service type is required')
      .max(255, 'Service type too long'),
    description: z.string()
      .max(2000, 'Description too long')
      .optional(),
    status: z.enum(['NEW', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'ON_HOLD']),
    priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']),
    scheduledAt: z.date().optional(),
    completedAt: z.date().optional(),
    assignedToId: z.string().cuid('Invalid user ID').optional(),
    n8nWorkflowId: z.string().max(255, 'Workflow ID too long').optional(),
    webhookData: z.record(z.any()).optional()
  }),

  // User validation
  user: z.object({
    id: z.string().cuid().optional(),
    email: z.string()
      .email('Invalid email format')
      .max(255, 'Email too long'),
    name: z.string()
      .min(1, 'User name is required')
      .max(255, 'User name too long')
      .regex(/^[\u0E00-\u0E7Fa-zA-Z\s\-\.]+$/, 'Invalid characters in name'),
    role: z.enum(['ADMIN', 'OPERATIONS', 'TRAINING', 'QC_MANAGER']),
    isActive: z.boolean().default(true)
  }),

  // Quality Check validation
  qualityCheck: z.object({
    id: z.string().cuid().optional(),
    jobId: z.string().cuid('Invalid job ID'),
    checklistId: z.string().cuid('Invalid checklist ID'),
    status: z.enum(['PENDING', 'IN_PROGRESS', 'PASSED', 'FAILED', 'NEEDS_REVIEW']),
    completedBy: z.string().cuid('Invalid user ID').optional(),
    completedAt: z.date().optional(),
    notes: z.string().max(2000, 'Notes too long').optional()
  }),

  // Quality Checklist validation
  qualityChecklist: z.object({
    id: z.string().cuid().optional(),
    name: z.string()
      .min(1, 'Checklist name is required')
      .max(255, 'Checklist name too long'),
    description: z.string()
      .max(1000, 'Description too long')
      .optional(),
    items: z.array(z.object({
      id: z.string(),
      text: z.string().min(1, 'Item text is required'),
      required: z.boolean().default(true),
      category: z.string().optional()
    })).min(1, 'At least one checklist item is required'),
    isActive: z.boolean().default(true)
  }),

  // Training Workflow validation
  trainingWorkflow: z.object({
    id: z.string().cuid().optional(),
    jobId: z.string().cuid('Invalid job ID'),
    status: z.enum(['AWAITING_DOCUMENTS', 'DOCUMENTS_RECEIVED', 'TRAINING_IN_PROGRESS', 'TRAINING_COMPLETED', 'COMPLETED']),
    documentsReceived: z.boolean().default(false),
    trainingCompleted: z.boolean().default(false),
    notes: z.string().max(2000, 'Notes too long').optional()
  }),

  // Webhook Log validation
  webhookLog: z.object({
    id: z.string().cuid().optional(),
    source: z.string()
      .min(1, 'Source is required')
      .max(100, 'Source name too long'),
    workflowId: z.string().max(255, 'Workflow ID too long').optional(),
    executionId: z.string().max(255, 'Execution ID too long').optional(),
    payload: z.record(z.any()),
    status: z.enum(['RECEIVED', 'PROCESSING', 'PROCESSED', 'FAILED', 'RETRY_NEEDED']),
    processedAt: z.date().optional(),
    errorMessage: z.string().max(2000, 'Error message too long').optional(),
    createdJobId: z.string().cuid('Invalid job ID').optional(),
    retryCount: z.number().int().min(0).max(10)
  }),

  // Audit Log validation
  auditLog: z.object({
    id: z.string().cuid().optional(),
    entityType: z.string()
      .min(1, 'Entity type is required')
      .max(100, 'Entity type too long'),
    entityId: z.string()
      .min(1, 'Entity ID is required')
      .max(255, 'Entity ID too long'),
    action: z.string()
      .min(1, 'Action is required')
      .max(100, 'Action too long'),
    oldValues: z.record(z.any()).optional(),
    newValues: z.record(z.any()).optional(),
    userId: z.string().cuid('Invalid user ID').optional(),
    timestamp: z.date().default(() => new Date())
  })
};

// =============================================================================
// BUSINESS LOGIC VALIDATION
// =============================================================================

/**
 * Business logic validation rules
 */
export class BusinessValidation {
  /**
   * Validate job status transitions
   */
  static validateJobStatusTransition(
    currentStatus: string,
    newStatus: string
  ): { valid: boolean; message?: string } {
    const validTransitions: Record<string, string[]> = {
      'NEW': ['IN_PROGRESS', 'CANCELLED'],
      'IN_PROGRESS': ['COMPLETED', 'ON_HOLD', 'CANCELLED'],
      'ON_HOLD': ['IN_PROGRESS', 'CANCELLED'],
      'COMPLETED': [], // Final state
      'CANCELLED': []  // Final state
    };

    const allowed = validTransitions[currentStatus] || [];

    if (!allowed.includes(newStatus)) {
      return {
        valid: false,
        message: `Invalid status transition from ${currentStatus} to ${newStatus}`
      };
    }

    return { valid: true };
  }

  /**
   * Validate job assignment rules
   */
  static async validateJobAssignment(
    jobId: string,
    assignedToId: string
  ): Promise<{ valid: boolean; message?: string }> {
    try {
      // Check if user exists and is active
      const user = await prisma.user.findUnique({
        where: { id: assignedToId },
        select: { isActive: true, role: true }
      });

      if (!user) {
        return { valid: false, message: 'Assigned user not found' };
      }

      if (!user.isActive) {
        return { valid: false, message: 'Cannot assign to inactive user' };
      }

      // Check if user has appropriate role for the job
      const job = await prisma.job.findUnique({
        where: { id: jobId },
        select: { serviceType: true }
      });

      if (!job) {
        return { valid: false, message: 'Job not found' };
      }

      // Role-based assignment validation
      if (job.serviceType.includes('ฝึกอบรม') && user.role !== 'TRAINING') {
        return {
          valid: false,
          message: 'Training jobs must be assigned to TRAINING role users'
        };
      }

      return { valid: true };

    } catch (error) {
      return { valid: false, message: 'Assignment validation failed' };
    }
  }

  /**
   * Validate quality check completion
   */
  static async validateQualityCheckCompletion(
    qualityCheckId: string,
    completedBy: string
  ): Promise<{ valid: boolean; message?: string }> {
    try {
      // Check if quality check exists and is in valid state
      const qc = await prisma.qualityCheck.findUnique({
        where: { id: qualityCheckId },
        include: {
          job: {
            select: { status: true }
          }
        }
      });

      if (!qc) {
        return { valid: false, message: 'Quality check not found' };
      }

      if (qc.status === 'PASSED' || qc.status === 'FAILED') {
        return { valid: false, message: 'Quality check already completed' };
      }

      if (qc.job.status !== 'COMPLETED') {
        return { valid: false, message: 'Cannot complete QC for non-completed job' };
      }

      // Check if user has QC permissions
      const user = await prisma.user.findUnique({
        where: { id: completedBy },
        select: { role: true, isActive: true }
      });

      if (!user?.isActive) {
        return { valid: false, message: 'User not found or inactive' };
      }

      if (!['QC_MANAGER', 'ADMIN'].includes(user.role)) {
        return { valid: false, message: 'User does not have QC permissions' };
      }

      return { valid: true };

    } catch (error) {
      return { valid: false, message: 'QC validation failed' };
    }
  }

  /**
   * Validate data consistency across related entities
   */
  static async validateDataConsistency(): Promise<{
    valid: boolean;
    issues: Array<{ type: string; message: string; count?: number }>;
  }> {
    const issues: Array<{ type: string; message: string; count?: number }> = [];

    try {
      // Check for orphaned jobs (customer doesn't exist)
      const orphanedJobs = await prisma.$queryRaw<Array<{ count: bigint }>>`
        SELECT COUNT(*) as count
        FROM jobs j
        LEFT JOIN customers c ON j.customer_id = c.id
        WHERE c.id IS NULL
      `;

      if (Number(orphanedJobs[0].count) > 0) {
        issues.push({
          type: 'orphaned_jobs',
          message: 'Jobs exist without valid customers',
          count: Number(orphanedJobs[0].count)
        });
      }

      // Check for quality checks on non-existent jobs
      const orphanedQC = await prisma.$queryRaw<Array<{ count: bigint }>>`
        SELECT COUNT(*) as count
        FROM quality_checks qc
        LEFT JOIN jobs j ON qc.job_id = j.id
        WHERE j.id IS NULL
      `;

      if (Number(orphanedQC[0].count) > 0) {
        issues.push({
          type: 'orphaned_quality_checks',
          message: 'Quality checks exist without valid jobs',
          count: Number(orphanedQC[0].count)
        });
      }

      // Check for jobs assigned to inactive users
      const jobsWithInactiveUsers = await prisma.job.count({
        where: {
          assignedTo: {
            isActive: false
          }
        }
      });

      if (jobsWithInactiveUsers > 0) {
        issues.push({
          type: 'jobs_assigned_to_inactive_users',
          message: 'Jobs assigned to inactive users',
          count: jobsWithInactiveUsers
        });
      }

      // Check for completed jobs without completion date
      const completedJobsWithoutDate = await prisma.job.count({
        where: {
          status: 'COMPLETED',
          completedAt: null
        }
      });

      if (completedJobsWithoutDate > 0) {
        issues.push({
          type: 'completed_jobs_missing_date',
          message: 'Completed jobs missing completion date',
          count: completedJobsWithoutDate
        });
      }

      // Check for invalid LINE User IDs
      const invalidLineUserIds = await prisma.customer.count({
        where: {
          lineUserId: {
            not: null,
            not: { startsWith: 'U' }
          }
        }
      });

      if (invalidLineUserIds > 0) {
        issues.push({
          type: 'invalid_line_user_ids',
          message: 'Customers with invalid LINE User ID format',
          count: invalidLineUserIds
        });
      }

      return {
        valid: issues.length === 0,
        issues
      };

    } catch (error) {
      issues.push({
        type: 'validation_error',
        message: `Data consistency check failed: ${(error as Error).message}`
      });

      return { valid: false, issues };
    }
  }
}

// =============================================================================
// SCHEMA VALIDATION UTILITIES
// =============================================================================

/**
 * Main schema validator class
 */
export class SchemaValidator {
  /**
   * Validate entity data against schema
   */
  static validate<T>(
    entityType: keyof typeof ValidationSchemas,
    data: unknown
  ): { valid: boolean; data?: T; errors?: string[] } {
    try {
      const schema = ValidationSchemas[entityType];
      const result = schema.safeParse(data);

      if (result.success) {
        return { valid: true, data: result.data as T };
      } else {
        const errors = result.error.errors.map(err =>
          `${err.path.join('.')}: ${err.message}`
        );
        return { valid: false, errors };
      }

    } catch (error) {
      return {
        valid: false,
        errors: [`Validation error: ${(error as Error).message}`]
      };
    }
  }

  /**
   * Validate multiple entities in a batch
   */
  static validateBatch(
    validations: Array<{
      entityType: keyof typeof ValidationSchemas;
      data: unknown;
      id?: string;
    }>
  ): {
    valid: boolean;
    results: Array<{
      id?: string;
      entityType: string;
      valid: boolean;
      errors?: string[];
    }>;
  } {
    const results = validations.map(({ entityType, data, id }) => {
      const validation = this.validate(entityType, data);
      return {
        id,
        entityType,
        valid: validation.valid,
        errors: validation.errors
      };
    });

    return {
      valid: results.every(r => r.valid),
      results
    };
  }

  /**
   * Validate foreign key relationships
   */
  static async validateForeignKeys(
    entityType: string,
    data: Record<string, any>
  ): Promise<{ valid: boolean; errors?: string[] }> {
    const errors: string[] = [];

    try {
      switch (entityType) {
        case 'job':
          // Validate customer exists
          if (data.customerId) {
            const customer = await prisma.customer.findUnique({
              where: { id: data.customerId }
            });
            if (!customer) {
              errors.push('Customer not found');
            }
          }

          // Validate assigned user exists
          if (data.assignedToId) {
            const user = await prisma.user.findUnique({
              where: { id: data.assignedToId }
            });
            if (!user) {
              errors.push('Assigned user not found');
            } else if (!user.isActive) {
              errors.push('Cannot assign to inactive user');
            }
          }
          break;

        case 'qualityCheck':
          // Validate job exists
          if (data.jobId) {
            const job = await prisma.job.findUnique({
              where: { id: data.jobId }
            });
            if (!job) {
              errors.push('Job not found');
            }
          }

          // Validate checklist exists
          if (data.checklistId) {
            const checklist = await prisma.qualityChecklist.findUnique({
              where: { id: data.checklistId }
            });
            if (!checklist) {
              errors.push('Quality checklist not found');
            } else if (!checklist.isActive) {
              errors.push('Cannot use inactive checklist');
            }
          }
          break;

        case 'trainingWorkflow':
          // Validate job exists
          if (data.jobId) {
            const job = await prisma.job.findUnique({
              where: { id: data.jobId }
            });
            if (!job) {
              errors.push('Job not found');
            }
          }
          break;
      }

      return { valid: errors.length === 0, errors: errors.length > 0 ? errors : undefined };

    } catch (error) {
      return {
        valid: false,
        errors: [`Foreign key validation failed: ${(error as Error).message}`]
      };
    }
  }

  /**
   * Run comprehensive schema validation
   */
  static async runComprehensiveValidation(): Promise<{
    valid: boolean;
    summary: {
      schemaIssues: number;
      dataConsistencyIssues: number;
      foreignKeyIssues: number;
    };
    details: {
      schemaValidation: any[];
      dataConsistency: any;
      recommendations: string[];
    };
  }> {
    console.log('🔍 Running comprehensive schema validation...');

    // Check data consistency
    const consistencyCheck = await BusinessValidation.validateDataConsistency();

    // Generate recommendations
    const recommendations: string[] = [];

    if (!consistencyCheck.valid) {
      recommendations.push('Fix data consistency issues before production deployment');

      consistencyCheck.issues.forEach(issue => {
        switch (issue.type) {
          case 'orphaned_jobs':
            recommendations.push('Clean up orphaned jobs or restore missing customer records');
            break;
          case 'jobs_assigned_to_inactive_users':
            recommendations.push('Reassign jobs from inactive users to active team members');
            break;
          case 'completed_jobs_missing_date':
            recommendations.push('Add completion dates to completed jobs for accurate reporting');
            break;
          case 'invalid_line_user_ids':
            recommendations.push('Fix LINE User ID format or remove invalid entries');
            break;
        }
      });
    } else {
      recommendations.push('✅ Schema validation passed - database is in good health');
    }

    // Add general recommendations
    recommendations.push('Set up automated schema validation in CI/CD pipeline');
    recommendations.push('Enable database constraint checking in production');
    recommendations.push('Schedule weekly data consistency checks');

    return {
      valid: consistencyCheck.valid,
      summary: {
        schemaIssues: 0, // Would be populated by actual schema checks
        dataConsistencyIssues: consistencyCheck.issues.length,
        foreignKeyIssues: 0 // Would be populated by FK validation
      },
      details: {
        schemaValidation: [], // Would contain schema-level validation results
        dataConsistency: consistencyCheck,
        recommendations
      }
    };
  }
}

// Export main validation functions
export const validateEntity = SchemaValidator.validate;
export const validateBatch = SchemaValidator.validateBatch;
export const validateForeignKeys = SchemaValidator.validateForeignKeys;
export const runSchemaValidation = SchemaValidator.runComprehensiveValidation;

export default {
  ValidationSchemas,
  BusinessValidation,
  SchemaValidator,
  validateEntity,
  validateBatch,
  validateForeignKeys,
  runSchemaValidation
};