// Database Constraint Validation for Tinedy CRM
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// =============================================================================
// DATABASE CONSTRAINT DEFINITIONS
// =============================================================================

/**
 * Database constraint validation rules
 */
export const DatabaseConstraints = {
  // Customer constraints
  customer: {
    required: ['name'],
    unique: ['lineUserId'],
    maxLengths: {
      name: 255,
      phone: 20,
      email: 255,
      address: 1000,
      notes: 2000
    },
    patterns: {
      lineUserId: /^U[a-fA-F0-9]{32}$/,
      phone: /^(\+66|0)[0-9]{8,9}$/,
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      name: /^[\u0E00-\u0E7Fa-zA-Z\s\-\.]+$/
    },
    businessRules: {
      statusTransitions: {
        'ACTIVE': ['INACTIVE', 'BLOCKED'],
        'INACTIVE': ['ACTIVE', 'BLOCKED'],
        'BLOCKED': ['ACTIVE', 'INACTIVE']
      }
    }
  },

  // Job constraints
  job: {
    required: ['customerId', 'serviceType'],
    foreignKeys: {
      customerId: 'customers.id',
      assignedToId: 'users.id'
    },
    maxLengths: {
      serviceType: 255,
      description: 2000,
      n8nWorkflowId: 255
    },
    businessRules: {
      statusTransitions: {
        'NEW': ['IN_PROGRESS', 'CANCELLED'],
        'IN_PROGRESS': ['COMPLETED', 'ON_HOLD', 'CANCELLED'],
        'ON_HOLD': ['IN_PROGRESS', 'CANCELLED'],
        'COMPLETED': [], // Final state
        'CANCELLED': []  // Final state
      },
      assignmentRules: {
        'TRAINING': ['à¸à¸¶à¸à¸­à¸šà¸£à¸¡', 'Training', 'à¸­à¸šà¸£à¸¡'],
        'QC_MANAGER': ['à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¸¸à¸“à¸ à¸²à¸ž', 'Quality Check'],
        'OPERATIONS': ['*'] // Can handle any service type
      }
    },
    dateLogic: {
      completedAt: 'Required when status is COMPLETED',
      scheduledAt: 'Cannot be in the past for NEW jobs'
    }
  },

  // User constraints
  user: {
    required: ['email', 'name', 'role'],
    unique: ['email'],
    maxLengths: {
      email: 255,
      name: 255
    },
    patterns: {
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      name: /^[\u0E00-\u0E7Fa-zA-Z\s\-\.]+$/
    },
    businessRules: {
      rolePermissions: {
        'ADMIN': ['*'],
        'QC_MANAGER': ['quality-checks', 'audit-logs'],
        'TRAINING': ['training-workflows'],
        'OPERATIONS': ['jobs', 'customers']
      }
    }
  },

  // Quality Check constraints
  qualityCheck: {
    required: ['jobId', 'checklistId'],
    foreignKeys: {
      jobId: 'jobs.id',
      checklistId: 'quality_checklists.id',
      completedBy: 'users.id'
    },
    maxLengths: {
      notes: 2000
    },
    businessRules: {
      statusTransitions: {
        'PENDING': ['IN_PROGRESS', 'PASSED', 'FAILED'],
        'IN_PROGRESS': ['PASSED', 'FAILED', 'NEEDS_REVIEW'],
        'PASSED': [], // Final state
        'FAILED': ['NEEDS_REVIEW'],
        'NEEDS_REVIEW': ['PASSED', 'FAILED']
      },
      completionRules: {
        requiredForPassed: ['completedBy', 'completedAt'],
        requiredForFailed: ['completedBy', 'completedAt', 'notes']
      }
    }
  },

  // Training Workflow constraints
  trainingWorkflow: {
    required: ['jobId'],
    foreignKeys: {
      jobId: 'jobs.id'
    },
    maxLengths: {
      notes: 2000
    },
    businessRules: {
      statusTransitions: {
        'AWAITING_DOCUMENTS': ['DOCUMENTS_RECEIVED'],
        'DOCUMENTS_RECEIVED': ['TRAINING_IN_PROGRESS'],
        'TRAINING_IN_PROGRESS': ['TRAINING_COMPLETED'],
        'TRAINING_COMPLETED': ['COMPLETED'],
        'COMPLETED': [] // Final state
      },
      logicRules: {
        documentsReceived: 'Must be true when status >= DOCUMENTS_RECEIVED',
        trainingCompleted: 'Must be true when status >= TRAINING_COMPLETED'
      }
    }
  },

  // Webhook Log constraints
  webhookLog: {
    required: ['source', 'payload'],
    foreignKeys: {
      createdJobId: 'jobs.id'
    },
    maxLengths: {
      source: 100,
      workflowId: 255,
      executionId: 255,
      errorMessage: 2000
    },
    businessRules: {
      retryLimits: {
        maxRetryCount: 10,
        retryableStatuses: ['FAILED', 'RETRY_NEEDED']
      },
      statusTransitions: {
        'RECEIVED': ['PROCESSING', 'FAILED'],
        'PROCESSING': ['PROCESSED', 'FAILED'],
        'PROCESSED': [], // Final state
        'FAILED': ['RETRY_NEEDED'],
        'RETRY_NEEDED': ['PROCESSING', 'FAILED']
      }
    }
  },

  // Audit Log constraints
  auditLog: {
    required: ['entityType', 'entityId', 'action'],
    foreignKeys: {
      userId: 'users.id'
    },
    maxLengths: {
      entityType: 100,
      entityId: 255,
      action: 100
    },
    businessRules: {
      immutableFields: ['timestamp', 'entityType', 'entityId', 'action'],
      requiredForActions: {
        'CREATE': ['newValues'],
        'UPDATE': ['oldValues', 'newValues'],
        'DELETE': ['oldValues']
      }
    }
  }
};

// =============================================================================
// CONSTRAINT VALIDATION ENGINE
// =============================================================================

/**
 * Database constraint validator
 */
export class ConstraintValidator {
  /**
   * Validate required fields
   */
  static validateRequired(
    entityType: keyof typeof DatabaseConstraints,
    data: Record<string, any>
  ): { valid: boolean; missingFields?: string[] } {
    const constraints = DatabaseConstraints[entityType];
    const required = constraints.required || [];
    const missingFields: string[] = [];

    required.forEach(field => {
      if (data[field] === undefined || data[field] === null || data[field] === '') {
        missingFields.push(field);
      }
    });

    return {
      valid: missingFields.length === 0,
      missingFields: missingFields.length > 0 ? missingFields : undefined
    };
  }

  /**
   * Validate field lengths
   */
  static validateLengths(
    entityType: keyof typeof DatabaseConstraints,
    data: Record<string, any>
  ): { valid: boolean; violations?: Array<{ field: string; length: number; max: number }> } {
    const constraints = DatabaseConstraints[entityType];
    const maxLengths = constraints.maxLengths || {};
    const violations: Array<{ field: string; length: number; max: number }> = [];

    Object.entries(maxLengths).forEach(([field, maxLength]) => {
      const value = data[field];
      if (typeof value === 'string' && value.length > maxLength) {
        violations.push({
          field,
          length: value.length,
          max: maxLength
        });
      }
    });

    return {
      valid: violations.length === 0,
      violations: violations.length > 0 ? violations : undefined
    };
  }

  /**
   * Validate field patterns
   */
  static validatePatterns(
    entityType: keyof typeof DatabaseConstraints,
    data: Record<string, any>
  ): { valid: boolean; violations?: Array<{ field: string; value: string; pattern: string }> } {
    const constraints = DatabaseConstraints[entityType];
    const patterns = constraints.patterns || {};
    const violations: Array<{ field: string; value: string; pattern: string }> = [];

    Object.entries(patterns).forEach(([field, pattern]) => {
      const value = data[field];
      if (value && typeof value === 'string' && !pattern.test(value)) {
        violations.push({
          field,
          value,
          pattern: pattern.toString()
        });
      }
    });

    return {
      valid: violations.length === 0,
      violations: violations.length > 0 ? violations : undefined
    };
  }

  /**
   * Validate foreign key constraints
   */
  static async validateForeignKeys(
    entityType: keyof typeof DatabaseConstraints,
    data: Record<string, any>
  ): Promise<{ valid: boolean; violations?: Array<{ field: string; value: string; table: string }> }> {
    const constraints = DatabaseConstraints[entityType];
    const foreignKeys = constraints.foreignKeys || {};
    const violations: Array<{ field: string; value: string; table: string }> = [];

    for (const [field, tableColumn] of Object.entries(foreignKeys)) {
      const value = data[field];
      if (!value) continue; // Skip null/undefined values

      const [table] = tableColumn.split('.');

      try {
        let exists = false;

        switch (table) {
          case 'customers':
            exists = !!(await prisma.customer.findUnique({ where: { id: value } }));
            break;
          case 'users':
            exists = !!(await prisma.user.findUnique({ where: { id: value } }));
            break;
          case 'jobs':
            exists = !!(await prisma.job.findUnique({ where: { id: value } }));
            break;
          case 'quality_checklists':
            exists = !!(await prisma.qualityChecklist.findUnique({ where: { id: value } }));
            break;
          default:
            console.warn(`Unknown table for FK validation: ${table}`);
            continue;
        }

        if (!exists) {
          violations.push({
            field,
            value,
            table
          });
        }

      } catch (error) {
        console.error(`FK validation error for ${field}:`, error);
        violations.push({
          field,
          value,
          table: `${table} (validation error)`
        });
      }
    }

    return {
      valid: violations.length === 0,
      violations: violations.length > 0 ? violations : undefined
    };
  }

  /**
   * Validate business rules
   */
  static async validateBusinessRules(
    entityType: keyof typeof DatabaseConstraints,
    data: Record<string, any>,
    context?: { currentData?: Record<string, any>; operation?: 'CREATE' | 'UPDATE' }
  ): Promise<{ valid: boolean; violations?: string[] }> {
    const constraints = DatabaseConstraints[entityType];
    const businessRules = constraints.businessRules || {};
    const violations: string[] = [];

    // Validate status transitions
    if (businessRules.statusTransitions && data.status && context?.currentData?.status) {
      const currentStatus = context.currentData.status;
      const newStatus = data.status;
      const allowedTransitions = businessRules.statusTransitions[currentStatus] || [];

      if (!allowedTransitions.includes(newStatus)) {
        violations.push(`Invalid status transition from ${currentStatus} to ${newStatus}`);
      }
    }

    // Validate assignment rules for jobs
    if (entityType === 'job' && data.assignedToId && data.serviceType) {
      const user = await prisma.user.findUnique({
        where: { id: data.assignedToId },
        select: { role: true }
      });

      if (user) {
        const assignmentRules = businessRules.assignmentRules || {};
        const allowedServices = assignmentRules[user.role] || [];

        if (!allowedServices.includes('*')) {
          const isServiceAllowed = allowedServices.some(service =>
            data.serviceType.includes(service)
          );

          if (!isServiceAllowed) {
            violations.push(`User role ${user.role} cannot handle service type: ${data.serviceType}`);
          }
        }
      }
    }

    // Validate completion requirements for quality checks
    if (entityType === 'qualityCheck' && data.status) {
      const completionRules = businessRules.completionRules || {};

      if (data.status === 'PASSED' && completionRules.requiredForPassed) {
        completionRules.requiredForPassed.forEach((field: string) => {
          if (!data[field]) {
            violations.push(`${field} is required when quality check is marked as PASSED`);
          }
        });
      }

      if (data.status === 'FAILED' && completionRules.requiredForFailed) {
        completionRules.requiredForFailed.forEach((field: string) => {
          if (!data[field]) {
            violations.push(`${field} is required when quality check is marked as FAILED`);
          }
        });
      }
    }

    // Validate training workflow logic
    if (entityType === 'trainingWorkflow') {
      const logicRules = businessRules.logicRules || {};

      if (logicRules.documentsReceived &&
          ['DOCUMENTS_RECEIVED', 'TRAINING_IN_PROGRESS', 'TRAINING_COMPLETED', 'COMPLETED'].includes(data.status) &&
          !data.documentsReceived) {
        violations.push('documentsReceived must be true for status >= DOCUMENTS_RECEIVED');
      }

      if (logicRules.trainingCompleted &&
          ['TRAINING_COMPLETED', 'COMPLETED'].includes(data.status) &&
          !data.trainingCompleted) {
        violations.push('trainingCompleted must be true for status >= TRAINING_COMPLETED');
      }
    }

    return {
      valid: violations.length === 0,
      violations: violations.length > 0 ? violations : undefined
    };
  }

  /**
   * Comprehensive constraint validation
   */
  static async validateAll(
    entityType: keyof typeof DatabaseConstraints,
    data: Record<string, any>,
    context?: { currentData?: Record<string, any>; operation?: 'CREATE' | 'UPDATE' }
  ): Promise<{
    valid: boolean;
    errors: {
      required?: string[];
      lengths?: Array<{ field: string; length: number; max: number }>;
      patterns?: Array<{ field: string; value: string; pattern: string }>;
      foreignKeys?: Array<{ field: string; value: string; table: string }>;
      businessRules?: string[];
    };
  }> {
    const [
      requiredValidation,
      lengthValidation,
      patternValidation,
      foreignKeyValidation,
      businessRuleValidation
    ] = await Promise.all([
      Promise.resolve(this.validateRequired(entityType, data)),
      Promise.resolve(this.validateLengths(entityType, data)),
      Promise.resolve(this.validatePatterns(entityType, data)),
      this.validateForeignKeys(entityType, data),
      this.validateBusinessRules(entityType, data, context)
    ]);

    const errors: any = {};

    if (!requiredValidation.valid) {
      errors.required = requiredValidation.missingFields;
    }

    if (!lengthValidation.valid) {
      errors.lengths = lengthValidation.violations;
    }

    if (!patternValidation.valid) {
      errors.patterns = patternValidation.violations;
    }

    if (!foreignKeyValidation.valid) {
      errors.foreignKeys = foreignKeyValidation.violations;
    }

    if (!businessRuleValidation.valid) {
      errors.businessRules = businessRuleValidation.violations;
    }

    const valid = Object.keys(errors).length === 0;

    return { valid, errors };
  }
}

// =============================================================================
// CONSTRAINT CHECKING UTILITIES
// =============================================================================

/**
 * Check database referential integrity
 */
export async function checkReferentialIntegrity(): Promise<{
  valid: boolean;
  issues: Array<{
    table: string;
    field: string;
    invalidReferences: number;
    description: string;
  }>;
}> {
  const issues: Array<{
    table: string;
    field: string;
    invalidReferences: number;
    description: string;
  }> = [];

  try {
    // Check jobs.customerId references
    const invalidJobCustomers = await prisma.$queryRaw<Array<{ count: bigint }>>`
      SELECT COUNT(*) as count
      FROM jobs j
      LEFT JOIN customers c ON j.customer_id = c.id
      WHERE c.id IS NULL
    `;

    if (Number(invalidJobCustomers[0].count) > 0) {
      issues.push({
        table: 'jobs',
        field: 'customer_id',
        invalidReferences: Number(invalidJobCustomers[0].count),
        description: 'Jobs referencing non-existent customers'
      });
    }

    // Check jobs.assignedToId references
    const invalidJobAssignees = await prisma.$queryRaw<Array<{ count: bigint }>>`
      SELECT COUNT(*) as count
      FROM jobs j
      LEFT JOIN users u ON j.assigned_to_id = u.id
      WHERE j.assigned_to_id IS NOT NULL AND u.id IS NULL
    `;

    if (Number(invalidJobAssignees[0].count) > 0) {
      issues.push({
        table: 'jobs',
        field: 'assigned_to_id',
        invalidReferences: Number(invalidJobAssignees[0].count),
        description: 'Jobs assigned to non-existent users'
      });
    }

    // Check quality_checks.jobId references
    const invalidQCJobs = await prisma.$queryRaw<Array<{ count: bigint }>>`
      SELECT COUNT(*) as count
      FROM quality_checks qc
      LEFT JOIN jobs j ON qc.job_id = j.id
      WHERE j.id IS NULL
    `;

    if (Number(invalidQCJobs[0].count) > 0) {
      issues.push({
        table: 'quality_checks',
        field: 'job_id',
        invalidReferences: Number(invalidQCJobs[0].count),
        description: 'Quality checks referencing non-existent jobs'
      });
    }

    // Check training_workflows.jobId references
    const invalidTrainingJobs = await prisma.$queryRaw<Array<{ count: bigint }>>`
      SELECT COUNT(*) as count
      FROM training_workflows tw
      LEFT JOIN jobs j ON tw.job_id = j.id
      WHERE j.id IS NULL
    `;

    if (Number(invalidTrainingJobs[0].count) > 0) {
      issues.push({
        table: 'training_workflows',
        field: 'job_id',
        invalidReferences: Number(invalidTrainingJobs[0].count),
        description: 'Training workflows referencing non-existent jobs'
      });
    }

    return {
      valid: issues.length === 0,
      issues
    };

  } catch (error) {
    console.error('Referential integrity check failed:', error);
    return {
      valid: false,
      issues: [{
        table: 'system',
        field: 'all',
        invalidReferences: 0,
        description: `Integrity check failed: ${(error as Error).message}`
      }]
    };
  }
}

/**
 * Generate constraint violation report
 */
export async function generateConstraintReport(): Promise<{
  summary: {
    totalTables: number;
    constraintViolations: number;
    referentialIntegrityIssues: number;
  };
  details: {
    referentialIntegrity: any;
    recommendations: string[];
  };
}> {
  console.log('ðŸ” Generating database constraint report...');

  const referentialIntegrity = await checkReferentialIntegrity();

  const recommendations: string[] = [];

  if (!referentialIntegrity.valid) {
    recommendations.push('Fix referential integrity issues before production deployment');

    referentialIntegrity.issues.forEach(issue => {
      recommendations.push(`Clean up ${issue.invalidReferences} invalid references in ${issue.table}.${issue.field}`);
    });
  } else {
    recommendations.push('âœ… Referential integrity is maintained across all tables');
  }

  recommendations.push('Enable foreign key constraints in production database');
  recommendations.push('Set up automated constraint validation in deployment pipeline');
  recommendations.push('Monitor constraint violations with database alerts');

  return {
    summary: {
      totalTables: Object.keys(DatabaseConstraints).length,
      constraintViolations: 0, // Would be populated by actual violation checks
      referentialIntegrityIssues: referentialIntegrity.issues.length
    },
    details: {
      referentialIntegrity,
      recommendations
    }
  };
}

export default {
  DatabaseConstraints,
  ConstraintValidator,
  checkReferentialIntegrity,
  generateConstraintReport
};