// Security Monitoring & Alerting System for Tinedy CRM
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import { logAuthEvent } from '../middleware/auth-utils';

const prisma = new PrismaClient();

interface SecurityEvent {
  type: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  source: string;
  details: Record<string, any>;
  timestamp: Date;
  userId?: string;
  ip?: string;
  userAgent?: string;
}

interface AlertConfig {
  threshold: number;
  timeWindow: number; // milliseconds
  enabled: boolean;
  channels: string[]; // email, slack, webhook
}

// Security monitoring configuration
const SECURITY_ALERTS: Record<string, AlertConfig> = {
  // Authentication failures
  'auth_failures': {
    threshold: 5,
    timeWindow: 15 * 60 * 1000, // 15 minutes
    enabled: true,
    channels: ['email', 'slack']
  },

  // SQL injection attempts
  'sql_injection_attempts': {
    threshold: 1,
    timeWindow: 60 * 1000, // 1 minute
    enabled: true,
    channels: ['email', 'slack', 'webhook']
  },

  // XSS attempts
  'xss_attempts': {
    threshold: 3,
    timeWindow: 5 * 60 * 1000, // 5 minutes
    enabled: true,
    channels: ['email', 'slack']
  },

  // Rate limit violations
  'rate_limit_exceeded': {
    threshold: 10,
    timeWindow: 10 * 60 * 1000, // 10 minutes
    enabled: true,
    channels: ['slack']
  },

  // Unauthorized access attempts
  'unauthorized_access': {
    threshold: 3,
    timeWindow: 5 * 60 * 1000, // 5 minutes
    enabled: true,
    channels: ['email', 'slack']
  },

  // Suspicious data access patterns
  'data_access_anomaly': {
    threshold: 1,
    timeWindow: 60 * 1000, // 1 minute
    enabled: true,
    channels: ['email', 'webhook']
  },

  // Admin privilege escalation
  'privilege_escalation': {
    threshold: 1,
    timeWindow: 60 * 1000, // 1 minute
    enabled: true,
    channels: ['email', 'slack', 'webhook']
  }
};

/**
 * Main Security Monitor Class
 */
export class SecurityMonitor {
  private eventBuffer: SecurityEvent[] = [];
  private alertsSent: Map<string, number> = new Map();

  /**
   * Record security event
   */
  async recordEvent(event: Omit<SecurityEvent, 'timestamp'>) {
    const securityEvent: SecurityEvent = {
      ...event,
      timestamp: new Date()
    };

    // Add to buffer
    this.eventBuffer.push(securityEvent);

    // Store in database
    await this.storeEvent(securityEvent);

    // Check for alert triggers
    await this.checkAlertTriggers(securityEvent);

    // Clean old events from buffer
    this.cleanEventBuffer();

    console.log(`🔍 Security Event Recorded: ${event.type}`, {
      severity: event.severity,
      source: event.source,
      userId: event.userId
    });
  }

  /**
   * Store security event in database
   */
  private async storeEvent(event: SecurityEvent) {
    try {
      await prisma.auditLog.create({
        data: {
          entityType: 'SecurityEvent',
          entityId: event.source,
          action: event.type,
          userId: event.userId,
          newValues: {
            severity: event.severity,
            details: event.details,
            ip: event.ip,
            userAgent: event.userAgent,
            timestamp: event.timestamp.toISOString()
          }
        }
      });
    } catch (error) {
      console.error('Failed to store security event:', error);
    }
  }

  /**
   * Check if security event should trigger alerts
   */
  private async checkAlertTriggers(event: SecurityEvent) {
    const config = SECURITY_ALERTS[event.type];
    if (!config?.enabled) return;

    // Count recent events of same type
    const recentEvents = this.eventBuffer.filter(e =>
      e.type === event.type &&
      Date.now() - e.timestamp.getTime() <= config.timeWindow
    );

    if (recentEvents.length >= config.threshold) {
      await this.triggerAlert(event.type, recentEvents, config);
    }
  }

  /**
   * Trigger security alert
   */
  private async triggerAlert(
    eventType: string,
    events: SecurityEvent[],
    config: AlertConfig
  ) {
    const alertKey = `${eventType}_${Math.floor(Date.now() / config.timeWindow)}`;

    // Prevent duplicate alerts in same time window
    if (this.alertsSent.has(alertKey)) return;

    this.alertsSent.set(alertKey, Date.now());

    const alertData = {
      eventType,
      count: events.length,
      timeWindow: config.timeWindow,
      firstEvent: events[0],
      lastEvent: events[events.length - 1],
      affectedIPs: [...new Set(events.map(e => e.ip).filter(Boolean))],
      affectedUsers: [...new Set(events.map(e => e.userId).filter(Boolean))]
    };

    console.warn(`🚨 SECURITY ALERT: ${eventType}`, alertData);

    // Send alerts through configured channels
    for (const channel of config.channels) {
      try {
        await this.sendAlert(channel, eventType, alertData);
      } catch (error) {
        console.error(`Failed to send alert via ${channel}:`, error);
      }
    }
  }

  /**
   * Send alert through specific channel
   */
  private async sendAlert(
    channel: string,
    eventType: string,
    alertData: any
  ) {
    switch (channel) {
      case 'email':
        await this.sendEmailAlert(eventType, alertData);
        break;
      case 'slack':
        await this.sendSlackAlert(eventType, alertData);
        break;
      case 'webhook':
        await this.sendWebhookAlert(eventType, alertData);
        break;
    }
  }

  /**
   * Send email alert
   */
  private async sendEmailAlert(eventType: string, alertData: any) {
    // TODO: Implement email alerting (use Resend, SendGrid, etc.)
    console.log('📧 Email Alert:', {
      to: process.env.SECURITY_ALERT_EMAIL,
      subject: `🚨 Security Alert: ${eventType}`,
      data: alertData
    });
  }

  /**
   * Send Slack alert
   */
  private async sendSlackAlert(eventType: string, alertData: any) {
    if (!process.env.SLACK_WEBHOOK_URL) return;

    try {
      const message = {
        text: `🚨 Security Alert: ${eventType}`,
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: `🚨 Security Alert: ${eventType}`
            }
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*Event Count:* ${alertData.count}`
              },
              {
                type: 'mrkdwn',
                text: `*Time Window:* ${alertData.timeWindow / 1000}s`
              },
              {
                type: 'mrkdwn',
                text: `*Affected IPs:* ${alertData.affectedIPs.join(', ') || 'Unknown'}`
              },
              {
                type: 'mrkdwn',
                text: `*Severity:* ${alertData.firstEvent.severity}`
              }
            ]
          },
          {
            type: 'context',
            elements: [
              {
                type: 'mrkdwn',
                text: `First event: ${alertData.firstEvent.timestamp}`
              }
            ]
          }
        ]
      };

      await fetch(process.env.SLACK_WEBHOOK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(message)
      });

    } catch (error) {
      console.error('Slack alert failed:', error);
    }
  }

  /**
   * Send webhook alert
   */
  private async sendWebhookAlert(eventType: string, alertData: any) {
    if (!process.env.SECURITY_WEBHOOK_URL) return;

    try {
      await fetch(process.env.SECURITY_WEBHOOK_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.SECURITY_WEBHOOK_TOKEN}`
        },
        body: JSON.stringify({
          event: eventType,
          timestamp: new Date().toISOString(),
          data: alertData,
          source: 'tinedy-crm'
        })
      });

    } catch (error) {
      console.error('Webhook alert failed:', error);
    }
  }

  /**
   * Clean old events from buffer
   */
  private cleanEventBuffer() {
    const maxAge = 60 * 60 * 1000; // 1 hour
    const cutoff = Date.now() - maxAge;

    this.eventBuffer = this.eventBuffer.filter(
      event => event.timestamp.getTime() > cutoff
    );

    // Clean old alert keys
    for (const [key, timestamp] of this.alertsSent.entries()) {
      if (Date.now() - timestamp > maxAge) {
        this.alertsSent.delete(key);
      }
    }
  }

  /**
   * Get security metrics
   */
  async getSecurityMetrics(hours = 24) {
    const since = new Date(Date.now() - (hours * 60 * 60 * 1000));

    const events = await prisma.auditLog.findMany({
      where: {
        entityType: 'SecurityEvent',
        timestamp: { gte: since }
      },
      orderBy: { timestamp: 'desc' }
    });

    const metrics = {
      totalEvents: events.length,
      eventsByType: {} as Record<string, number>,
      eventsBySeverity: {} as Record<string, number>,
      topIPs: {} as Record<string, number>,
      timeline: [] as Array<{ hour: string; count: number }>
    };

    // Process events
    events.forEach(event => {
      const data = event.newValues as any;

      // Count by type
      const type = event.action;
      metrics.eventsByType[type] = (metrics.eventsByType[type] || 0) + 1;

      // Count by severity
      const severity = data.severity || 'UNKNOWN';
      metrics.eventsBySeverity[severity] = (metrics.eventsBySeverity[severity] || 0) + 1;

      // Count by IP
      const ip = data.ip || 'unknown';
      metrics.topIPs[ip] = (metrics.topIPs[ip] || 0) + 1;
    });

    // Generate timeline
    for (let i = 0; i < hours; i++) {
      const hour = new Date(Date.now() - (i * 60 * 60 * 1000));
      const hourKey = hour.toISOString().slice(0, 13);

      const hourEvents = events.filter(e =>
        e.timestamp.toISOString().slice(0, 13) === hourKey
      );

      metrics.timeline.unshift({
        hour: hourKey,
        count: hourEvents.length
      });
    }

    return metrics;
  }

  /**
   * Force check for suspicious patterns
   */
  async runSecurityScan() {
    console.log('🔍 Running security scan...');

    const issues = [];

    // Check for suspicious login patterns
    const suspiciousLogins = await this.checkSuspiciousLogins();
    if (suspiciousLogins.length > 0) {
      issues.push({
        type: 'suspicious_login_patterns',
        severity: 'MEDIUM' as const,
        count: suspiciousLogins.length,
        details: suspiciousLogins
      });
    }

    // Check for data access anomalies
    const dataAnomalies = await this.checkDataAccessAnomalies();
    if (dataAnomalies.length > 0) {
      issues.push({
        type: 'data_access_anomalies',
        severity: 'HIGH' as const,
        count: dataAnomalies.length,
        details: dataAnomalies
      });
    }

    // Check for unauthorized admin actions
    const adminActions = await this.checkUnauthorizedAdminActions();
    if (adminActions.length > 0) {
      issues.push({
        type: 'unauthorized_admin_actions',
        severity: 'CRITICAL' as const,
        count: adminActions.length,
        details: adminActions
      });
    }

    // Record findings
    for (const issue of issues) {
      await this.recordEvent({
        type: issue.type,
        severity: issue.severity,
        source: 'security_scan',
        details: issue.details
      });
    }

    console.log(`🔍 Security scan complete. Found ${issues.length} issues.`);
    return issues;
  }

  /**
   * Check for suspicious login patterns
   */
  private async checkSuspiciousLogins() {
    const oneHourAgo = new Date(Date.now() - (60 * 60 * 1000));

    // Multiple failed logins from same IP
    const failedLogins = await prisma.auditLog.findMany({
      where: {
        action: 'login_failure',
        timestamp: { gte: oneHourAgo }
      }
    });

    const ipCounts = failedLogins.reduce((acc, log) => {
      const ip = (log.newValues as any)?.ip || 'unknown';
      acc[ip] = (acc[ip] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return Object.entries(ipCounts)
      .filter(([_, count]) => count >= 5)
      .map(([ip, count]) => ({ ip, attempts: count }));
  }

  /**
   * Check for data access anomalies
   */
  private async checkDataAccessAnomalies() {
    const oneHourAgo = new Date(Date.now() - (60 * 60 * 1000));

    // Unusual volume of data access
    const dataAccess = await prisma.auditLog.findMany({
      where: {
        action: 'READ',
        timestamp: { gte: oneHourAgo }
      }
    });

    const userCounts = dataAccess.reduce((acc, log) => {
      const userId = log.userId || 'unknown';
      acc[userId] = (acc[userId] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return Object.entries(userCounts)
      .filter(([_, count]) => count >= 100) // High threshold for data access
      .map(([userId, count]) => ({ userId, accessCount: count }));
  }

  /**
   * Check for unauthorized admin actions
   */
  private async checkUnauthorizedAdminActions() {
    const oneHourAgo = new Date(Date.now() - (60 * 60 * 1000));

    // Check for admin actions by non-admin users
    const adminActions = await prisma.auditLog.findMany({
      where: {
        action: { in: ['CREATE', 'UPDATE', 'DELETE'] },
        entityType: { in: ['User', 'System'] },
        timestamp: { gte: oneHourAgo }
      },
      include: {
        user: {
          select: { role: true, name: true }
        }
      }
    });

    return adminActions
      .filter(action => action.user?.role !== 'ADMIN')
      .map(action => ({
        userId: action.userId,
        userName: action.user?.name,
        userRole: action.user?.role,
        action: action.action,
        entityType: action.entityType
      }));
  }
}

// Export singleton instance
export const securityMonitor = new SecurityMonitor();

// Helper functions for common security events
export async function recordAuthFailure(ip: string, userAgent: string, details?: any) {
  await securityMonitor.recordEvent({
    type: 'auth_failures',
    severity: 'MEDIUM',
    source: 'authentication',
    details: { reason: 'invalid_credentials', ...details },
    ip,
    userAgent
  });
}

export async function recordSQLInjectionAttempt(ip: string, userAgent: string, payload: string) {
  await securityMonitor.recordEvent({
    type: 'sql_injection_attempts',
    severity: 'CRITICAL',
    source: 'api_request',
    details: { payload: payload.substring(0, 200) },
    ip,
    userAgent
  });
}

export async function recordXSSAttempt(ip: string, userAgent: string, payload: string) {
  await securityMonitor.recordEvent({
    type: 'xss_attempts',
    severity: 'HIGH',
    source: 'api_request',
    details: { payload: payload.substring(0, 200) },
    ip,
    userAgent
  });
}

export async function recordUnauthorizedAccess(userId: string, resource: string, ip: string) {
  await securityMonitor.recordEvent({
    type: 'unauthorized_access',
    severity: 'HIGH',
    source: 'authorization',
    details: { resource, action: 'access_denied' },
    userId,
    ip
  });
}

export async function recordDataAccessAnomaly(userId: string, details: any) {
  await securityMonitor.recordEvent({
    type: 'data_access_anomaly',
    severity: 'MEDIUM',
    source: 'data_access',
    details,
    userId
  });
}

export async function recordPrivilegeEscalation(userId: string, fromRole: string, toRole: string) {
  await securityMonitor.recordEvent({
    type: 'privilege_escalation',
    severity: 'CRITICAL',
    source: 'user_management',
    details: { fromRole, toRole },
    userId
  });
}

export default {
  SecurityMonitor,
  securityMonitor,
  recordAuthFailure,
  recordSQLInjectionAttempt,
  recordXSSAttempt,
  recordUnauthorizedAccess,
  recordDataAccessAnomaly,
  recordPrivilegeEscalation
};