// Security Dashboard Data Provider
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import { securityMonitor } from './security-monitor';

const prisma = new PrismaClient();

export interface SecurityDashboardData {
  overview: {
    totalEvents: number;
    criticalEvents: number;
    activeThreats: number;
    systemHealth: 'GOOD' | 'WARNING' | 'CRITICAL';
  };
  recentEvents: Array<{
    id: string;
    type: string;
    severity: string;
    timestamp: Date;
    details: any;
  }>;
  threatTrends: Array<{
    date: string;
    authFailures: number;
    suspiciousActivity: number;
    blockedRequests: number;
  }>;
  topThreats: Array<{
    type: string;
    count: number;
    severity: string;
    lastSeen: Date;
  }>;
  userActivity: Array<{
    userId: string;
    userName: string;
    role: string;
    activityCount: number;
    riskScore: number;
  }>;
  systemMetrics: {
    averageResponseTime: number;
    errorRate: number;
    requestsPerMinute: number;
    blockedRequests: number;
  };
}

/**
 * Security Dashboard Provider
 */
export class SecurityDashboardProvider {
  /**
   * Get complete dashboard data
   */
  async getDashboardData(timeRange: number = 24): Promise<SecurityDashboardData> {
    const hours = timeRange;
    const since = new Date(Date.now() - (hours * 60 * 60 * 1000));

    const [
      overview,
      recentEvents,
      threatTrends,
      topThreats,
      userActivity,
      systemMetrics
    ] = await Promise.all([
      this.getOverview(since),
      this.getRecentEvents(since),
      this.getThreatTrends(since),
      this.getTopThreats(since),
      this.getUserActivity(since),
      this.getSystemMetrics(since)
    ]);

    return {
      overview,
      recentEvents,
      threatTrends,
      topThreats,
      userActivity,
      systemMetrics
    };
  }

  /**
   * Get security overview
   */
  private async getOverview(since: Date) {
    const events = await prisma.auditLog.findMany({
      where: {
        entityType: 'SecurityEvent',
        timestamp: { gte: since }
      }
    });

    const criticalEvents = events.filter(e =>
      (e.newValues as any)?.severity === 'CRITICAL'
    ).length;

    const highSeverityEvents = events.filter(e =>
      ['CRITICAL', 'HIGH'].includes((e.newValues as any)?.severity)
    ).length;

    let systemHealth: 'GOOD' | 'WARNING' | 'CRITICAL' = 'GOOD';
    if (criticalEvents > 0) {
      systemHealth = 'CRITICAL';
    } else if (highSeverityEvents > 5) {
      systemHealth = 'WARNING';
    }

    return {
      totalEvents: events.length,
      criticalEvents,
      activeThreats: highSeverityEvents,
      systemHealth
    };
  }

  /**
   * Get recent security events
   */
  private async getRecentEvents(since: Date) {
    const events = await prisma.auditLog.findMany({
      where: {
        entityType: 'SecurityEvent',
        timestamp: { gte: since }
      },
      orderBy: { timestamp: 'desc' },
      take: 20
    });

    return events.map(event => ({
      id: event.id,
      type: event.action,
      severity: (event.newValues as any)?.severity || 'UNKNOWN',
      timestamp: event.timestamp,
      details: event.newValues
    }));
  }

  /**
   * Get threat trends over time
   */
  private async getThreatTrends(since: Date) {
    const events = await prisma.auditLog.findMany({
      where: {
        entityType: 'SecurityEvent',
        timestamp: { gte: since }
      }
    });

    // Group by day
    const trends: Record<string, {
      authFailures: number;
      suspiciousActivity: number;
      blockedRequests: number;
    }> = {};

    events.forEach(event => {
      const date = event.timestamp.toISOString().split('T')[0];
      if (!trends[date]) {
        trends[date] = { authFailures: 0, suspiciousActivity: 0, blockedRequests: 0 };
      }

      switch (event.action) {
        case 'auth_failures':
          trends[date].authFailures++;
          break;
        case 'rate_limit_exceeded':
          trends[date].blockedRequests++;
          break;
        default:
          trends[date].suspiciousActivity++;
      }
    });

    return Object.entries(trends).map(([date, data]) => ({
      date,
      ...data
    })).sort((a, b) => a.date.localeCompare(b.date));
  }

  /**
   * Get top threat types
   */
  private async getTopThreats(since: Date) {
    const events = await prisma.auditLog.findMany({
      where: {
        entityType: 'SecurityEvent',
        timestamp: { gte: since }
      }
    });

    const threatCounts: Record<string, {
      count: number;
      severity: string;
      lastSeen: Date;
    }> = {};

    events.forEach(event => {
      const type = event.action;
      const severity = (event.newValues as any)?.severity || 'UNKNOWN';

      if (!threatCounts[type]) {
        threatCounts[type] = {
          count: 0,
          severity,
          lastSeen: event.timestamp
        };
      }

      threatCounts[type].count++;
      if (event.timestamp > threatCounts[type].lastSeen) {
        threatCounts[type].lastSeen = event.timestamp;
        threatCounts[type].severity = severity;
      }
    });

    return Object.entries(threatCounts)
      .map(([type, data]) => ({ type, ...data }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
  }

  /**
   * Get user activity analysis
   */
  private async getUserActivity(since: Date) {
    const activities = await prisma.auditLog.findMany({
      where: {
        timestamp: { gte: since },
        userId: { not: null }
      },
      include: {
        user: {
          select: { name: true, role: true }
        }
      }
    });

    const userStats: Record<string, {
      name: string;
      role: string;
      activityCount: number;
      securityEvents: number;
      suspiciousActions: number;
    }> = {};

    activities.forEach(activity => {
      const userId = activity.userId!;
      const userName = activity.user?.name || 'Unknown';
      const userRole = activity.user?.role || 'Unknown';

      if (!userStats[userId]) {
        userStats[userId] = {
          name: userName,
          role: userRole,
          activityCount: 0,
          securityEvents: 0,
          suspiciousActions: 0
        };
      }

      userStats[userId].activityCount++;

      if (activity.entityType === 'SecurityEvent') {
        userStats[userId].securityEvents++;
      }

      // Check for suspicious actions
      if (['DELETE', 'UPDATE'].includes(activity.action) &&
          ['User', 'System'].includes(activity.entityType)) {
        userStats[userId].suspiciousActions++;
      }
    });

    return Object.entries(userStats)
      .map(([userId, stats]) => ({
        userId,
        userName: stats.name,
        role: stats.role,
        activityCount: stats.activityCount,
        riskScore: this.calculateRiskScore(stats)
      }))
      .sort((a, b) => b.riskScore - a.riskScore)
      .slice(0, 20);
  }

  /**
   * Calculate user risk score
   */
  private calculateRiskScore(stats: {
    activityCount: number;
    securityEvents: number;
    suspiciousActions: number;
  }): number {
    let score = 0;

    // High activity
    if (stats.activityCount > 100) score += 2;
    else if (stats.activityCount > 50) score += 1;

    // Security events
    score += stats.securityEvents * 5;

    // Suspicious actions
    score += stats.suspiciousActions * 3;

    return Math.min(score, 100); // Cap at 100
  }

  /**
   * Get system performance metrics
   */
  private async getSystemMetrics(since: Date) {
    // Get API performance data
    const apiLogs = await prisma.auditLog.findMany({
      where: {
        timestamp: { gte: since },
        entityType: { not: 'SecurityEvent' }
      }
    });

    // Get security events for blocked requests
    const securityEvents = await prisma.auditLog.findMany({
      where: {
        entityType: 'SecurityEvent',
        timestamp: { gte: since }
      }
    });

    const totalRequests = apiLogs.length;
    const errorCount = apiLogs.filter(log =>
      ['ERROR', 'FAILED'].includes(log.action)
    ).length;

    const blockedRequests = securityEvents.filter(event =>
      ['rate_limit_exceeded', 'unauthorized_access'].includes(event.action)
    ).length;

    const timeSpanHours = (Date.now() - since.getTime()) / (1000 * 60 * 60);
    const requestsPerMinute = totalRequests / (timeSpanHours * 60);

    return {
      averageResponseTime: 150, // TODO: Calculate from actual response times
      errorRate: totalRequests > 0 ? (errorCount / totalRequests) * 100 : 0,
      requestsPerMinute: Math.round(requestsPerMinute),
      blockedRequests
    };
  }

  /**
   * Get real-time security status
   */
  async getSecurityStatus() {
    const lastHour = new Date(Date.now() - (60 * 60 * 1000));

    const recentEvents = await prisma.auditLog.findMany({
      where: {
        entityType: 'SecurityEvent',
        timestamp: { gte: lastHour }
      }
    });

    const criticalEvents = recentEvents.filter(e =>
      (e.newValues as any)?.severity === 'CRITICAL'
    );

    const activeIncidents = criticalEvents.length;
    const threatLevel = this.calculateThreatLevel(recentEvents);

    return {
      status: threatLevel,
      activeIncidents,
      lastUpdate: new Date(),
      recentCriticalEvents: criticalEvents.slice(0, 5),
      recommendations: this.getSecurityRecommendations(recentEvents)
    };
  }

  /**
   * Calculate current threat level
   */
  private calculateThreatLevel(events: any[]): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    const criticalCount = events.filter(e =>
      (e.newValues as any)?.severity === 'CRITICAL'
    ).length;

    const highCount = events.filter(e =>
      (e.newValues as any)?.severity === 'HIGH'
    ).length;

    if (criticalCount > 0) return 'CRITICAL';
    if (highCount > 3) return 'HIGH';
    if (events.length > 10) return 'MEDIUM';
    return 'LOW';
  }

  /**
   * Get security recommendations
   */
  private getSecurityRecommendations(events: any[]): string[] {
    const recommendations: string[] = [];
    const eventTypes = events.map(e => e.action);

    if (eventTypes.includes('auth_failures')) {
      recommendations.push('ตรวจสอบการเข้าสู่ระบบที่ผิดพลาดซ้ำๆ - อาจเป็นการโจมตี brute force');
    }

    if (eventTypes.includes('sql_injection_attempts')) {
      recommendations.push('พบความพยายาม SQL injection - ตรวจสอบ input validation');
    }

    if (eventTypes.includes('rate_limit_exceeded')) {
      recommendations.push('มีการเข้าถึงเกินอัตราที่กำหนด - พิจารณาปรับ rate limiting');
    }

    if (eventTypes.includes('unauthorized_access')) {
      recommendations.push('พบการเข้าถึงที่ไม่ได้รับอนุญาต - ตรวจสอบ access control');
    }

    if (recommendations.length === 0) {
      recommendations.push('ระบบปลอดภัยอยู่ในสภาพปกติ - ดำเนินการ monitoring ต่อไป');
    }

    return recommendations;
  }
}

// Export singleton instance
export const securityDashboard = new SecurityDashboardProvider();

export default securityDashboard;