// Database Performance Monitoring for Tinedy CRM
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import { performance } from 'perf_hooks';

const prisma = new PrismaClient();

interface QueryPerformanceMetric {
  query: string;
  duration: number;
  timestamp: Date;
  params?: any;
  resultCount?: number;
  cached?: boolean;
}

interface PerformanceReport {
  overview: {
    totalQueries: number;
    averageResponseTime: number;
    slowQueries: number;
    cacheHitRate: number;
    errorRate: number;
  };
  slowQueries: QueryPerformanceMetric[];
  frequentQueries: Array<{
    query: string;
    count: number;
    averageDuration: number;
    totalDuration: number;
  }>;
  indexAnalysis: Array<{
    table: string;
    unusedIndexes: string[];
    missingIndexes: string[];
    indexUsage: Record<string, number>;
  }>;
  recommendations: string[];
}

/**
 * Database Performance Monitor
 */
export class DatabasePerformanceMonitor {
  private queryMetrics: QueryPerformanceMetric[] = [];
  private slowQueryThreshold = 1000; // milliseconds
  private maxMetricsSize = 1000;

  constructor() {
    this.setupPrismaLogging();
  }

  /**
   * Setup Prisma query logging for performance monitoring
   */
  private setupPrismaLogging() {
    // Enable query logging in development
    if (process.env.NODE_ENV === 'development') {
      (prisma as any).$on('query', (e: any) => {
        this.recordQueryMetric({
          query: this.sanitizeQuery(e.query),
          duration: e.duration,
          timestamp: new Date(),
          params: e.params
        });
      });
    }
  }

  /**
   * Record query performance metric
   */
  recordQueryMetric(metric: QueryPerformanceMetric) {
    this.queryMetrics.push(metric);

    // Keep only recent metrics
    if (this.queryMetrics.length > this.maxMetricsSize) {
      this.queryMetrics = this.queryMetrics.slice(-this.maxMetricsSize);
    }

    // Log slow queries
    if (metric.duration > this.slowQueryThreshold) {
      console.warn(`üêå Slow Query (${metric.duration}ms):`, metric.query);
    }
  }

  /**
   * Sanitize query for logging (remove sensitive data)
   */
  private sanitizeQuery(query: string): string {
    return query
      .replace(/(password|token|secret|key)[\\s]*=[\\s]*'[^']*'/gi, '$1=[REDACTED]')
      .replace(/(\$\d+)/g, '?'); // Replace parameter placeholders
  }

  /**
   * Generate comprehensive performance report
   */
  async generatePerformanceReport(hours: number = 24): Promise<PerformanceReport> {
    const since = new Date(Date.now() - (hours * 60 * 60 * 1000));

    const recentMetrics = this.queryMetrics.filter(m => m.timestamp >= since);

    // Calculate overview metrics
    const overview = this.calculateOverview(recentMetrics);

    // Get slow queries
    const slowQueries = this.getSlowQueries(recentMetrics);

    // Analyze frequent queries
    const frequentQueries = this.analyzeFrequentQueries(recentMetrics);

    // Analyze database indexes
    const indexAnalysis = await this.analyzeIndexUsage();

    // Generate recommendations
    const recommendations = this.generateRecommendations(
      overview,
      slowQueries,
      frequentQueries,
      indexAnalysis
    );

    return {
      overview,
      slowQueries,
      frequentQueries,
      indexAnalysis,
      recommendations
    };
  }

  /**
   * Calculate performance overview
   */
  private calculateOverview(metrics: QueryPerformanceMetric[]) {
    if (metrics.length === 0) {
      return {
        totalQueries: 0,
        averageResponseTime: 0,
        slowQueries: 0,
        cacheHitRate: 0,
        errorRate: 0
      };
    }

    const totalQueries = metrics.length;
    const totalDuration = metrics.reduce((sum, m) => sum + m.duration, 0);
    const averageResponseTime = totalDuration / totalQueries;
    const slowQueries = metrics.filter(m => m.duration > this.slowQueryThreshold).length;
    const cachedQueries = metrics.filter(m => m.cached).length;
    const cacheHitRate = (cachedQueries / totalQueries) * 100;

    return {
      totalQueries,
      averageResponseTime: Math.round(averageResponseTime * 100) / 100,
      slowQueries,
      cacheHitRate: Math.round(cacheHitRate * 100) / 100,
      errorRate: 0 // TODO: Track query errors
    };
  }

  /**
   * Get slow queries for analysis
   */
  private getSlowQueries(metrics: QueryPerformanceMetric[]) {
    return metrics
      .filter(m => m.duration > this.slowQueryThreshold)
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 20); // Top 20 slowest queries
  }

  /**
   * Analyze frequent queries
   */
  private analyzeFrequentQueries(metrics: QueryPerformanceMetric[]) {
    const queryStats: Record<string, {
      count: number;
      totalDuration: number;
      durations: number[];
    }> = {};

    metrics.forEach(metric => {
      const query = metric.query;
      if (!queryStats[query]) {
        queryStats[query] = { count: 0, totalDuration: 0, durations: [] };
      }
      queryStats[query].count++;
      queryStats[query].totalDuration += metric.duration;
      queryStats[query].durations.push(metric.duration);
    });

    return Object.entries(queryStats)
      .map(([query, stats]) => ({
        query,
        count: stats.count,
        averageDuration: Math.round((stats.totalDuration / stats.count) * 100) / 100,
        totalDuration: stats.totalDuration
      }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 15); // Top 15 most frequent queries
  }

  /**
   * Analyze database index usage
   */
  async analyzeIndexUsage() {
    try {
      // Get table statistics
      const tableStats = await prisma.$queryRaw<Array<{
        schemaname: string;
        tablename: string;
        seq_scan: number;
        seq_tup_read: number;
        idx_scan: number;
        idx_tup_fetch: number;
      }>>`
        SELECT
          schemaname,
          tablename,
          seq_scan,
          seq_tup_read,
          idx_scan,
          idx_tup_fetch
        FROM pg_stat_user_tables
        WHERE schemaname = 'public'
        ORDER BY seq_scan DESC
      `;

      // Get index usage statistics
      const indexStats = await prisma.$queryRaw<Array<{
        schemaname: string;
        tablename: string;
        indexname: string;
        idx_scan: number;
        idx_tup_read: number;
        idx_tup_fetch: number;
      }>>`
        SELECT
          schemaname,
          tablename,
          indexname,
          idx_scan,
          idx_tup_read,
          idx_tup_fetch
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public'
        ORDER BY idx_scan DESC
      `;

      // Analyze each table
      const analysis = [];
      const tables = ['customers', 'jobs', 'users', 'quality_checks', 'webhook_logs', 'audit_logs'];

      for (const table of tables) {
        const tableData = tableStats.find(t => t.tablename === table);
        const tableIndexes = indexStats.filter(i => i.tablename === table);

        const unusedIndexes = tableIndexes
          .filter(i => (i.idx_scan || 0) === 0)
          .map(i => i.indexname);

        const indexUsage: Record<string, number> = {};
        tableIndexes.forEach(i => {
          indexUsage[i.indexname] = i.idx_scan || 0;
        });

        // Suggest missing indexes based on table scan ratios
        const missingIndexes = [];
        if (tableData && tableData.seq_scan > (tableData.idx_scan || 0) * 2) {
          missingIndexes.push(`Consider adding indexes for frequently scanned ${table} table`);
        }

        analysis.push({
          table,
          unusedIndexes,
          missingIndexes,
          indexUsage
        });
      }

      return analysis;

    } catch (error) {
      console.error('Error analyzing index usage:', error);
      return [];
    }
  }

  /**
   * Generate performance recommendations
   */
  private generateRecommendations(
    overview: any,
    slowQueries: QueryPerformanceMetric[],
    frequentQueries: any[],
    indexAnalysis: any[]
  ): string[] {
    const recommendations: string[] = [];

    // Average response time recommendations
    if (overview.averageResponseTime > 200) {
      recommendations.push(
        `üö® Average response time (${overview.averageResponseTime}ms) is high. Consider query optimization and caching.`
      );
    } else if (overview.averageResponseTime > 100) {
      recommendations.push(
        `‚ö†Ô∏è Average response time (${overview.averageResponseTime}ms) could be improved with better indexing.`
      );
    } else {
      recommendations.push(
        `‚úÖ Average response time (${overview.averageResponseTime}ms) is good.`
      );
    }

    // Slow queries recommendations
    if (slowQueries.length > 0) {
      recommendations.push(
        `üêå Found ${slowQueries.length} slow queries. Review and optimize the slowest ones.`
      );

      // Specific slow query recommendations
      slowQueries.slice(0, 3).forEach((query, index) => {
        recommendations.push(
          `   ${index + 1}. Query taking ${query.duration}ms - consider adding indexes or optimizing logic`
        );
      });
    }

    // Cache recommendations
    if (overview.cacheHitRate < 50) {
      recommendations.push(
        `üìà Cache hit rate (${overview.cacheHitRate}%) is low. Implement query result caching.`
      );
    }

    // Index recommendations
    indexAnalysis.forEach(table => {
      if (table.unusedIndexes.length > 0) {
        recommendations.push(
          `üóëÔ∏è Table ${table.table} has ${table.unusedIndexes.length} unused indexes that could be dropped.`
        );
      }

      if (table.missingIndexes.length > 0) {
        recommendations.push(
          `üîç Table ${table.table}: ${table.missingIndexes.join(', ')}`
        );
      }
    });

    // Frequent query recommendations
    const expensiveFrequentQueries = frequentQueries.filter(q =>
      q.count > 50 && q.averageDuration > 100
    );

    if (expensiveFrequentQueries.length > 0) {
      recommendations.push(
        `üî• Found ${expensiveFrequentQueries.length} frequently executed expensive queries. Prioritize optimizing these.`
      );
    }

    // Connection pool recommendations
    if (overview.totalQueries > 10000) {
      recommendations.push(
        `üèä‚Äç‚ôÇÔ∏è High query volume (${overview.totalQueries}). Ensure connection pooling is properly configured.`
      );
    }

    // General recommendations
    recommendations.push(
      `üìä Monitor database performance regularly and set up alerts for response time degradation.`
    );

    return recommendations;
  }

  /**
   * Run comprehensive database performance tests
   */
  async runPerformanceTests() {
    console.log('üèÉ‚Äç‚ôÇÔ∏è Running database performance tests...');

    const tests = [
      this.testCustomerQueries(),
      this.testJobQueries(),
      this.testAuditLogQueries(),
      this.testComplexJoinQueries(),
      this.testAggregationQueries()
    ];

    const results = await Promise.all(tests);

    const report = {
      timestamp: new Date(),
      tests: results,
      summary: {
        totalTests: results.length,
        passed: results.filter(r => r.passed).length,
        failed: results.filter(r => !r.passed).length,
        averageResponseTime: results.reduce((sum, r) => sum + r.duration, 0) / results.length
      }
    };

    console.log('üìä Performance test results:', report.summary);
    return report;
  }

  /**
   * Test customer query performance
   */
  private async testCustomerQueries() {
    const start = performance.now();

    try {
      // Test customer search by name
      await prisma.customer.findMany({
        where: {
          name: { contains: 'Test' }
        },
        take: 10
      });

      // Test customer with jobs
      await prisma.customer.findMany({
        include: {
          jobs: {
            take: 5,
            orderBy: { createdAt: 'desc' }
          }
        },
        take: 10
      });

      const duration = performance.now() - start;

      return {
        test: 'Customer Queries',
        duration: Math.round(duration),
        passed: duration < 500,
        message: duration < 500 ? 'Customer queries perform well' : 'Customer queries are slow'
      };

    } catch (error) {
      return {
        test: 'Customer Queries',
        duration: performance.now() - start,
        passed: false,
        message: `Customer query test failed: ${error}`
      };
    }
  }

  /**
   * Test job query performance
   */
  private async testJobQueries() {
    const start = performance.now();

    try {
      // Test job filtering by status
      await prisma.job.findMany({
        where: {
          status: 'IN_PROGRESS'
        },
        include: {
          customer: true,
          assignedTo: true
        },
        take: 20
      });

      // Test job filtering by date range
      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      await prisma.job.findMany({
        where: {
          createdAt: { gte: oneWeekAgo }
        },
        orderBy: { createdAt: 'desc' },
        take: 50
      });

      const duration = performance.now() - start;

      return {
        test: 'Job Queries',
        duration: Math.round(duration),
        passed: duration < 300,
        message: duration < 300 ? 'Job queries perform well' : 'Job queries could be optimized'
      };

    } catch (error) {
      return {
        test: 'Job Queries',
        duration: performance.now() - start,
        passed: false,
        message: `Job query test failed: ${error}`
      };
    }
  }

  /**
   * Test audit log query performance
   */
  private async testAuditLogQueries() {
    const start = performance.now();

    try {
      // Test audit log retrieval
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      await prisma.auditLog.findMany({
        where: {
          timestamp: { gte: oneHourAgo }
        },
        orderBy: { timestamp: 'desc' },
        take: 100
      });

      const duration = performance.now() - start;

      return {
        test: 'Audit Log Queries',
        duration: Math.round(duration),
        passed: duration < 400,
        message: duration < 400 ? 'Audit log queries perform well' : 'Audit log queries need optimization'
      };

    } catch (error) {
      return {
        test: 'Audit Log Queries',
        duration: performance.now() - start,
        passed: false,
        message: `Audit log query test failed: ${error}`
      };
    }
  }

  /**
   * Test complex join query performance
   */
  private async testComplexJoinQueries() {
    const start = performance.now();

    try {
      // Complex query with multiple joins
      await prisma.job.findMany({
        where: {
          status: { in: ['NEW', 'IN_PROGRESS'] }
        },
        include: {
          customer: true,
          assignedTo: true,
          qualityChecks: {
            include: {
              checklist: true
            }
          },
          training: true
        },
        take: 10
      });

      const duration = performance.now() - start;

      return {
        test: 'Complex Join Queries',
        duration: Math.round(duration),
        passed: duration < 600,
        message: duration < 600 ? 'Complex joins perform adequately' : 'Complex joins are expensive - consider optimization'
      };

    } catch (error) {
      return {
        test: 'Complex Join Queries',
        duration: performance.now() - start,
        passed: false,
        message: `Complex join test failed: ${error}`
      };
    }
  }

  /**
   * Test aggregation query performance
   */
  private async testAggregationQueries() {
    const start = performance.now();

    try {
      // Aggregation queries
      await Promise.all([
        prisma.job.count(),
        prisma.job.count({
          where: { status: 'COMPLETED' }
        }),
        prisma.customer.count({
          where: { status: 'ACTIVE' }
        })
      ]);

      const duration = performance.now() - start;

      return {
        test: 'Aggregation Queries',
        duration: Math.round(duration),
        passed: duration < 200,
        message: duration < 200 ? 'Aggregation queries are fast' : 'Aggregation queries could be faster'
      };

    } catch (error) {
      return {
        test: 'Aggregation Queries',
        duration: performance.now() - start,
        passed: false,
        message: `Aggregation test failed: ${error}`
      };
    }
  }

  /**
   * Get real-time performance metrics
   */
  getRealtimeMetrics() {
    const recentMetrics = this.queryMetrics.slice(-100); // Last 100 queries

    if (recentMetrics.length === 0) {
      return {
        queriesPerMinute: 0,
        averageResponseTime: 0,
        slowQueryCount: 0,
        status: 'idle'
      };
    }

    const now = Date.now();
    const oneMinuteAgo = now - 60 * 1000;
    const recentQueries = recentMetrics.filter(m => m.timestamp.getTime() > oneMinuteAgo);

    const queriesPerMinute = recentQueries.length;
    const averageResponseTime = recentQueries.length > 0
      ? recentQueries.reduce((sum, m) => sum + m.duration, 0) / recentQueries.length
      : 0;
    const slowQueryCount = recentQueries.filter(m => m.duration > this.slowQueryThreshold).length;

    let status = 'good';
    if (averageResponseTime > 500) status = 'critical';
    else if (averageResponseTime > 200) status = 'warning';

    return {
      queriesPerMinute,
      averageResponseTime: Math.round(averageResponseTime * 100) / 100,
      slowQueryCount,
      status
    };
  }

  /**
   * Clear metrics history
   */
  clearMetrics() {
    this.queryMetrics = [];
    console.log('üìä Performance metrics cleared');
  }
}

// Export singleton instance
export const performanceMonitor = new DatabasePerformanceMonitor();

export default performanceMonitor;