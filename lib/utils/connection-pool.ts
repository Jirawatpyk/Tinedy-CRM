// Database Connection Pool & Caching Configuration for Tinedy CRM
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';

// Global connection pool configuration
declare global {
  var __prisma: PrismaClient | undefined;
}

/**
 * Optimized Prisma Client Configuration for Production
 */
const createPrismaClient = () => {
  return new PrismaClient({
    // Connection pool configuration
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },

    // Logging configuration for performance monitoring
    log: process.env.NODE_ENV === 'development' ? [
      {
        emit: 'event',
        level: 'query',
      },
      {
        emit: 'stdout',
        level: 'error',
      },
      {
        emit: 'stdout',
        level: 'warn',
      },
    ] : [
      {
        emit: 'stdout',
        level: 'error',
      },
    ],

    // Error formatting
    errorFormat: process.env.NODE_ENV === 'development' ? 'pretty' : 'minimal',
  });
};

/**
 * Singleton Prisma Client with Connection Pooling
 */
export const prisma = globalThis.__prisma ?? createPrismaClient();

// Ensure single instance in development (hot reload protection)
if (process.env.NODE_ENV !== 'production') {
  globalThis.__prisma = prisma;
}

/**
 * Database Connection Pool Manager
 */
export class ConnectionPoolManager {
  private static instance: ConnectionPoolManager;
  private connectionCount = 0;
  private maxConnections = parseInt(process.env.DB_MAX_CONNECTIONS || '10');
  private connectionTimeout = parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000'); // 10 seconds

  private constructor() {
    this.setupConnectionMonitoring();
  }

  static getInstance(): ConnectionPoolManager {
    if (!ConnectionPoolManager.instance) {
      ConnectionPoolManager.instance = new ConnectionPoolManager();
    }
    return ConnectionPoolManager.instance;
  }

  /**
   * Setup connection monitoring
   */
  private setupConnectionMonitoring() {
    // Monitor Prisma query events
    if (process.env.NODE_ENV === 'development') {
      prisma.$on('query', (e) => {
        // Log slow queries
        if (e.duration > 1000) {
          console.warn(`üêå Slow Query (${e.duration}ms):`, e.query.substring(0, 100));
        }
      });
    }

    // Connection health check interval
    setInterval(async () => {
      await this.healthCheck();
    }, 30000); // Every 30 seconds
  }

  /**
   * Get connection pool status
   */
  async getPoolStatus() {
    try {
      // Simple query to test connection
      const start = Date.now();
      await prisma.$queryRaw`SELECT 1 as health_check`;
      const responseTime = Date.now() - start;

      return {
        healthy: true,
        responseTime,
        maxConnections: this.maxConnections,
        activeConnections: this.connectionCount,
        utilizationRate: (this.connectionCount / this.maxConnections) * 100
      };

    } catch (error) {
      console.error('Database connection pool error:', error);
      return {
        healthy: false,
        error: (error as Error).message,
        maxConnections: this.maxConnections,
        activeConnections: this.connectionCount
      };
    }
  }

  /**
   * Health check for connection pool
   */
  private async healthCheck() {
    const status = await this.getPoolStatus();

    if (!status.healthy) {
      console.error('üö® Database connection pool unhealthy:', status.error);
    } else if (status.utilizationRate && status.utilizationRate > 80) {
      console.warn('‚ö†Ô∏è High database connection pool utilization:', status.utilizationRate + '%');
    }
  }

  /**
   * Execute query with connection tracking
   */
  async executeWithTracking<T>(operation: () => Promise<T>): Promise<T> {
    this.connectionCount++;

    try {
      const result = await operation();
      return result;
    } finally {
      this.connectionCount--;
    }
  }

  /**
   * Graceful shutdown
   */
  async shutdown() {
    console.log('üîå Shutting down database connections...');
    await prisma.$disconnect();
    console.log('‚úÖ Database connections closed');
  }
}

/**
 * Redis Cache Manager for Query Results
 */
export class CacheManager {
  private cache = new Map<string, { data: any; expiry: number }>();
  private defaultTTL = 5 * 60 * 1000; // 5 minutes
  private maxCacheSize = 1000; // Maximum cache entries

  /**
   * Get cached data
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) return null;

    // Check if expired
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  /**
   * Set cached data
   */
  set(key: string, data: any, ttl?: number): void {
    // Implement LRU cache behavior
    if (this.cache.size >= this.maxCacheSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    const expiry = Date.now() + (ttl || this.defaultTTL);
    this.cache.set(key, { data, expiry });
  }

  /**
   * Delete cached entry
   */
  delete(key: string): void {
    this.cache.delete(key);
  }

  /**
   * Clear all cache
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * Get cache statistics
   */
  getStats() {
    const now = Date.now();
    const validEntries = Array.from(this.cache.values()).filter(entry => now <= entry.expiry);

    return {
      totalEntries: this.cache.size,
      validEntries: validEntries.length,
      expiredEntries: this.cache.size - validEntries.length,
      hitRate: this.calculateHitRate(),
      memoryUsage: this.estimateMemoryUsage()
    };
  }

  /**
   * Calculate hit rate (simple implementation)
   */
  private calculateHitRate(): number {
    // This would need proper hit/miss tracking in a real implementation
    return 0; // Placeholder
  }

  /**
   * Estimate memory usage
   */
  private estimateMemoryUsage(): string {
    const bytes = JSON.stringify(Array.from(this.cache.entries())).length;
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
    return Math.round(bytes / (1024 * 1024)) + ' MB';
  }

  /**
   * Clean expired entries
   */
  cleanExpired(): number {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiry) {
        this.cache.delete(key);
        cleanedCount++;
      }
    }

    return cleanedCount;
  }
}

// Global instances
export const connectionPool = ConnectionPoolManager.getInstance();
export const cache = new CacheManager();

// Auto-cleanup expired cache entries every 5 minutes
setInterval(() => {
  const cleaned = cache.cleanExpired();
  if (cleaned > 0) {
    console.log(`üßπ Cleaned ${cleaned} expired cache entries`);
  }
}, 5 * 60 * 1000);

/**
 * Cached database query wrapper
 */
export async function cachedQuery<T>(
  key: string,
  queryFn: () => Promise<T>,
  ttl?: number
): Promise<T> {
  // Try to get from cache first
  const cached = cache.get<T>(key);
  if (cached !== null) {
    console.log(`üì¶ Cache HIT: ${key}`);
    return cached;
  }

  // Execute query and cache result
  console.log(`üîç Cache MISS: ${key}`);
  const result = await connectionPool.executeWithTracking(queryFn);
  cache.set(key, result, ttl);

  return result;
}

/**
 * Database health monitoring
 */
export async function getDatabaseHealth() {
  const poolStatus = await connectionPool.getPoolStatus();
  const cacheStats = cache.getStats();

  return {
    database: poolStatus,
    cache: cacheStats,
    timestamp: new Date(),
    environment: process.env.NODE_ENV
  };
}

/**
 * Optimized query helpers for common operations
 */
export const OptimizedQueries = {
  /**
   * Get active customers with caching
   */
  async getActiveCustomers(limit = 50) {
    return cachedQuery(
      `active_customers_${limit}`,
      () => prisma.customer.findMany({
        where: { status: 'ACTIVE' },
        orderBy: { createdAt: 'desc' },
        take: limit,
        select: {
          id: true,
          name: true,
          phone: true,
          email: true,
          status: true,
          createdAt: true
        }
      }),
      2 * 60 * 1000 // 2 minutes cache
    );
  },

  /**
   * Get job dashboard data with caching
   */
  async getJobDashboard(userId?: string) {
    const cacheKey = `job_dashboard_${userId || 'all'}`;

    return cachedQuery(
      cacheKey,
      () => prisma.job.findMany({
        where: {
          status: { in: ['NEW', 'IN_PROGRESS'] },
          ...(userId && { assignedToId: userId })
        },
        include: {
          customer: {
            select: { id: true, name: true, phone: true }
          },
          assignedTo: {
            select: { id: true, name: true }
          }
        },
        orderBy: [
          { priority: 'desc' },
          { createdAt: 'asc' }
        ],
        take: 100
      }),
      1 * 60 * 1000 // 1 minute cache
    );
  },

  /**
   * Get user statistics with caching
   */
  async getUserStats(userId: string) {
    return cachedQuery(
      `user_stats_${userId}`,
      async () => {
        const [totalJobs, completedJobs, activeJobs] = await Promise.all([
          prisma.job.count({ where: { assignedToId: userId } }),
          prisma.job.count({
            where: {
              assignedToId: userId,
              status: 'COMPLETED'
            }
          }),
          prisma.job.count({
            where: {
              assignedToId: userId,
              status: { in: ['NEW', 'IN_PROGRESS'] }
            }
          })
        ]);

        return {
          totalJobs,
          completedJobs,
          activeJobs,
          completionRate: totalJobs > 0 ? (completedJobs / totalJobs) * 100 : 0
        };
      },
      5 * 60 * 1000 // 5 minutes cache
    );
  },

  /**
   * Invalidate related caches when data changes
   */
  invalidateCache(patterns: string[]) {
    const keys = Array.from(cache['cache'].keys());
    let invalidatedCount = 0;

    patterns.forEach(pattern => {
      keys.forEach(key => {
        if (key.includes(pattern)) {
          cache.delete(key);
          invalidatedCount++;
        }
      });
    });

    console.log(`üóëÔ∏è Invalidated ${invalidatedCount} cache entries for patterns:`, patterns);
  }
};

/**
 * Graceful shutdown handler
 */
process.on('SIGTERM', async () => {
  console.log('üõë Received SIGTERM, shutting down gracefully...');
  await connectionPool.shutdown();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('üõë Received SIGINT, shutting down gracefully...');
  await connectionPool.shutdown();
  process.exit(0);
});

export default {
  prisma,
  connectionPool,
  cache,
  cachedQuery,
  getDatabaseHealth,
  OptimizedQueries
};