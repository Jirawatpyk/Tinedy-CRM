// Data Protection & Privacy Utilities for Tinedy CRM
// Generated by Database Agent (Alex)

import crypto from 'crypto';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Encryption configuration
const ENCRYPTION_CONFIG = {
  algorithm: 'aes-256-gcm',
  keyLength: 32,
  ivLength: 16,
  tagLength: 16,
  encoding: 'base64' as BufferEncoding
};

/**
 * Data Protection Manager
 */
export class DataProtectionManager {
  private encryptionKey: string;

  constructor() {
    this.encryptionKey = process.env.DATA_ENCRYPTION_KEY || this.generateKey();

    if (!process.env.DATA_ENCRYPTION_KEY) {
      console.warn('‚ö†Ô∏è DATA_ENCRYPTION_KEY not set, using generated key');
    }
  }

  /**
   * Encrypt sensitive data
   */
  encrypt(data: string): string {
    try {
      const iv = crypto.randomBytes(ENCRYPTION_CONFIG.ivLength);
      const cipher = crypto.createCipher(ENCRYPTION_CONFIG.algorithm, this.encryptionKey);

      cipher.setAAD(Buffer.from('tinedy-crm-data'));

      let encrypted = cipher.update(data, 'utf8', ENCRYPTION_CONFIG.encoding);
      encrypted += cipher.final(ENCRYPTION_CONFIG.encoding);

      const tag = cipher.getAuthTag();

      // Combine IV + encrypted data + auth tag
      const combined = Buffer.concat([
        iv,
        Buffer.from(encrypted, ENCRYPTION_CONFIG.encoding),
        tag
      ]);

      return combined.toString(ENCRYPTION_CONFIG.encoding);

    } catch (error) {
      console.error('Encryption error:', error);
      throw new Error('Failed to encrypt data');
    }
  }

  /**
   * Decrypt sensitive data
   */
  decrypt(encryptedData: string): string {
    try {
      const combined = Buffer.from(encryptedData, ENCRYPTION_CONFIG.encoding);

      // Extract components
      const iv = combined.subarray(0, ENCRYPTION_CONFIG.ivLength);
      const tag = combined.subarray(-ENCRYPTION_CONFIG.tagLength);
      const encrypted = combined.subarray(
        ENCRYPTION_CONFIG.ivLength,
        -ENCRYPTION_CONFIG.tagLength
      );

      const decipher = crypto.createDecipher(ENCRYPTION_CONFIG.algorithm, this.encryptionKey);
      decipher.setAAD(Buffer.from('tinedy-crm-data'));
      decipher.setAuthTag(tag);

      let decrypted = decipher.update(encrypted, undefined, 'utf8');
      decrypted += decipher.final('utf8');

      return decrypted;

    } catch (error) {
      console.error('Decryption error:', error);
      throw new Error('Failed to decrypt data');
    }
  }

  /**
   * Generate encryption key
   */
  private generateKey(): string {
    return crypto.randomBytes(ENCRYPTION_CONFIG.keyLength).toString('hex');
  }

  /**
   * Hash sensitive data (one-way)
   */
  hash(data: string, salt?: string): string {
    const actualSalt = salt || crypto.randomBytes(16).toString('hex');
    const hash = crypto.pbkdf2Sync(data, actualSalt, 10000, 64, 'sha512');
    return `${actualSalt}:${hash.toString('hex')}`;
  }

  /**
   * Verify hashed data
   */
  verifyHash(data: string, hashedData: string): boolean {
    const [salt, hash] = hashedData.split(':');
    const verifyHash = crypto.pbkdf2Sync(data, salt, 10000, 64, 'sha512');
    return hash === verifyHash.toString('hex');
  }
}

/**
 * Data Masking Utilities
 */
export class DataMasker {
  /**
   * Mask phone number
   */
  static maskPhone(phone: string): string {
    if (!phone) return '';

    // Thai phone number format: +66-X-XXX-XXXX
    const cleaned = phone.replace(/\D/g, '');

    if (cleaned.length >= 10) {
      const country = cleaned.startsWith('66') ? '+66' : '';
      const local = cleaned.slice(-9);
      return `${country}-${local.slice(0, 1)}-***-${local.slice(-4)}`;
    }

    return phone.replace(/\d(?=\d{4})/g, '*');
  }

  /**
   * Mask email address
   */
  static maskEmail(email: string): string {
    if (!email || !email.includes('@')) return email;

    const [local, domain] = email.split('@');
    const maskedLocal = local.length > 2
      ? `${local[0]}***${local.slice(-1)}`
      : '***';

    return `${maskedLocal}@${domain}`;
  }

  /**
   * Mask LINE User ID
   */
  static maskLineUserId(lineUserId: string): string {
    if (!lineUserId) return '';
    return `U${'*'.repeat(lineUserId.length - 5)}${lineUserId.slice(-4)}`;
  }

  /**
   * Mask name
   */
  static maskName(name: string): string {
    if (!name) return '';

    const words = name.split(' ');
    return words.map(word => {
      if (word.length <= 2) return word;
      return `${word[0]}${'*'.repeat(word.length - 2)}${word.slice(-1)}`;
    }).join(' ');
  }

  /**
   * Mask address
   */
  static maskAddress(address: string): string {
    if (!address) return '';

    // Keep first and last parts, mask middle
    const parts = address.split(' ');
    if (parts.length <= 3) return address;

    const first = parts.slice(0, 2).join(' ');
    const last = parts.slice(-2).join(' ');
    const middle = '*'.repeat(10);

    return `${first} ${middle} ${last}`;
  }
}

/**
 * Privacy Compliance Manager
 */
export class PrivacyComplianceManager {
  /**
   * Data retention manager
   */
  async enforceDataRetention() {
    const retentionPeriods = {
      audit_logs: 365, // 1 year
      webhook_logs: 90, // 3 months
      failed_webhooks: 30, // 1 month
    };

    for (const [table, days] of Object.entries(retentionPeriods)) {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      let deletedCount = 0;

      switch (table) {
        case 'audit_logs':
          const auditResult = await prisma.auditLog.deleteMany({
            where: { timestamp: { lt: cutoffDate } }
          });
          deletedCount = auditResult.count;
          break;

        case 'webhook_logs':
          const webhookResult = await prisma.webhookLog.deleteMany({
            where: {
              createdAt: { lt: cutoffDate },
              status: 'PROCESSED' // Only delete processed logs
            }
          });
          deletedCount = webhookResult.count;
          break;

        case 'failed_webhooks':
          const failedResult = await prisma.failedWebhook.deleteMany({
            where: { failedAt: { lt: cutoffDate } }
          });
          deletedCount = failedResult.count;
          break;
      }

      if (deletedCount > 0) {
        console.log(`üóëÔ∏è Data retention: Deleted ${deletedCount} records from ${table}`);

        // Log retention action
        await prisma.auditLog.create({
          data: {
            entityType: 'DataRetention',
            entityId: table,
            action: 'DELETE',
            newValues: {
              deletedCount,
              cutoffDate: cutoffDate.toISOString(),
              reason: 'Automated data retention policy'
            }
          }
        });
      }
    }
  }

  /**
   * Right to be forgotten (GDPR Article 17)
   */
  async deleteCustomerData(customerId: string, reason: string = 'user_request') {
    const deletionLog = {
      customerId,
      reason,
      timestamp: new Date().toISOString(),
      deletedEntities: [] as string[]
    };

    try {
      // 1. Delete related data (cascade)
      const training = await prisma.trainingWorkflow.deleteMany({
        where: {
          job: { customerId }
        }
      });
      if (training.count > 0) deletionLog.deletedEntities.push(`training_workflows: ${training.count}`);

      const qualityChecks = await prisma.qualityCheck.deleteMany({
        where: {
          job: { customerId }
        }
      });
      if (qualityChecks.count > 0) deletionLog.deletedEntities.push(`quality_checks: ${qualityChecks.count}`);

      const jobs = await prisma.job.deleteMany({
        where: { customerId }
      });
      if (jobs.count > 0) deletionLog.deletedEntities.push(`jobs: ${jobs.count}`);

      // 2. Anonymize webhook logs (don't delete for system integrity)
      const webhooks = await prisma.webhookLog.updateMany({
        where: {
          payload: {
            path: ['customer', 'lineUserId'],
            not: null
          }
        },
        data: {
          payload: {
            ...{}, // Remove customer data but keep system data
            customer: {
              lineUserId: '[DELETED]',
              displayName: '[DELETED]',
              phone: '[DELETED]',
              email: '[DELETED]'
            }
          }
        }
      });

      // 3. Delete customer record
      const customer = await prisma.customer.delete({
        where: { id: customerId }
      });
      deletionLog.deletedEntities.push('customer: 1');

      // 4. Create deletion audit log
      await prisma.auditLog.create({
        data: {
          entityType: 'DataDeletion',
          entityId: customerId,
          action: 'DELETE',
          newValues: deletionLog
        }
      });

      console.log(`üóëÔ∏è Customer data deleted: ${customerId}`, deletionLog);

      return {
        success: true,
        deletedEntities: deletionLog.deletedEntities,
        message: 'Customer data successfully deleted'
      };

    } catch (error) {
      console.error('Data deletion error:', error);

      // Log failed deletion attempt
      await prisma.auditLog.create({
        data: {
          entityType: 'DataDeletion',
          entityId: customerId,
          action: 'DELETE_FAILED',
          newValues: {
            ...deletionLog,
            error: (error as Error).message
          }
        }
      });

      throw new Error(`Failed to delete customer data: ${(error as Error).message}`);
    }
  }

  /**
   * Data export for GDPR compliance
   */
  async exportCustomerData(customerId: string) {
    try {
      // Get customer data
      const customer = await prisma.customer.findUnique({
        where: { id: customerId },
        include: {
          jobs: {
            include: {
              qualityChecks: {
                include: {
                  checklist: true
                }
              },
              training: true
            }
          }
        }
      });

      if (!customer) {
        throw new Error('Customer not found');
      }

      // Get audit logs related to customer
      const auditLogs = await prisma.auditLog.findMany({
        where: {
          OR: [
            { entityId: customerId },
            { entityType: 'Job', entityId: { in: customer.jobs.map(j => j.id) } }
          ]
        },
        orderBy: { timestamp: 'desc' }
      });

      // Mask sensitive internal data
      const exportData = {
        customer: {
          id: customer.id,
          name: customer.name,
          phone: customer.phone,
          email: customer.email,
          address: customer.address,
          status: customer.status,
          createdAt: customer.createdAt,
          updatedAt: customer.updatedAt,
          // Exclude internal fields
          notes: '[INTERNAL_USE_ONLY]'
        },
        jobs: customer.jobs.map(job => ({
          id: job.id,
          serviceType: job.serviceType,
          description: job.description,
          status: job.status,
          priority: job.priority,
          scheduledAt: job.scheduledAt,
          completedAt: job.completedAt,
          createdAt: job.createdAt,
          qualityChecks: job.qualityChecks.map(qc => ({
            status: qc.status,
            completedAt: qc.completedAt,
            notes: qc.notes,
            checklist: qc.checklist.name
          })),
          training: job.training ? {
            status: job.training.status,
            documentsReceived: job.training.documentsReceived,
            trainingCompleted: job.training.trainingCompleted
          } : null
        })),
        auditTrail: auditLogs.map(log => ({
          timestamp: log.timestamp,
          action: log.action,
          entityType: log.entityType
          // Exclude detailed values for privacy
        })),
        exportMetadata: {
          exportedAt: new Date().toISOString(),
          exportedBy: 'automated_system',
          dataAsOf: new Date().toISOString()
        }
      };

      // Log export action
      await prisma.auditLog.create({
        data: {
          entityType: 'DataExport',
          entityId: customerId,
          action: 'EXPORT',
          newValues: {
            reason: 'GDPR_compliance',
            recordCount: customer.jobs.length + 1
          }
        }
      });

      return exportData;

    } catch (error) {
      console.error('Data export error:', error);
      throw new Error(`Failed to export customer data: ${(error as Error).message}`);
    }
  }

  /**
   * Check data processing consent
   */
  async hasProcessingConsent(customerId: string): Promise<boolean> {
    // For now, assume consent through LINE OA opt-in
    // In production, implement proper consent management
    const customer = await prisma.customer.findUnique({
      where: { id: customerId },
      select: { status: true, createdAt: true }
    });

    return customer?.status === 'ACTIVE';
  }

  /**
   * Anonymize data for analytics
   */
  static anonymizeForAnalytics(data: any): any {
    const anonymized = { ...data };

    // Remove or hash identifying fields
    if (anonymized.id) anonymized.id = crypto.createHash('sha256').update(anonymized.id).digest('hex').slice(0, 8);
    if (anonymized.email) anonymized.email = DataMasker.maskEmail(anonymized.email);
    if (anonymized.phone) anonymized.phone = DataMasker.maskPhone(anonymized.phone);
    if (anonymized.name) anonymized.name = DataMasker.maskName(anonymized.name);
    if (anonymized.address) anonymized.address = DataMasker.maskAddress(anonymized.address);
    if (anonymized.lineUserId) anonymized.lineUserId = DataMasker.maskLineUserId(anonymized.lineUserId);

    // Remove notes that might contain sensitive info
    if (anonymized.notes) anonymized.notes = '[ANONYMIZED]';

    return anonymized;
  }
}

/**
 * Secure data handling decorator
 */
export function secureDataHandler(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
  const method = descriptor.value!;

  descriptor.value = async function (...args: any[]) {
    try {
      const result = await method.apply(this, args);

      // Auto-mask sensitive data in response
      if (result && typeof result === 'object') {
        return maskSensitiveData(result);
      }

      return result;

    } catch (error) {
      // Don't expose internal errors
      console.error('Secure handler error:', error);
      throw new Error('Data processing error');
    }
  };
}

/**
 * Automatically mask sensitive data in objects
 */
function maskSensitiveData(obj: any): any {
  if (!obj || typeof obj !== 'object') return obj;

  if (Array.isArray(obj)) {
    return obj.map(item => maskSensitiveData(item));
  }

  const masked = { ...obj };

  // Apply masking to known sensitive fields
  if (masked.phone) masked.phone = DataMasker.maskPhone(masked.phone);
  if (masked.email) masked.email = DataMasker.maskEmail(masked.email);
  if (masked.lineUserId) masked.lineUserId = DataMasker.maskLineUserId(masked.lineUserId);

  // Recursively mask nested objects
  for (const key in masked) {
    if (masked[key] && typeof masked[key] === 'object') {
      masked[key] = maskSensitiveData(masked[key]);
    }
  }

  return masked;
}

// Export instances
export const dataProtection = new DataProtectionManager();
export const privacyCompliance = new PrivacyComplianceManager();

export default {
  DataProtectionManager,
  DataMasker,
  PrivacyComplianceManager,
  dataProtection,
  privacyCompliance,
  secureDataHandler
};