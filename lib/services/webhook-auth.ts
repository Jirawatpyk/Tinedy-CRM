// Webhook Authentication & Validation Service
// Generated by Database Agent (Alex)

import crypto from 'crypto';
import { WebhookAuthHeaders } from '../types/webhook-types';

export class WebhookAuthService {
  private readonly webhookSecret: string;
  private readonly timestampTolerance = 5 * 60 * 1000; // 5 minutes

  constructor() {
    this.webhookSecret = process.env.N8N_WEBHOOK_SECRET || '';
    if (!this.webhookSecret) {
      console.warn('N8N_WEBHOOK_SECRET not configured - webhook security disabled');
    }
  }

  /**
   * ตรวจสอบ webhook authentication
   */
  async validateWebhookAuth(
    body: string,
    headers: WebhookAuthHeaders
  ): Promise<{ isValid: boolean; error?: string }> {
    try {
      // ตรวจสอบ timestamp เพื่อป้องกัน replay attacks
      const timestampCheck = this.validateTimestamp(headers['x-timestamp']);
      if (!timestampCheck.isValid) {
        return { isValid: false, error: timestampCheck.error };
      }

      // ตรวจสอบ signature
      const signatureCheck = this.validateSignature(body, headers);
      if (!signatureCheck.isValid) {
        return { isValid: false, error: signatureCheck.error };
      }

      return { isValid: true };

    } catch (error) {
      console.error('Webhook auth validation error:', error);
      return { isValid: false, error: 'Authentication validation failed' };
    }
  }

  /**
   * ตรวจสอบ timestamp เพื่อป้องกัน replay attacks
   */
  private validateTimestamp(timestamp?: string): { isValid: boolean; error?: string } {
    if (!timestamp) {
      return { isValid: false, error: 'Missing timestamp header' };
    }

    const requestTime = parseInt(timestamp);
    if (isNaN(requestTime)) {
      return { isValid: false, error: 'Invalid timestamp format' };
    }

    const currentTime = Date.now();
    const timeDiff = Math.abs(currentTime - requestTime);

    if (timeDiff > this.timestampTolerance) {
      return { isValid: false, error: 'Request timestamp too old' };
    }

    return { isValid: true };
  }

  /**
   * ตรวจสอบ webhook signature
   */
  private validateSignature(
    body: string,
    headers: WebhookAuthHeaders
  ): { isValid: boolean; error?: string } {
    const signature = headers['x-n8n-signature'];
    const timestamp = headers['x-timestamp'];

    if (!signature) {
      return { isValid: false, error: 'Missing signature header' };
    }

    if (!this.webhookSecret) {
      // ถ้าไม่มี secret ให้ผ่านไปได้ (สำหรับ development)
      console.warn('Webhook secret not configured - skipping signature validation');
      return { isValid: true };
    }

    try {
      // สร้าง expected signature
      const expectedSignature = this.generateSignature(body, timestamp!);

      // เปรียบเทียบ signature แบบ constant-time เพื่อป้องกัน timing attacks
      const isValid = crypto.timingSafeEqual(
        Buffer.from(signature, 'utf8'),
        Buffer.from(expectedSignature, 'utf8')
      );

      if (!isValid) {
        return { isValid: false, error: 'Invalid signature' };
      }

      return { isValid: true };

    } catch (error) {
      console.error('Signature validation error:', error);
      return { isValid: false, error: 'Signature validation failed' };
    }
  }

  /**
   * สร้าง webhook signature
   */
  private generateSignature(body: string, timestamp: string): string {
    const payload = `${timestamp}.${body}`;
    return crypto
      .createHmac('sha256', this.webhookSecret)
      .update(payload, 'utf8')
      .digest('hex');
  }

  /**
   * ตรวจสอบ rate limiting
   */
  async checkRateLimit(
    identifier: string,
    maxRequests: number = 100,
    windowMs: number = 60 * 1000 // 1 minute
  ): Promise<{ allowed: boolean; remaining: number; resetTime: number }> {
    // Implementation ขึ้นอยู่กับ rate limiting solution ที่เลือก
    // อาจใช้ Redis, Memory store, หรือ Database

    // ตัวอย่าง implementation แบบง่าย (ใช้ memory)
    const key = `rate_limit:${identifier}`;
    const now = Date.now();

    // ในการใช้งานจริงควรใช้ Redis หรือระบบ distributed cache
    // สำหรับตอนนี้ให้ผ่านทุก request
    return {
      allowed: true,
      remaining: maxRequests - 1,
      resetTime: now + windowMs
    };
  }

  /**
   * Log webhook security events
   */
  async logSecurityEvent(
    event: 'auth_success' | 'auth_failure' | 'rate_limit' | 'suspicious_activity',
    details: {
      ip?: string;
      userAgent?: string;
      error?: string;
      payload?: any;
    }
  ) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      event,
      ip: details.ip,
      userAgent: details.userAgent,
      error: details.error
    };

    // ใน production ควร log ไปยัง security monitoring system
    console.log('Webhook Security Event:', logEntry);

    // อาจบันทึกลง database สำหรับ audit trail
    // await this.saveSecurityLog(logEntry);
  }
}

// Rate limiting configuration
export const RATE_LIMITS = {
  webhook: {
    maxRequests: 1000,
    windowMs: 60 * 1000, // 1 minute
  },
  perIP: {
    maxRequests: 100,
    windowMs: 60 * 1000, // 1 minute
  }
};

// Export singleton instance
export const webhookAuthService = new WebhookAuthService();