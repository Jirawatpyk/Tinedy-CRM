// Webhook Processing Service for Tinedy CRM
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import {
  N8NWebhookPayload,
  WebhookProcessingResult,
  WebhookValidationResult,
  CustomerDataInput,
  JobCreateInput,
  WebhookProcessingStatus,
  WebhookErrorCode
} from '../types/webhook-types';

export class WebhookProcessor {
  private prisma: PrismaClient;
  private retryConfig = {
    maxRetries: 3,
    retryDelays: [1000, 5000, 15000], // 1s, 5s, 15s
    retryableErrors: [
      WebhookErrorCode.DATABASE_ERROR,
      WebhookErrorCode.CUSTOMER_CREATION_FAILED,
      WebhookErrorCode.JOB_CREATION_FAILED
    ]
  };

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  /**
   * ประมวลผล N8N webhook payload หลัก
   */
  async processWebhook(payload: N8NWebhookPayload): Promise<WebhookProcessingResult> {
    const webhookLogId = await this.createWebhookLog(payload);

    try {
      // 1. Validate payload
      const validation = this.validatePayload(payload);
      if (!validation.isValid) {
        await this.updateWebhookLog(webhookLogId, 'FAILED', validation.errors.join(', '));
        return {
          success: false,
          error: {
            code: WebhookErrorCode.INVALID_PAYLOAD,
            message: 'Invalid webhook payload',
            details: validation.errors
          }
        };
      }

      // 2. ตรวจสอบ duplicate request
      const duplicate = await this.checkDuplicateRequest(payload);
      if (duplicate) {
        await this.updateWebhookLog(webhookLogId, 'PROCESSED', 'Duplicate request detected');
        return {
          success: true,
          data: {
            customerId: duplicate.customerId,
            jobId: duplicate.id,
            status: 'duplicate'
          }
        };
      }

      // 3. Handle customer data
      const customer = await this.handleCustomer(payload.customer);

      // 4. Create job
      const job = await this.createJob(payload, customer.id);

      // 5. Update webhook log
      await this.updateWebhookLog(webhookLogId, 'PROCESSED', undefined, job.id);

      return {
        success: true,
        data: {
          customerId: customer.id,
          jobId: job.id,
          status: job.customerId === customer.id ? 'created' : 'updated'
        },
        warnings: validation.warnings
      };

    } catch (error) {
      console.error('Webhook processing error:', error);
      await this.updateWebhookLog(webhookLogId, 'FAILED', (error as Error).message);

      return {
        success: false,
        error: {
          code: WebhookErrorCode.DATABASE_ERROR,
          message: 'Internal processing error',
          details: error
        }
      };
    }
  }

  /**
   * Validate webhook payload
   */
  private validatePayload(payload: N8NWebhookPayload): WebhookValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Required fields validation
    if (!payload.workflow?.id) errors.push('Missing workflow.id');
    if (!payload.customer?.lineUserId) errors.push('Missing customer.lineUserId');
    if (!payload.customer?.displayName) errors.push('Missing customer.displayName');
    if (!payload.booking?.serviceType) errors.push('Missing booking.serviceType');
    if (!payload.booking?.description) errors.push('Missing booking.description');

    // Data format validation
    if (payload.booking?.preferredDate) {
      const date = new Date(payload.booking.preferredDate);
      if (isNaN(date.getTime())) {
        errors.push('Invalid booking.preferredDate format');
      }
    }

    // Priority validation
    const validPriorities = ['LOW', 'MEDIUM', 'HIGH', 'URGENT'];
    if (payload.booking?.priority && !validPriorities.includes(payload.booking.priority)) {
      errors.push('Invalid booking.priority value');
    }

    // Optional field warnings
    if (!payload.customer.phone && !payload.customer.email) {
      warnings.push('No contact information (phone/email) provided');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * ตรวจสอบ duplicate request
   */
  private async checkDuplicateRequest(payload: N8NWebhookPayload) {
    // ตรวจสอบจาก executionId และ messageId
    const existingLog = await this.prisma.webhookLog.findFirst({
      where: {
        OR: [
          { executionId: payload.workflow.executionId },
          {
            AND: [
              { payload: { path: ['conversation', 'messageId'], equals: payload.conversation.messageId } },
              { createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } } // ใน 24 ชั่วโมงที่ผ่านมา
            ]
          }
        ]
      },
      include: { createdJob: true }
    });

    return existingLog?.createdJob || null;
  }

  /**
   * จัดการข้อมูลลูกค้า (สร้างใหม่หรืออัพเดต)
   */
  private async handleCustomer(customerData: N8NWebhookPayload['customer']) {
    // ตรวจสอบลูกค้าที่มีอยู่แล้ว
    let customer = await this.prisma.customer.findUnique({
      where: { lineUserId: customerData.lineUserId }
    });

    if (!customer) {
      // สร้างลูกค้าใหม่
      customer = await this.prisma.customer.create({
        data: {
          lineUserId: customerData.lineUserId,
          name: customerData.displayName,
          phone: customerData.phone,
          email: customerData.email,
          status: 'ACTIVE'
        }
      });
    } else {
      // อัพเดตข้อมูลลูกค้าที่มีอยู่ (ถ้ามีข้อมูลใหม่)
      const updateData: any = {};

      if (customerData.displayName && customerData.displayName !== customer.name) {
        updateData.name = customerData.displayName;
      }
      if (customerData.phone && customerData.phone !== customer.phone) {
        updateData.phone = customerData.phone;
      }
      if (customerData.email && customerData.email !== customer.email) {
        updateData.email = customerData.email;
      }

      if (Object.keys(updateData).length > 0) {
        customer = await this.prisma.customer.update({
          where: { id: customer.id },
          data: { ...updateData, updatedAt: new Date() }
        });
      }
    }

    return customer;
  }

  /**
   * สร้างงานใหม่จาก webhook data
   */
  private async createJob(payload: N8NWebhookPayload, customerId: string) {
    const scheduledAt = payload.booking.preferredDate
      ? new Date(payload.booking.preferredDate)
      : null;

    return await this.prisma.job.create({
      data: {
        customerId,
        serviceType: payload.booking.serviceType,
        description: payload.booking.description,
        priority: payload.booking.priority || 'MEDIUM',
        scheduledAt,
        n8nWorkflowId: payload.workflow.id,
        webhookData: payload,
        status: 'NEW'
      }
    });
  }

  /**
   * สร้าง webhook log record
   */
  private async createWebhookLog(payload: N8NWebhookPayload): Promise<string> {
    const log = await this.prisma.webhookLog.create({
      data: {
        source: 'N8N',
        workflowId: payload.workflow.id,
        executionId: payload.workflow.executionId,
        payload: payload,
        status: 'RECEIVED'
      }
    });

    return log.id;
  }

  /**
   * อัพเดต webhook log status
   */
  private async updateWebhookLog(
    logId: string,
    status: string,
    errorMessage?: string,
    createdJobId?: string
  ) {
    await this.prisma.webhookLog.update({
      where: { id: logId },
      data: {
        status: status as any,
        errorMessage,
        createdJobId,
        processedAt: status === 'PROCESSED' ? new Date() : undefined,
        updatedAt: new Date()
      }
    });
  }

  /**
   * Retry failed webhook processing
   */
  async retryFailedWebhook(webhookLogId: string): Promise<WebhookProcessingResult> {
    const webhookLog = await this.prisma.webhookLog.findUnique({
      where: { id: webhookLogId }
    });

    if (!webhookLog || webhookLog.status !== 'FAILED') {
      return {
        success: false,
        error: {
          code: WebhookErrorCode.INVALID_PAYLOAD,
          message: 'Webhook log not found or not in failed state'
        }
      };
    }

    // อัพเดต retry count
    await this.prisma.webhookLog.update({
      where: { id: webhookLogId },
      data: { retryCount: { increment: 1 } }
    });

    // Retry processing
    return this.processWebhook(webhookLog.payload as N8NWebhookPayload);
  }

  /**
   * ดึงรายการ failed webhooks ที่ควร retry
   */
  async getRetryableFailedWebhooks() {
    return await this.prisma.webhookLog.findMany({
      where: {
        status: 'FAILED',
        retryCount: { lt: this.retryConfig.maxRetries },
        createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } // ใน 24 ชั่วโมงที่ผ่านมา
      },
      orderBy: { createdAt: 'asc' }
    });
  }
}

// Export singleton instance
export const webhookProcessor = new WebhookProcessor(new PrismaClient());