// Webhook Retry Service for Failed Processing
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import { webhookProcessor } from './webhook-processor';
import { N8NWebhookPayload, WebhookErrorCode } from '../types/webhook-types';

export class WebhookRetryService {
  private prisma: PrismaClient;
  private isProcessing = false;

  // Retry configuration
  private readonly retryConfig = {
    maxRetries: 3,
    retryDelays: [2000, 10000, 30000], // 2s, 10s, 30s
    retryableErrors: [
      WebhookErrorCode.DATABASE_ERROR,
      WebhookErrorCode.CUSTOMER_CREATION_FAILED,
      WebhookErrorCode.JOB_CREATION_FAILED,
      'NETWORK_ERROR',
      'TIMEOUT_ERROR'
    ],
    exponentialBackoff: true,
    maxRetryAge: 24 * 60 * 60 * 1000, // 24 hours
  };

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  /**
   * เริ่ม retry processor (เรียกเป็นระยะ)
   */
  async startRetryProcessor(intervalMs: number = 60000) { // ทุก 1 นาที
    if (this.isProcessing) {
      console.log('Retry processor already running');
      return;
    }

    console.log('Starting webhook retry processor...');
    this.isProcessing = true;

    const processRetries = async () => {
      try {
        await this.processFailedWebhooks();
      } catch (error) {
        console.error('Error in retry processor:', error);
      }

      if (this.isProcessing) {
        setTimeout(processRetries, intervalMs);
      }
    };

    // เริ่ม processing loop
    processRetries();
  }

  /**
   * หยุด retry processor
   */
  stopRetryProcessor() {
    console.log('Stopping webhook retry processor...');
    this.isProcessing = false;
  }

  /**
   * ประมวลผล failed webhooks ทั้งหมดที่ควร retry
   */
  async processFailedWebhooks() {
    const failedWebhooks = await this.getRetryableWebhooks();

    if (failedWebhooks.length === 0) {
      return;
    }

    console.log(`Found ${failedWebhooks.length} failed webhooks to retry`);

    for (const webhook of failedWebhooks) {
      try {
        await this.retryWebhook(webhook.id);
      } catch (error) {
        console.error(`Error retrying webhook ${webhook.id}:`, error);
      }

      // หน่วงเวลาเล็กน้อยระหว่างการ retry
      await this.delay(100);
    }
  }

  /**
   * Retry webhook เฉพาะรายการ
   */
  async retryWebhook(webhookLogId: string): Promise<boolean> {
    const webhookLog = await this.prisma.webhookLog.findUnique({
      where: { id: webhookLogId }
    });

    if (!webhookLog) {
      console.error(`Webhook log ${webhookLogId} not found`);
      return false;
    }

    // ตรวจสอบว่าควร retry หรือไม่
    if (!this.shouldRetry(webhookLog)) {
      await this.moveToDeadLetter(webhookLog);
      return false;
    }

    // คำนวณ delay สำหรับการ retry
    const retryDelay = this.calculateRetryDelay(webhookLog.retryCount);

    // ตรวจสอบว่าถึงเวลา retry แล้วหรือยัง
    const nextRetryTime = new Date(webhookLog.updatedAt.getTime() + retryDelay);
    if (new Date() < nextRetryTime) {
      console.log(`Webhook ${webhookLogId} not ready for retry yet (next retry: ${nextRetryTime.toISOString()})`);
      return false;
    }

    console.log(`Retrying webhook ${webhookLogId} (attempt ${webhookLog.retryCount + 1})`);

    try {
      // อัพเดต retry count
      await this.prisma.webhookLog.update({
        where: { id: webhookLogId },
        data: {
          retryCount: { increment: 1 },
          status: 'PROCESSING',
          updatedAt: new Date()
        }
      });

      // ลอง process อีกครั้ง
      const result = await webhookProcessor.processWebhook(
        webhookLog.payload as N8NWebhookPayload
      );

      if (result.success) {
        console.log(`Webhook ${webhookLogId} retry successful`);

        // อัพเดต status เป็น processed
        await this.prisma.webhookLog.update({
          where: { id: webhookLogId },
          data: {
            status: 'PROCESSED',
            processedAt: new Date(),
            errorMessage: null,
            createdJobId: result.data?.jobId,
            updatedAt: new Date()
          }
        });

        return true;
      } else {
        console.error(`Webhook ${webhookLogId} retry failed:`, result.error);

        // อัพเดต error message
        await this.prisma.webhookLog.update({
          where: { id: webhookLogId },
          data: {
            status: 'FAILED',
            errorMessage: result.error?.message,
            updatedAt: new Date()
          }
        });

        return false;
      }

    } catch (error) {
      console.error(`Unexpected error retrying webhook ${webhookLogId}:`, error);

      // อัพเดต error
      await this.prisma.webhookLog.update({
        where: { id: webhookLogId },
        data: {
          status: 'FAILED',
          errorMessage: (error as Error).message,
          updatedAt: new Date()
        }
      });

      return false;
    }
  }

  /**
   * ดึงรายการ webhook ที่ควร retry
   */
  private async getRetryableWebhooks() {
    const maxAge = new Date(Date.now() - this.retryConfig.maxRetryAge);

    return await this.prisma.webhookLog.findMany({
      where: {
        status: 'FAILED',
        retryCount: { lt: this.retryConfig.maxRetries },
        createdAt: { gte: maxAge }
      },
      orderBy: { createdAt: 'asc' },
      take: 50 // จำกัดจำนวนที่ process ต่อรอบ
    });
  }

  /**
   * ตรวจสอบว่าควร retry หรือไม่
   */
  private shouldRetry(webhookLog: any): boolean {
    // ตรวจสอบจำนวน retry
    if (webhookLog.retryCount >= this.retryConfig.maxRetries) {
      return false;
    }

    // ตรวจสอบอายุของ webhook
    const maxAge = new Date(Date.now() - this.retryConfig.maxRetryAge);
    if (webhookLog.createdAt < maxAge) {
      return false;
    }

    // ตรวจสอบประเภท error ที่สามารถ retry ได้
    const errorMessage = webhookLog.errorMessage || '';
    const isRetryableError = this.retryConfig.retryableErrors.some(
      error => errorMessage.includes(error)
    );

    return isRetryableError;
  }

  /**
   * คำนวณ delay สำหรับการ retry
   */
  private calculateRetryDelay(retryCount: number): number {
    if (retryCount < this.retryConfig.retryDelays.length) {
      return this.retryConfig.retryDelays[retryCount];
    }

    // ใช้ exponential backoff สำหรับ retry ที่เกิน
    if (this.retryConfig.exponentialBackoff) {
      const baseDelay = this.retryConfig.retryDelays[this.retryConfig.retryDelays.length - 1];
      return baseDelay * Math.pow(2, retryCount - this.retryConfig.retryDelays.length);
    }

    // ใช้ delay สุดท้าย
    return this.retryConfig.retryDelays[this.retryConfig.retryDelays.length - 1];
  }

  /**
   * ย้าย webhook ที่ไม่สามารถ retry ได้ไป dead letter queue
   */
  private async moveToDeadLetter(webhookLog: any) {
    console.log(`Moving webhook ${webhookLog.id} to dead letter queue`);

    try {
      // สร้าง failed webhook record
      await this.prisma.failedWebhook.create({
        data: {
          originalLogId: webhookLog.id,
          payload: webhookLog.payload,
          errorDetails: webhookLog.errorMessage || 'Max retries exceeded',
          manualReview: true
        }
      });

      // อัพเดต status ของ webhook log
      await this.prisma.webhookLog.update({
        where: { id: webhookLog.id },
        data: {
          status: 'RETRY_NEEDED', // หรือสร้าง status ใหม่ เช่น 'DEAD_LETTER'
          updatedAt: new Date()
        }
      });

      console.log(`Webhook ${webhookLog.id} moved to dead letter queue`);

    } catch (error) {
      console.error(`Error moving webhook ${webhookLog.id} to dead letter:`, error);
    }
  }

  /**
   * รายงานสถิติการ retry
   */
  async getRetryStatistics() {
    const stats = await this.prisma.webhookLog.groupBy({
      by: ['status'],
      _count: { status: true },
      where: {
        createdAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } // ใน 24 ชั่วโมงที่ผ่านมา
      }
    });

    const failedWebhooks = await this.prisma.failedWebhook.count({
      where: {
        failedAt: { gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
      }
    });

    return {
      webhookStats: stats.reduce((acc, stat) => {
        acc[stat.status] = stat._count.status;
        return acc;
      }, {} as Record<string, number>),
      deadLetterCount: failedWebhooks,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * ทำความสะอาด webhook logs เก่า
   */
  async cleanupOldWebhooks(olderThanDays: number = 30) {
    const cutoffDate = new Date(Date.now() - olderThanDays * 24 * 60 * 60 * 1000);

    const deleted = await this.prisma.webhookLog.deleteMany({
      where: {
        status: 'PROCESSED',
        createdAt: { lt: cutoffDate }
      }
    });

    console.log(`Cleaned up ${deleted.count} old webhook logs`);
    return deleted.count;
  }

  /**
   * Utility function for delay
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Export singleton instance
export const webhookRetryService = new WebhookRetryService(new PrismaClient());