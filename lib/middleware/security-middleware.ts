// Security Middleware for Tinedy CRM API Endpoints
// Generated by Database Agent (Alex)

import { NextRequest, NextResponse } from 'next/server';
import { headers } from 'next/headers';
import { rateLimit } from './rate-limiter';
import { validateJWT, hasPermission } from './auth-utils';

// Security configuration
const SECURITY_CONFIG = {
  rateLimits: {
    default: { requests: 100, window: 60 * 1000 }, // 100 req/min
    auth: { requests: 5, window: 60 * 1000 },      // 5 req/min for auth
    webhook: { requests: 1000, window: 60 * 1000 }, // 1000 req/min for webhooks
  },
  cors: {
    allowedOrigins: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
    allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization', 'x-api-key'],
  },
  security: {
    maxRequestSize: 10 * 1024 * 1024, // 10MB
    allowedFileTypes: ['image/jpeg', 'image/png', 'application/pdf'],
    suspiciousPatterns: [
      /\b(union|select|insert|delete|drop|create|alter)\b/i, // SQL injection
      /<script[^>]*>.*?<\/script>/gi, // XSS
      /javascript:/gi, // JavaScript protocol
      /__proto__/gi, // Prototype pollution
    ]
  }
};

/**
 * Main security middleware
 */
export async function securityMiddleware(
  request: NextRequest,
  context: { params?: any }
) {
  const startTime = Date.now();

  try {
    // 1. Rate limiting
    const rateLimitResult = await applyRateLimit(request);
    if (!rateLimitResult.allowed) {
      return createErrorResponse('Rate limit exceeded', 429, {
        'X-RateLimit-Limit': rateLimitResult.limit.toString(),
        'X-RateLimit-Remaining': '0',
        'X-RateLimit-Reset': rateLimitResult.resetTime.toString(),
      });
    }

    // 2. CORS validation
    const corsResult = await validateCORS(request);
    if (!corsResult.allowed) {
      return createErrorResponse('CORS policy violation', 403);
    }

    // 3. Request size validation
    const sizeResult = await validateRequestSize(request);
    if (!sizeResult.valid) {
      return createErrorResponse('Request size too large', 413);
    }

    // 4. Content validation
    const contentResult = await validateRequestContent(request);
    if (!contentResult.valid) {
      return createErrorResponse('Suspicious content detected', 400);
    }

    // 5. Authentication & Authorization
    const authResult = await validateAuthentication(request);
    if (!authResult.valid) {
      return createErrorResponse('Authentication required', 401);
    }

    // 6. Log security event
    await logSecurityEvent('request_processed', {
      ip: getClientIP(request),
      userAgent: request.headers.get('user-agent'),
      path: request.nextUrl.pathname,
      method: request.method,
      userId: authResult.user?.id,
      processingTime: Date.now() - startTime
    });

    // Add security headers to response
    const response = NextResponse.next();
    addSecurityHeaders(response);

    return response;

  } catch (error) {
    console.error('Security middleware error:', error);

    await logSecurityEvent('middleware_error', {
      ip: getClientIP(request),
      error: (error as Error).message,
      path: request.nextUrl.pathname
    });

    return createErrorResponse('Security validation failed', 500);
  }
}

/**
 * Apply rate limiting based on endpoint
 */
async function applyRateLimit(request: NextRequest) {
  const path = request.nextUrl.pathname;
  const clientIP = getClientIP(request);

  let limitConfig = SECURITY_CONFIG.rateLimits.default;

  // Set different limits for different endpoints
  if (path.includes('/auth/')) {
    limitConfig = SECURITY_CONFIG.rateLimits.auth;
  } else if (path.includes('/webhook/')) {
    limitConfig = SECURITY_CONFIG.rateLimits.webhook;
  }

  return await rateLimit(clientIP, limitConfig.requests, limitConfig.window);
}

/**
 * Validate CORS policy
 */
async function validateCORS(request: NextRequest) {
  const origin = request.headers.get('origin');
  const method = request.method;

  // Allow same-origin requests
  if (!origin) {
    return { allowed: true };
  }

  // Check allowed origins
  const isAllowedOrigin = SECURITY_CONFIG.cors.allowedOrigins.includes(origin) ||
                         SECURITY_CONFIG.cors.allowedOrigins.includes('*');

  // Check allowed methods
  const isAllowedMethod = SECURITY_CONFIG.cors.allowedMethods.includes(method);

  return {
    allowed: isAllowedOrigin && isAllowedMethod,
    origin,
    method
  };
}

/**
 * Validate request size
 */
async function validateRequestSize(request: NextRequest) {
  const contentLength = request.headers.get('content-length');

  if (contentLength) {
    const size = parseInt(contentLength, 10);
    if (size > SECURITY_CONFIG.security.maxRequestSize) {
      return { valid: false, size };
    }
  }

  return { valid: true };
}

/**
 * Validate request content for suspicious patterns
 */
async function validateRequestContent(request: NextRequest) {
  try {
    // Only validate text content
    const contentType = request.headers.get('content-type') || '';
    if (!contentType.includes('application/json') && !contentType.includes('text/')) {
      return { valid: true };
    }

    // Get request body for validation
    const body = await request.text();

    // Check for suspicious patterns
    for (const pattern of SECURITY_CONFIG.security.suspiciousPatterns) {
      if (pattern.test(body)) {
        await logSecurityEvent('suspicious_content_detected', {
          ip: getClientIP(request),
          pattern: pattern.toString(),
          path: request.nextUrl.pathname,
          contentPreview: body.substring(0, 200)
        });

        return { valid: false, pattern: pattern.toString() };
      }
    }

    return { valid: true };

  } catch (error) {
    // If we can't read the body, allow the request
    return { valid: true };
  }
}

/**
 * Validate authentication and authorization
 */
async function validateAuthentication(request: NextRequest) {
  const path = request.nextUrl.pathname;

  // Public endpoints that don't require authentication
  const publicPaths = [
    '/api/health',
    '/api/webhook/', // Webhooks use different auth
    '/auth/', // Auth endpoints
  ];

  if (publicPaths.some(p => path.startsWith(p))) {
    return { valid: true };
  }

  // Check for JWT token
  const authHeader = request.headers.get('authorization');
  const token = authHeader?.replace('Bearer ', '');

  if (!token) {
    return { valid: false, reason: 'Missing token' };
  }

  try {
    const decoded = await validateJWT(token);

    // Check if user has permission for this endpoint
    const hasAccess = await hasPermission(decoded.userId, path, request.method);

    if (!hasAccess) {
      return { valid: false, reason: 'Insufficient permissions' };
    }

    return { valid: true, user: decoded };

  } catch (error) {
    return { valid: false, reason: 'Invalid token' };
  }
}

/**
 * Add security headers to response
 */
function addSecurityHeaders(response: NextResponse) {
  // HSTS
  response.headers.set(
    'Strict-Transport-Security',
    'max-age=31536000; includeSubDomains; preload'
  );

  // Content Security Policy
  response.headers.set(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:;"
  );

  // X-Frame-Options
  response.headers.set('X-Frame-Options', 'DENY');

  // X-Content-Type-Options
  response.headers.set('X-Content-Type-Options', 'nosniff');

  // Referrer Policy
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');

  // Permissions Policy
  response.headers.set(
    'Permissions-Policy',
    'camera=(), microphone=(), geolocation=()'
  );

  // Remove server identification
  response.headers.delete('Server');
  response.headers.delete('X-Powered-By');
}

/**
 * Get client IP address
 */
function getClientIP(request: NextRequest): string {
  const forwarded = request.headers.get('x-forwarded-for');
  const realIP = request.headers.get('x-real-ip');
  const connectingIP = request.headers.get('cf-connecting-ip');

  return (
    connectingIP ||
    realIP ||
    forwarded?.split(',')[0] ||
    request.ip ||
    'unknown'
  );
}

/**
 * Create standardized error response
 */
function createErrorResponse(
  message: string,
  status: number,
  additionalHeaders: Record<string, string> = {}
) {
  const response = NextResponse.json(
    {
      error: {
        message,
        status,
        timestamp: new Date().toISOString(),
        requestId: crypto.randomUUID(),
      }
    },
    { status }
  );

  // Add security headers
  addSecurityHeaders(response);

  // Add additional headers
  Object.entries(additionalHeaders).forEach(([key, value]) => {
    response.headers.set(key, value);
  });

  return response;
}

/**
 * Log security events
 */
async function logSecurityEvent(
  event: string,
  details: Record<string, any>
) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    ...details,
    environment: process.env.NODE_ENV,
    service: 'tinedy-crm-api'
  };

  // In production, send to security monitoring service
  if (process.env.NODE_ENV === 'production') {
    // TODO: Integrate with security monitoring service (e.g., Sentry, DataDog)
    console.log('Security Event:', JSON.stringify(logEntry));
  } else {
    console.log('Security Event:', logEntry);
  }

  // Critical events should trigger alerts
  const criticalEvents = [
    'suspicious_content_detected',
    'authentication_failure',
    'authorization_failure',
    'rate_limit_exceeded'
  ];

  if (criticalEvents.includes(event)) {
    await triggerSecurityAlert(event, details);
  }
}

/**
 * Trigger security alerts for critical events
 */
async function triggerSecurityAlert(
  event: string,
  details: Record<string, any>
) {
  // TODO: Implement alerting mechanism (email, Slack, etc.)
  console.warn(`ðŸš¨ SECURITY ALERT: ${event}`, details);
}

// Export middleware configuration
export const config = {
  matcher: [
    '/api/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};

export default securityMiddleware;