// Rate Limiter Implementation for Tinedy CRM
// Generated by Database Agent (Alex)

interface RateLimitResult {
  allowed: boolean;
  limit: number;
  remaining: number;
  resetTime: number;
}

interface RateLimitEntry {
  count: number;
  resetTime: number;
}

// In-memory store for development (use Redis in production)
const rateLimitStore = new Map<string, RateLimitEntry>();

/**
 * Token bucket rate limiter
 */
export async function rateLimit(
  identifier: string,
  maxRequests: number,
  windowMs: number
): Promise<RateLimitResult> {
  const now = Date.now();
  const key = `rate_limit:${identifier}`;

  // Get existing entry
  const existing = rateLimitStore.get(key);

  // If no existing entry or window has passed, create new
  if (!existing || now >= existing.resetTime) {
    const newEntry: RateLimitEntry = {
      count: 1,
      resetTime: now + windowMs
    };

    rateLimitStore.set(key, newEntry);

    return {
      allowed: true,
      limit: maxRequests,
      remaining: maxRequests - 1,
      resetTime: newEntry.resetTime
    };
  }

  // Check if limit exceeded
  if (existing.count >= maxRequests) {
    return {
      allowed: false,
      limit: maxRequests,
      remaining: 0,
      resetTime: existing.resetTime
    };
  }

  // Increment count
  existing.count++;
  rateLimitStore.set(key, existing);

  return {
    allowed: true,
    limit: maxRequests,
    remaining: maxRequests - existing.count,
    resetTime: existing.resetTime
  };
}

/**
 * Advanced rate limiter with different strategies
 */
export class AdvancedRateLimiter {
  private store = new Map<string, any>();

  /**
   * Sliding window rate limiter
   */
  async slidingWindow(
    identifier: string,
    maxRequests: number,
    windowMs: number
  ): Promise<RateLimitResult> {
    const now = Date.now();
    const key = `sliding:${identifier}`;

    // Get existing timestamps
    const timestamps = this.store.get(key) || [];

    // Remove old timestamps outside window
    const validTimestamps = timestamps.filter(
      (ts: number) => now - ts < windowMs
    );

    // Check if limit exceeded
    if (validTimestamps.length >= maxRequests) {
      return {
        allowed: false,
        limit: maxRequests,
        remaining: 0,
        resetTime: validTimestamps[0] + windowMs
      };
    }

    // Add current timestamp
    validTimestamps.push(now);
    this.store.set(key, validTimestamps);

    return {
      allowed: true,
      limit: maxRequests,
      remaining: maxRequests - validTimestamps.length,
      resetTime: now + windowMs
    };
  }

  /**
   * Leaky bucket rate limiter
   */
  async leakyBucket(
    identifier: string,
    capacity: number,
    leakRate: number // requests per second
  ): Promise<RateLimitResult> {
    const now = Date.now();
    const key = `bucket:${identifier}`;

    // Get existing bucket
    const bucket = this.store.get(key) || {
      level: 0,
      lastLeak: now
    };

    // Calculate leak amount
    const timePassed = (now - bucket.lastLeak) / 1000; // seconds
    const leakAmount = timePassed * leakRate;

    // Apply leak
    bucket.level = Math.max(0, bucket.level - leakAmount);
    bucket.lastLeak = now;

    // Check if bucket is full
    if (bucket.level >= capacity) {
      this.store.set(key, bucket);
      return {
        allowed: false,
        limit: capacity,
        remaining: 0,
        resetTime: now + ((bucket.level - capacity + 1) / leakRate) * 1000
      };
    }

    // Add request to bucket
    bucket.level += 1;
    this.store.set(key, bucket);

    return {
      allowed: true,
      limit: capacity,
      remaining: Math.floor(capacity - bucket.level),
      resetTime: now + (bucket.level / leakRate) * 1000
    };
  }
}

/**
 * Distributed rate limiter using Redis (for production)
 */
export class RedisRateLimiter {
  private redis: any; // Redis client

  constructor(redisClient: any) {
    this.redis = redisClient;
  }

  async rateLimit(
    identifier: string,
    maxRequests: number,
    windowMs: number
  ): Promise<RateLimitResult> {
    const key = `rate_limit:${identifier}`;
    const now = Date.now();
    const windowStart = now - windowMs;

    // Use Redis sorted sets for sliding window
    const pipe = this.redis.pipeline();

    // Remove old entries
    pipe.zremrangebyscore(key, 0, windowStart);

    // Count current requests
    pipe.zcard(key);

    // Add current request
    pipe.zadd(key, now, `${now}-${Math.random()}`);

    // Set expiration
    pipe.expire(key, Math.ceil(windowMs / 1000));

    const results = await pipe.exec();
    const currentCount = results[1][1];

    if (currentCount > maxRequests) {
      // Remove the request we just added
      await this.redis.zrem(key, `${now}-${Math.random()}`);

      return {
        allowed: false,
        limit: maxRequests,
        remaining: 0,
        resetTime: now + windowMs
      };
    }

    return {
      allowed: true,
      limit: maxRequests,
      remaining: maxRequests - currentCount,
      resetTime: now + windowMs
    };
  }
}

/**
 * Rate limit configuration for different endpoints
 */
export const RATE_LIMIT_CONFIGS = {
  // Authentication endpoints - strict limits
  auth: {
    login: { requests: 5, window: 15 * 60 * 1000 }, // 5 attempts per 15 minutes
    register: { requests: 3, window: 60 * 60 * 1000 }, // 3 attempts per hour
    resetPassword: { requests: 3, window: 60 * 60 * 1000 }
  },

  // API endpoints - moderate limits
  api: {
    read: { requests: 1000, window: 60 * 1000 }, // 1000 requests per minute
    write: { requests: 100, window: 60 * 1000 }, // 100 requests per minute
    delete: { requests: 10, window: 60 * 1000 }  // 10 requests per minute
  },

  // Webhook endpoints - high limits
  webhook: {
    n8n: { requests: 10000, window: 60 * 1000 }, // 10k requests per minute
    lineOA: { requests: 5000, window: 60 * 1000 }
  },

  // Admin endpoints - very strict limits
  admin: {
    userManagement: { requests: 50, window: 60 * 1000 },
    systemConfig: { requests: 10, window: 60 * 1000 }
  }
};

/**
 * Get rate limit configuration for endpoint
 */
export function getRateLimitConfig(path: string, method: string) {
  // Authentication endpoints
  if (path.includes('/auth/signin')) return RATE_LIMIT_CONFIGS.auth.login;
  if (path.includes('/auth/signup')) return RATE_LIMIT_CONFIGS.auth.register;
  if (path.includes('/auth/reset')) return RATE_LIMIT_CONFIGS.auth.resetPassword;

  // Webhook endpoints
  if (path.includes('/webhook/n8n')) return RATE_LIMIT_CONFIGS.webhook.n8n;
  if (path.includes('/webhook/line')) return RATE_LIMIT_CONFIGS.webhook.lineOA;

  // Admin endpoints
  if (path.includes('/admin/users')) return RATE_LIMIT_CONFIGS.admin.userManagement;
  if (path.includes('/admin/system')) return RATE_LIMIT_CONFIGS.admin.systemConfig;

  // API endpoints by method
  switch (method) {
    case 'GET':
    case 'HEAD':
      return RATE_LIMIT_CONFIGS.api.read;
    case 'DELETE':
      return RATE_LIMIT_CONFIGS.api.delete;
    case 'POST':
    case 'PUT':
    case 'PATCH':
    default:
      return RATE_LIMIT_CONFIGS.api.write;
  }
}

/**
 * Cleanup expired entries (run periodically)
 */
export function cleanupRateLimitStore() {
  const now = Date.now();

  for (const [key, entry] of rateLimitStore.entries()) {
    if (entry.resetTime <= now) {
      rateLimitStore.delete(key);
    }
  }
}

// Run cleanup every 5 minutes
setInterval(cleanupRateLimitStore, 5 * 60 * 1000);

export { rateLimit as default };