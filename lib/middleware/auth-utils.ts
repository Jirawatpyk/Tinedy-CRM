// Authentication & Authorization Utilities for Tinedy CRM
// Generated by Database Agent (Alex)

import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export interface JWTPayload {
  userId: string;
  email: string;
  role: string;
  sessionId: string;
  iat: number;
  exp: number;
}

export interface Permission {
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

// Role-based permissions configuration
const ROLE_PERMISSIONS: Record<string, Permission[]> = {
  ADMIN: [
    { resource: '*', action: '*' }, // Full access
  ],

  OPERATIONS: [
    // Customer management
    { resource: 'customers', action: 'read' },
    { resource: 'customers', action: 'update' },

    // Job management
    { resource: 'jobs', action: 'read' },
    { resource: 'jobs', action: 'create' },
    { resource: 'jobs', action: 'update', conditions: { assignedTo: 'self' } },

    // Quality checks (assigned jobs only)
    { resource: 'quality-checks', action: 'read', conditions: { assignedTo: 'self' } },
    { resource: 'quality-checks', action: 'update', conditions: { assignedTo: 'self' } },

    // Training workflows (assigned jobs only)
    { resource: 'training-workflows', action: 'read', conditions: { assignedTo: 'self' } },
    { resource: 'training-workflows', action: 'update', conditions: { assignedTo: 'self' } },
  ],

  TRAINING: [
    // Training-specific permissions
    { resource: 'training-workflows', action: 'read' },
    { resource: 'training-workflows', action: 'update' },

    // Jobs related to training
    { resource: 'jobs', action: 'read', conditions: { serviceType: 'training' } },
    { resource: 'jobs', action: 'update', conditions: { serviceType: 'training' } },

    // Customers (read-only for training context)
    { resource: 'customers', action: 'read' },
  ],

  QC_MANAGER: [
    // Quality control permissions
    { resource: 'quality-checks', action: '*' },
    { resource: 'quality-checklists', action: '*' },

    // Jobs (read for QC context)
    { resource: 'jobs', action: 'read' },
    { resource: 'jobs', action: 'update', conditions: { field: 'status' } },

    // Customers (read-only)
    { resource: 'customers', action: 'read' },

    // Audit logs (read-only)
    { resource: 'audit-logs', action: 'read' },
  ]
};

/**
 * Validate JWT token
 */
export async function validateJWT(token: string): Promise<JWTPayload> {
  const secret = process.env.JWT_SECRET || process.env.NEXTAUTH_SECRET;

  if (!secret) {
    throw new Error('JWT secret not configured');
  }

  try {
    const decoded = jwt.verify(token, secret) as JWTPayload;

    // Verify session is still active
    const session = await prisma.session.findFirst({
      where: {
        sessionToken: decoded.sessionId,
        expires: { gt: new Date() }
      }
    });

    if (!session) {
      throw new Error('Session expired or invalid');
    }

    return decoded;

  } catch (error) {
    throw new Error(`Invalid token: ${(error as Error).message}`);
  }
}

/**
 * Check if user has permission for specific action
 */
export async function hasPermission(
  userId: string,
  resource: string,
  action: string,
  context?: Record<string, any>
): Promise<boolean> {
  try {
    // Get user with role
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { role: true, isActive: true }
    });

    if (!user || !user.isActive) {
      return false;
    }

    // Get permissions for user's role
    const permissions = ROLE_PERMISSIONS[user.role] || [];

    // Check permissions
    return checkPermission(permissions, resource, action, {
      ...context,
      userId,
      userRole: user.role
    });

  } catch (error) {
    console.error('Permission check error:', error);
    return false;
  }
}

/**
 * Check specific permission against permission list
 */
function checkPermission(
  permissions: Permission[],
  resource: string,
  action: string,
  context: Record<string, any>
): boolean {
  for (const permission of permissions) {
    // Check resource match
    if (permission.resource !== '*' && permission.resource !== resource) {
      continue;
    }

    // Check action match
    if (permission.action !== '*' && permission.action !== action) {
      continue;
    }

    // Check conditions
    if (permission.conditions && !checkConditions(permission.conditions, context)) {
      continue;
    }

    // Permission matched
    return true;
  }

  return false;
}

/**
 * Check permission conditions
 */
function checkConditions(
  conditions: Record<string, any>,
  context: Record<string, any>
): boolean {
  for (const [key, value] of Object.entries(conditions)) {
    switch (key) {
      case 'assignedTo':
        if (value === 'self') {
          // Check if resource is assigned to current user
          if (!context.assignedToId || context.assignedToId !== context.userId) {
            return false;
          }
        }
        break;

      case 'serviceType':
        if (value === 'training') {
          // Check if job is training-related
          if (!context.serviceType?.includes('‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°')) {
            return false;
          }
        }
        break;

      case 'field':
        // Check if user is only updating specific fields
        if (context.updateFields && !context.updateFields.includes(value)) {
          return false;
        }
        break;

      default:
        // Direct value comparison
        if (context[key] !== value) {
          return false;
        }
    }
  }

  return true;
}

/**
 * Get user permissions list
 */
export async function getUserPermissions(userId: string): Promise<Permission[]> {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true, isActive: true }
  });

  if (!user || !user.isActive) {
    return [];
  }

  return ROLE_PERMISSIONS[user.role] || [];
}

/**
 * Check resource-level access
 */
export async function canAccessResource(
  userId: string,
  resourceType: string,
  resourceId: string,
  action: string
): Promise<boolean> {
  // Get additional context based on resource type
  let context: Record<string, any> = { userId };

  switch (resourceType) {
    case 'jobs':
      const job = await prisma.job.findUnique({
        where: { id: resourceId },
        select: { assignedToId: true, serviceType: true, customerId: true }
      });

      if (job) {
        context = {
          ...context,
          assignedToId: job.assignedToId,
          serviceType: job.serviceType,
          customerId: job.customerId
        };
      }
      break;

    case 'customers':
      // Add customer-specific context if needed
      context.customerId = resourceId;
      break;

    case 'quality-checks':
      const qc = await prisma.qualityCheck.findUnique({
        where: { id: resourceId },
        include: { job: { select: { assignedToId: true } } }
      });

      if (qc) {
        context.assignedToId = qc.job.assignedToId;
      }
      break;
  }

  return hasPermission(userId, resourceType, action, context);
}

/**
 * Generate secure session token
 */
export function generateSessionToken(): string {
  return jwt.sign(
    { type: 'session', timestamp: Date.now() },
    process.env.JWT_SECRET || 'fallback-secret',
    { expiresIn: '24h' }
  );
}

/**
 * Security audit logging for auth events
 */
export async function logAuthEvent(
  event: string,
  userId?: string,
  details?: Record<string, any>
) {
  const logData = {
    timestamp: new Date(),
    event,
    userId,
    ...details,
    ip: details?.ip || 'unknown',
    userAgent: details?.userAgent || 'unknown'
  };

  // Log to audit table
  if (userId) {
    await prisma.auditLog.create({
      data: {
        entityType: 'Auth',
        entityId: userId,
        action: event,
        newValues: logData,
        userId: userId
      }
    });
  }

  // Log critical events to security monitoring
  const criticalEvents = [
    'login_failure',
    'unauthorized_access',
    'permission_denied',
    'session_hijack_attempt'
  ];

  if (criticalEvents.includes(event)) {
    console.warn(`üö® AUTH SECURITY EVENT: ${event}`, logData);
  }
}

/**
 * Middleware helper to extract user from request
 */
export async function getCurrentUser(authHeader?: string | null) {
  if (!authHeader) return null;

  const token = authHeader.replace('Bearer ', '');

  try {
    const decoded = await validateJWT(token);

    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        isActive: true
      }
    });

    return user;

  } catch (error) {
    return null;
  }
}

/**
 * Role hierarchy check
 */
export function hasHigherRole(userRole: string, targetRole: string): boolean {
  const hierarchy = ['ADMIN', 'QC_MANAGER', 'TRAINING', 'OPERATIONS'];
  const userIndex = hierarchy.indexOf(userRole);
  const targetIndex = hierarchy.indexOf(targetRole);

  return userIndex < targetIndex; // Lower index = higher role
}

/**
 * API endpoint authorization decorator
 */
export function requirePermission(resource: string, action: string) {
  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
    const method = descriptor.value!;

    descriptor.value = async function (...args: any[]) {
      const [request] = args;
      const authHeader = request.headers.get('authorization');

      if (!authHeader) {
        return new Response('Unauthorized', { status: 401 });
      }

      try {
        const decoded = await validateJWT(authHeader.replace('Bearer ', ''));
        const hasAccess = await hasPermission(decoded.userId, resource, action);

        if (!hasAccess) {
          await logAuthEvent('permission_denied', decoded.userId, {
            resource,
            action,
            endpoint: request.url
          });

          return new Response('Forbidden', { status: 403 });
        }

        // Add user context to request
        (request as any).user = decoded;

        return method.apply(this, args);

      } catch (error) {
        return new Response('Invalid token', { status: 401 });
      }
    };
  };
}

export default {
  validateJWT,
  hasPermission,
  canAccessResource,
  getUserPermissions,
  logAuthEvent,
  getCurrentUser,
  requirePermission
};