// Jest Setup Configuration
// Generated by Database Agent (Alex)

import { jest } from '@jest/globals';

// Set test environment variables
process.env.NODE_ENV = 'test';
process.env.TEST_DATABASE_URL = process.env.TEST_DATABASE_URL || 'postgresql://localhost:5432/tinedy_crm_test';
process.env.TEST_API_URL = process.env.TEST_API_URL || 'http://localhost:3000';

// Set up global test timeout
jest.setTimeout(30000);

// Global test utilities
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeValidCUID(): R;
      toBeValidThaiPhone(): R;
      toBeValidLineUserId(): R;
      toBeValidTimestamp(): R;
      toHaveValidPagination(): R;
    }
  }
}

// Custom Jest matchers
expect.extend({
  toBeValidCUID(received: string) {
    const pass = /^c[a-z0-9]{24}$/.test(received);
    return {
      message: () => `expected ${received} to be a valid CUID`,
      pass
    };
  },

  toBeValidThaiPhone(received: string) {
    const pass = /^(\+66|0)[0-9]{8,9}$/.test(received);
    return {
      message: () => `expected ${received} to be a valid Thai phone number`,
      pass
    };
  },

  toBeValidLineUserId(received: string) {
    const pass = /^U[a-fA-F0-9]{32}$/.test(received);
    return {
      message: () => `expected ${received} to be a valid LINE User ID`,
      pass
    };
  },

  toBeValidTimestamp(received: string | Date) {
    const date = new Date(received);
    const pass = !isNaN(date.getTime());
    return {
      message: () => `expected ${received} to be a valid timestamp`,
      pass
    };
  },

  toHaveValidPagination(received: any) {
    const hasData = Array.isArray(received.data);
    const hasPagination = received.pagination &&
      typeof received.pagination.page === 'number' &&
      typeof received.pagination.limit === 'number' &&
      typeof received.pagination.total === 'number';

    const pass = hasData && hasPagination;
    return {
      message: () => `expected ${JSON.stringify(received)} to have valid pagination structure`,
      pass
    };
  }
});

// Global error handling for unhandled promises
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

// Global warning suppression for known issues
const originalError = console.error;
console.error = (...args: any[]) => {
  // Suppress specific warnings during tests
  const message = args[0];
  if (
    typeof message === 'string' &&
    (
      message.includes('Warning: ReactDOM.render is deprecated') ||
      message.includes('Warning: componentWillReceiveProps') ||
      message.includes('punycode') // Suppress punycode deprecation warnings
    )
  ) {
    return;
  }
  originalError.apply(console, args);
};

// Mock console methods for cleaner test output
const originalConsole = {
  log: console.log,
  warn: console.warn,
  error: console.error,
  info: console.info
};

// Override console methods in test environment
if (process.env.SUPPRESS_TEST_LOGS === 'true') {
  console.log = jest.fn();
  console.warn = jest.fn();
  console.info = jest.fn();
  // Keep error for debugging
  console.error = originalConsole.error;
}

// Restore console after tests if needed
afterAll(() => {
  if (process.env.SUPPRESS_TEST_LOGS === 'true') {
    console.log = originalConsole.log;
    console.warn = originalConsole.warn;
    console.error = originalConsole.error;
    console.info = originalConsole.info;
  }
});

// Mock fetch for API testing
global.fetch = jest.fn();

// Reset fetch mock before each test
beforeEach(() => {
  (global.fetch as jest.Mock).mockClear();
});

// Mock environment variables for testing
const mockEnvVars = {
  DATABASE_URL: process.env.TEST_DATABASE_URL,
  NEXTAUTH_SECRET: 'test-secret-key-for-testing-only',
  NEXTAUTH_URL: 'http://localhost:3000',
  JWT_SECRET: 'test-jwt-secret-for-testing-only',
  N8N_WEBHOOK_SECRET: 'test-n8n-webhook-secret',
  LINE_OA_WEBHOOK_SECRET: 'test-line-webhook-secret'
};

// Apply mock environment variables
Object.entries(mockEnvVars).forEach(([key, value]) => {
  if (!process.env[key]) {
    process.env[key] = value;
  }
});

// Global test helpers
global.testHelpers = {
  // Wait for async operations
  wait: (ms: number) => new Promise(resolve => setTimeout(resolve, ms)),

  // Generate test IDs
  generateTestId: () => `test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,

  // Mock API response
  mockApiResponse: (data: any, status: number = 200) => ({
    ok: status >= 200 && status < 300,
    status,
    json: () => Promise.resolve(data),
    text: () => Promise.resolve(JSON.stringify(data)),
    headers: new Headers({
      'content-type': 'application/json'
    })
  }),

  // Mock API error
  mockApiError: (message: string, status: number = 400) => ({
    ok: false,
    status,
    json: () => Promise.resolve({
      error: message,
      timestamp: new Date().toISOString()
    }),
    text: () => Promise.resolve(JSON.stringify({
      error: message,
      timestamp: new Date().toISOString()
    })),
    headers: new Headers({
      'content-type': 'application/json'
    })
  })
};

// Type declarations for global helpers
declare global {
  var testHelpers: {
    wait: (ms: number) => Promise<void>;
    generateTestId: () => string;
    mockApiResponse: (data: any, status?: number) => any;
    mockApiError: (message: string, status?: number) => any;
  };
}

export {};