// Testing Configuration for Tinedy CRM
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import { execSync } from 'child_process';
import { randomBytes } from 'crypto';

// =============================================================================
// TEST ENVIRONMENT SETUP
// =============================================================================

/**
 * Test database configuration
 */
export const TEST_CONFIG = {
  // Database settings
  database: {
    url: process.env.TEST_DATABASE_URL || process.env.DATABASE_URL,
    resetBetweenTests: true,
    seedData: true,
    enableLogging: false
  },

  // API testing settings
  api: {
    baseUrl: process.env.TEST_API_URL || 'http://localhost:3000',
    timeout: 30000,
    retries: 3,
    enableMocking: true
  },

  // Security testing
  security: {
    testApiKeys: true,
    testRateLimit: true,
    testValidation: true,
    enableSecurityAudit: true
  },

  // Performance testing
  performance: {
    enablePerformanceTests: false, // Disable by default
    maxResponseTime: 1000, // ms
    maxMemoryUsage: 100, // MB
    concurrentUsers: 10
  },

  // Test data generation
  testData: {
    customerCount: 5,
    jobCount: 10,
    userCount: 3,
    webhookCount: 5,
    generateRealistic: true
  }
};

// =============================================================================
// TEST DATABASE UTILITIES
// =============================================================================

/**
 * Test database manager
 */
export class TestDatabaseManager {
  private static prisma: PrismaClient;
  private static isSetup = false;

  /**
   * Initialize test database
   */
  static async setup() {
    if (this.isSetup) return;

    console.log('üîß Setting up test database...');

    // Create Prisma client for testing
    this.prisma = new PrismaClient({
      datasources: {
        db: {
          url: TEST_CONFIG.database.url
        }
      },
      log: TEST_CONFIG.database.enableLogging ? ['query', 'error'] : ['error']
    });

    // Run database migrations
    try {
      execSync('npx prisma db push', {
        stdio: TEST_CONFIG.database.enableLogging ? 'inherit' : 'pipe',
        env: {
          ...process.env,
          DATABASE_URL: TEST_CONFIG.database.url
        }
      });
      console.log('‚úÖ Database migrations applied');
    } catch (error) {
      console.error('‚ùå Migration failed:', error);
      throw error;
    }

    // Seed test data if enabled
    if (TEST_CONFIG.database.seedData) {
      await this.seedTestData();
    }

    this.isSetup = true;
    console.log('‚úÖ Test database setup complete');
  }

  /**
   * Clean database between tests
   */
  static async cleanup() {
    if (!this.prisma) return;

    console.log('üßπ Cleaning test database...');

    try {
      // Delete all data in reverse dependency order
      await this.prisma.auditLog.deleteMany();
      await this.prisma.failedWebhook.deleteMany();
      await this.prisma.webhookLog.deleteMany();
      await this.prisma.trainingWorkflow.deleteMany();
      await this.prisma.qualityCheck.deleteMany();
      await this.prisma.qualityChecklist.deleteMany();
      await this.prisma.job.deleteMany();
      await this.prisma.customer.deleteMany();
      await this.prisma.user.deleteMany();

      console.log('‚úÖ Database cleaned');
    } catch (error) {
      console.error('‚ùå Database cleanup failed:', error);
      throw error;
    }
  }

  /**
   * Seed test data
   */
  static async seedTestData() {
    console.log('üå± Seeding test data...');

    try {
      // Create test users
      const users = await Promise.all([
        this.prisma.user.create({
          data: {
            email: 'admin@test.com',
            name: 'Test Admin',
            role: 'ADMIN',
            isActive: true
          }
        }),
        this.prisma.user.create({
          data: {
            email: 'operations@test.com',
            name: 'Test Operations',
            role: 'OPERATIONS',
            isActive: true
          }
        }),
        this.prisma.user.create({
          data: {
            email: 'qc@test.com',
            name: 'Test QC Manager',
            role: 'QC_MANAGER',
            isActive: true
          }
        })
      ]);

      // Create test customers
      const customers = await Promise.all(
        Array.from({ length: TEST_CONFIG.testData.customerCount }, (_, i) =>
          this.prisma.customer.create({
            data: {
              name: `‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏î‡∏™‡∏≠‡∏ö ${i + 1}`,
              phone: `+6681234567${i}`,
              email: `customer${i + 1}@test.com`,
              address: `‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏î‡∏™‡∏≠‡∏ö ${i + 1}`,
              status: 'ACTIVE',
              lineUserId: `U${randomBytes(16).toString('hex')}`
            }
          })
        )
      );

      // Create test jobs
      const jobs = await Promise.all(
        Array.from({ length: TEST_CONFIG.testData.jobCount }, (_, i) =>
          this.prisma.job.create({
            data: {
              customerId: customers[i % customers.length].id,
              serviceType: ['‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î', '‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°', '‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û'][i % 3],
              description: `‡∏á‡∏≤‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö ${i + 1}`,
              status: ['NEW', 'IN_PROGRESS', 'COMPLETED'][i % 3] as any,
              priority: ['LOW', 'MEDIUM', 'HIGH'][i % 3] as any,
              assignedToId: i % 2 === 0 ? users[1].id : null,
              scheduledAt: new Date(Date.now() + (i * 24 * 60 * 60 * 1000))
            }
          })
        )
      );

      // Create test quality checklist
      const checklist = await this.prisma.qualityChecklist.create({
        data: {
          name: 'Test Quality Checklist',
          description: 'Checklist for testing purposes',
          items: [
            { id: '1', text: '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î', required: true, category: 'cleaning' },
            { id: '2', text: '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢', required: true, category: 'safety' },
            { id: '3', text: '‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏á‡∏≤‡∏ô', required: true, category: 'quality' }
          ],
          isActive: true
        }
      });

      // Create test quality checks
      await Promise.all(
        jobs.slice(0, 3).map((job, i) =>
          this.prisma.qualityCheck.create({
            data: {
              jobId: job.id,
              checklistId: checklist.id,
              status: ['PENDING', 'IN_PROGRESS', 'PASSED'][i] as any,
              completedBy: i === 2 ? users[2].id : null,
              completedAt: i === 2 ? new Date() : null,
              notes: i === 2 ? '‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢' : null
            }
          })
        )
      );

      console.log('‚úÖ Test data seeded successfully');
    } catch (error) {
      console.error('‚ùå Test data seeding failed:', error);
      throw error;
    }
  }

  /**
   * Get Prisma client for tests
   */
  static getPrisma(): PrismaClient {
    if (!this.prisma) {
      throw new Error('Test database not initialized. Call setup() first.');
    }
    return this.prisma;
  }

  /**
   * Teardown test database
   */
  static async teardown() {
    if (this.prisma) {
      await this.prisma.$disconnect();
      this.isSetup = false;
      console.log('‚úÖ Test database disconnected');
    }
  }

  /**
   * Reset database to clean state
   */
  static async reset() {
    await this.cleanup();
    if (TEST_CONFIG.database.seedData) {
      await this.seedTestData();
    }
  }
}

// =============================================================================
// TEST UTILITIES
// =============================================================================

/**
 * Test utilities and helpers
 */
export class TestUtils {
  /**
   * Generate test customer data
   */
  static generateCustomerData(override: Partial<any> = {}) {
    return {
      name: '‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏î‡∏™‡∏≠‡∏ö',
      phone: '+66812345678',
      email: 'test@example.com',
      address: '‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏î‡∏™‡∏≠‡∏ö 123',
      status: 'ACTIVE',
      lineUserId: `U${randomBytes(16).toString('hex')}`,
      ...override
    };
  }

  /**
   * Generate test job data
   */
  static generateJobData(customerId: string, override: Partial<any> = {}) {
    return {
      customerId,
      serviceType: '‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö',
      description: '‡∏á‡∏≤‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö',
      status: 'NEW',
      priority: 'MEDIUM',
      scheduledAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
      ...override
    };
  }

  /**
   * Generate test user data
   */
  static generateUserData(override: Partial<any> = {}) {
    const id = randomBytes(4).toString('hex');
    return {
      email: `test${id}@example.com`,
      name: `Test User ${id}`,
      role: 'OPERATIONS',
      isActive: true,
      ...override
    };
  }

  /**
   * Generate test webhook data
   */
  static generateWebhookData(override: Partial<any> = {}) {
    return {
      source: 'TEST',
      workflowId: 'test-workflow',
      executionId: `exec-${randomBytes(8).toString('hex')}`,
      payload: {
        test: true,
        timestamp: new Date().toISOString(),
        data: { message: 'Test webhook payload' }
      },
      status: 'RECEIVED',
      retryCount: 0,
      ...override
    };
  }

  /**
   * Wait for async operation
   */
  static async waitFor(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Retry operation with backoff
   */
  static async retry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    backoffMs: number = 1000
  ): Promise<T> {
    let lastError: Error;

    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        if (i < maxRetries - 1) {
          await this.waitFor(backoffMs * Math.pow(2, i));
        }
      }
    }

    throw lastError!;
  }

  /**
   * Generate random string
   */
  static randomString(length: number = 8): string {
    return randomBytes(Math.ceil(length / 2)).toString('hex').slice(0, length);
  }

  /**
   * Generate random Thai phone number
   */
  static randomThaiPhone(): string {
    const prefix = '+668';
    const suffix = Math.floor(Math.random() * 100000000).toString().padStart(8, '0');
    return prefix + suffix;
  }

  /**
   * Generate random LINE User ID
   */
  static randomLineUserId(): string {
    return 'U' + randomBytes(16).toString('hex');
  }

  /**
   * Create test API request headers
   */
  static createHeaders(token?: string): Record<string, string> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };

    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    return headers;
  }

  /**
   * Assert response format
   */
  static assertApiResponse(response: any, expectedStatus: number = 200) {
    expect(response.status).toBe(expectedStatus);
    expect(response.headers.get('content-type')).toContain('application/json');
  }

  /**
   * Assert error response format
   */
  static assertErrorResponse(response: any, expectedStatus: number) {
    expect(response.status).toBe(expectedStatus);
    expect(response.body).toHaveProperty('error');
    expect(response.body).toHaveProperty('timestamp');
  }

  /**
   * Create mock webhook request
   */
  static createMockWebhookRequest(data: any) {
    return {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'n8n-webhook'
      },
      body: JSON.stringify(data)
    };
  }

  /**
   * Measure execution time
   */
  static async measureTime<T>(operation: () => Promise<T>): Promise<{ result: T; duration: number }> {
    const start = Date.now();
    const result = await operation();
    const duration = Date.now() - start;
    return { result, duration };
  }
}

// =============================================================================
// TEST ASSERTIONS
// =============================================================================

/**
 * Custom test assertions
 */
export class TestAssertions {
  /**
   * Assert Thai phone number format
   */
  static assertThaiPhone(phone: string) {
    expect(phone).toMatch(/^(\+66|0)[0-9]{8,9}$/);
  }

  /**
   * Assert LINE User ID format
   */
  static assertLineUserId(lineUserId: string) {
    expect(lineUserId).toMatch(/^U[a-fA-F0-9]{32}$/);
  }

  /**
   * Assert CUID format
   */
  static assertCUID(id: string) {
    expect(id).toMatch(/^c[a-z0-9]{24}$/);
  }

  /**
   * Assert timestamp format
   */
  static assertTimestamp(timestamp: string | Date) {
    const date = new Date(timestamp);
    expect(date).toBeInstanceOf(Date);
    expect(date.getTime()).not.toBeNaN();
  }

  /**
   * Assert job status transition is valid
   */
  static assertValidJobStatusTransition(from: string, to: string) {
    const validTransitions = {
      'NEW': ['IN_PROGRESS', 'CANCELLED'],
      'IN_PROGRESS': ['COMPLETED', 'ON_HOLD', 'CANCELLED'],
      'ON_HOLD': ['IN_PROGRESS', 'CANCELLED'],
      'COMPLETED': [],
      'CANCELLED': []
    };

    const allowed = validTransitions[from as keyof typeof validTransitions] || [];
    expect(allowed).toContain(to);
  }

  /**
   * Assert entity has required fields
   */
  static assertRequiredFields(entity: any, requiredFields: string[]) {
    requiredFields.forEach(field => {
      expect(entity).toHaveProperty(field);
      expect(entity[field]).toBeDefined();
    });
  }

  /**
   * Assert performance within limits
   */
  static assertPerformance(duration: number, maxDuration: number = 1000) {
    expect(duration).toBeLessThan(maxDuration);
  }

  /**
   * Assert validation error format
   */
  static assertValidationError(error: any) {
    expect(error).toHaveProperty('error');
    expect(error).toHaveProperty('details');
    expect(typeof error.error).toBe('string');
  }

  /**
   * Assert pagination response format
   */
  static assertPaginationResponse(response: any) {
    expect(response).toHaveProperty('data');
    expect(response).toHaveProperty('pagination');
    expect(response.pagination).toHaveProperty('page');
    expect(response.pagination).toHaveProperty('limit');
    expect(response.pagination).toHaveProperty('total');
    expect(Array.isArray(response.data)).toBe(true);
  }
}

// =============================================================================
// GLOBAL TEST SETUP
// =============================================================================

// Global test setup
beforeAll(async () => {
  await TestDatabaseManager.setup();
}, 30000); // 30 second timeout

// Global test teardown
afterAll(async () => {
  await TestDatabaseManager.teardown();
});

// Reset database between tests if enabled
beforeEach(async () => {
  if (TEST_CONFIG.database.resetBetweenTests) {
    await TestDatabaseManager.reset();
  }
});

export default {
  TEST_CONFIG,
  TestDatabaseManager,
  TestUtils,
  TestAssertions
};