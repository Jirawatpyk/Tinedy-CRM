// Webhook API Integration Tests
// Generated by Database Agent (Alex)

import { describe, it, expect, beforeEach } from '@jest/globals';
import { TestDatabaseManager, TestUtils, TestAssertions, TEST_CONFIG } from '../../setup/test-config';

const BASE_URL = TEST_CONFIG.api.baseUrl;

describe('Webhook API Integration Tests', () => {
  beforeEach(async () => {
    await TestDatabaseManager.reset();
  });

  describe('POST /api/webhook/n8n', () => {
    it('should process valid N8N webhook', async () => {
      const webhookPayload = {
        executionId: 'exec-12345',
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: 'ลูกค้าจาก LINE',
            phone: '+66812345678',
            lineUserId: TestUtils.randomLineUserId()
          },
          booking: {
            serviceType: 'บริการทำความสะอาด',
            description: 'ทำความสะอาดบ้าน 2 ชั้น',
            preferredDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
            priority: 'MEDIUM'
          }
        },
        timestamp: new Date().toISOString()
      };

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key' // Mock API key
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result).toHaveProperty('success', true);
      expect(result).toHaveProperty('webhookLogId');
      expect(result).toHaveProperty('customerId');
      expect(result).toHaveProperty('jobId');
    });

    it('should create customer from webhook if not exists', async () => {
      const lineUserId = TestUtils.randomLineUserId();
      const webhookPayload = {
        executionId: 'exec-new-customer',
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: 'ลูกค้าใหม่',
            phone: '+66887654321',
            lineUserId,
            email: 'new@example.com'
          },
          booking: {
            serviceType: 'บริการฝึกอบรม',
            description: 'ฝึกอบรมพนักงาน'
          }
        }
      };

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result.success).toBe(true);
      expect(result.customerId).toBeDefined();

      // Verify customer was created
      const customerResponse = await fetch(`${BASE_URL}/api/customers/${result.customerId}`, {
        headers: TestUtils.createHeaders()
      });

      expect(customerResponse.status).toBe(200);

      const customer = await customerResponse.json();
      expect(customer.name).toBe('ลูกค้าใหม่');
      expect(customer.lineUserId).toBe(lineUserId);
    });

    it('should use existing customer if LINE User ID matches', async () => {
      // Create existing customer
      const lineUserId = TestUtils.randomLineUserId();
      const existingCustomer = TestUtils.generateCustomerData({
        name: 'ลูกค้าเดิม',
        lineUserId
      });

      const createResponse = await fetch(`${BASE_URL}/api/customers`, {
        method: 'POST',
        headers: TestUtils.createHeaders(),
        body: JSON.stringify(existingCustomer)
      });

      const customer = await createResponse.json();

      // Send webhook with same LINE User ID
      const webhookPayload = {
        executionId: 'exec-existing',
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: 'ชื่อใหม่จาก LINE', // Different name
            lineUserId
          },
          booking: {
            serviceType: 'บริการใหม่'
          }
        }
      };

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result.customerId).toBe(customer.id);
    });

    it('should handle webhook without customer LINE User ID', async () => {
      const webhookPayload = {
        executionId: 'exec-no-line-id',
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: 'ลูกค้าไม่มี LINE ID',
            phone: '+66899887766'
          },
          booking: {
            serviceType: 'บริการทั่วไป'
          }
        }
      };

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result.success).toBe(true);
      expect(result.customerId).toBeDefined();
    });

    it('should reject webhook without API key', async () => {
      const webhookPayload = TestUtils.generateWebhookData();

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
          // Missing X-API-Key
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response.status).toBe(401);
    });

    it('should reject webhook with invalid API key', async () => {
      const webhookPayload = TestUtils.generateWebhookData();

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'invalid-key'
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response.status).toBe(401);
    });

    it('should validate webhook payload structure', async () => {
      const invalidPayloads = [
        {}, // Empty payload
        { executionId: 'test' }, // Missing data
        { data: {} }, // Missing execution ID
        { executionId: 'test', data: { customer: {} } }, // Missing booking
        { executionId: 'test', data: { booking: {} } } // Missing customer
      ];

      for (const payload of invalidPayloads) {
        const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': 'test-api-key'
          },
          body: JSON.stringify(payload)
        });

        expect(response.status).toBe(400);

        const result = await response.json();
        expect(result).toHaveProperty('error');
      }
    });

    it('should handle duplicate webhook executions', async () => {
      const webhookPayload = {
        executionId: 'exec-duplicate',
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: 'ลูกค้าซ้ำ',
            lineUserId: TestUtils.randomLineUserId()
          },
          booking: {
            serviceType: 'บริการทดสอบ'
          }
        }
      };

      // Send first webhook
      const response1 = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response1.status).toBe(200);
      const result1 = await response1.json();

      // Send duplicate webhook
      const response2 = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: JSON.stringify(webhookPayload)
      });

      expect(response2.status).toBe(200);
      const result2 = await response2.json();

      // Should detect duplicate and not create new records
      expect(result2.duplicate).toBe(true);
      expect(result2.originalWebhookLogId).toBe(result1.webhookLogId);
    });
  });

  describe('POST /api/webhook/line', () => {
    it('should process LINE OA webhook', async () => {
      const lineWebhookPayload = {
        destination: 'line-destination',
        events: [
          {
            type: 'message',
            mode: 'active',
            timestamp: Date.now(),
            source: {
              type: 'user',
              userId: TestUtils.randomLineUserId()
            },
            message: {
              id: 'msg-123',
              type: 'text',
              text: 'สวัสดี ต้องการจองบริการ'
            },
            replyToken: 'reply-token-123'
          }
        ]
      };

      const response = await fetch(`${BASE_URL}/api/webhook/line`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Line-Signature': 'test-signature'
        },
        body: JSON.stringify(lineWebhookPayload)
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result).toHaveProperty('success', true);
      expect(result).toHaveProperty('webhookLogId');
    });

    it('should reject LINE webhook without signature', async () => {
      const lineWebhookPayload = {
        destination: 'test',
        events: []
      };

      const response = await fetch(`${BASE_URL}/api/webhook/line`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
          // Missing X-Line-Signature
        },
        body: JSON.stringify(lineWebhookPayload)
      });

      expect(response.status).toBe(401);
    });
  });

  describe('GET /api/webhook/logs', () => {
    beforeEach(async () => {
      // Create test webhook logs
      const webhookData = [
        TestUtils.generateWebhookData({
          source: 'N8N',
          status: 'PROCESSED',
          executionId: 'exec-1'
        }),
        TestUtils.generateWebhookData({
          source: 'LINE_OA',
          status: 'FAILED',
          executionId: 'exec-2',
          errorMessage: 'Processing failed'
        }),
        TestUtils.generateWebhookData({
          source: 'N8N',
          status: 'PROCESSING',
          executionId: 'exec-3'
        })
      ];

      const prisma = TestDatabaseManager.getPrisma();
      for (const data of webhookData) {
        await prisma.webhookLog.create({ data });
      }
    });

    it('should get webhook logs with pagination', async () => {
      const response = await fetch(`${BASE_URL}/api/webhook/logs`, {
        headers: TestUtils.createHeaders()
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      TestAssertions.assertPaginationResponse(result);
      expect(result.data).toHaveLength(3);
    });

    it('should filter webhook logs by source', async () => {
      const response = await fetch(`${BASE_URL}/api/webhook/logs?source=N8N`, {
        headers: TestUtils.createHeaders()
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result.data).toHaveLength(2);
      result.data.forEach((log: any) => {
        expect(log.source).toBe('N8N');
      });
    });

    it('should filter webhook logs by status', async () => {
      const response = await fetch(`${BASE_URL}/api/webhook/logs?status=FAILED`, {
        headers: TestUtils.createHeaders()
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result.data).toHaveLength(1);
      expect(result.data[0].status).toBe('FAILED');
      expect(result.data[0].errorMessage).toBeDefined();
    });

    it('should sort webhook logs by creation date', async () => {
      const response = await fetch(`${BASE_URL}/api/webhook/logs?sortBy=createdAt&sortOrder=desc`, {
        headers: TestUtils.createHeaders()
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      const dates = result.data.map((log: any) => new Date(log.createdAt).getTime());

      for (let i = 1; i < dates.length; i++) {
        expect(dates[i]).toBeLessThanOrEqual(dates[i - 1]);
      }
    });
  });

  describe('POST /api/webhook/retry/:id', () => {
    let failedWebhookId: string;

    beforeEach(async () => {
      const prisma = TestDatabaseManager.getPrisma();
      const failedWebhook = await prisma.webhookLog.create({
        data: TestUtils.generateWebhookData({
          status: 'FAILED',
          errorMessage: 'Processing failed',
          retryCount: 2
        })
      });
      failedWebhookId = failedWebhook.id;
    });

    it('should retry failed webhook', async () => {
      const response = await fetch(`${BASE_URL}/api/webhook/retry/${failedWebhookId}`, {
        method: 'POST',
        headers: TestUtils.createHeaders()
      });

      expect(response.status).toBe(200);

      const result = await response.json();
      expect(result).toHaveProperty('success', true);
      expect(result).toHaveProperty('retryCount');
      expect(result.retryCount).toBeGreaterThan(2);
    });

    it('should reject retry for non-failed webhook', async () => {
      const prisma = TestDatabaseManager.getPrisma();
      const successfulWebhook = await prisma.webhookLog.create({
        data: TestUtils.generateWebhookData({
          status: 'PROCESSED'
        })
      });

      const response = await fetch(`${BASE_URL}/api/webhook/retry/${successfulWebhook.id}`, {
        method: 'POST',
        headers: TestUtils.createHeaders()
      });

      expect(response.status).toBe(400);

      const result = await response.json();
      expect(result.error).toContain('retry');
    });

    it('should reject retry if max retries exceeded', async () => {
      const prisma = TestDatabaseManager.getPrisma();
      const maxRetriedWebhook = await prisma.webhookLog.create({
        data: TestUtils.generateWebhookData({
          status: 'FAILED',
          retryCount: 10 // Max retries
        })
      });

      const response = await fetch(`${BASE_URL}/api/webhook/retry/${maxRetriedWebhook.id}`, {
        method: 'POST',
        headers: TestUtils.createHeaders()
      });

      expect(response.status).toBe(400);

      const result = await response.json();
      expect(result.error).toContain('maximum');
    });
  });

  describe('Webhook Performance', () => {
    it('should process webhook quickly', async () => {
      const webhookPayload = {
        executionId: 'exec-performance',
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: 'ลูกค้าทดสอบประสิทธิภาพ',
            lineUserId: TestUtils.randomLineUserId()
          },
          booking: {
            serviceType: 'บริการทดสอบ'
          }
        }
      };

      const { duration } = await TestUtils.measureTime(async () => {
        const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': 'test-api-key'
          },
          body: JSON.stringify(webhookPayload)
        });
        return response.json();
      });

      TestAssertions.assertPerformance(duration, 2000); // Should complete within 2 seconds
    });

    it('should handle concurrent webhook requests', async () => {
      const webhookRequests = Array.from({ length: 5 }, (_, i) => ({
        executionId: `exec-concurrent-${i}`,
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: `ลูกค้า ${i}`,
            lineUserId: TestUtils.randomLineUserId()
          },
          booking: {
            serviceType: 'บริการพร้อมกัน'
          }
        }
      }));

      const promises = webhookRequests.map(payload =>
        fetch(`${BASE_URL}/api/webhook/n8n`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': 'test-api-key'
          },
          body: JSON.stringify(payload)
        })
      );

      const responses = await Promise.all(promises);

      // All should succeed
      responses.forEach(response => {
        expect(response.status).toBe(200);
      });
    });
  });

  describe('Webhook Error Handling', () => {
    it('should handle malformed webhook payload', async () => {
      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: 'invalid json'
      });

      expect(response.status).toBe(400);

      const result = await response.json();
      expect(result).toHaveProperty('error');
    });

    it('should handle webhook with missing required fields', async () => {
      const incompletePayload = {
        executionId: 'exec-incomplete',
        data: {
          customer: {
            // Missing name
            lineUserId: TestUtils.randomLineUserId()
          },
          booking: {
            // Missing serviceType
            description: 'บริการไม่สมบูรณ์'
          }
        }
      };

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: JSON.stringify(incompletePayload)
      });

      expect(response.status).toBe(400);

      const result = await response.json();
      TestAssertions.assertValidationError(result);
    });

    it('should handle webhook processing failure gracefully', async () => {
      // This would test database failure scenarios
      // In a real implementation, you might mock database failures
      const webhookPayload = {
        executionId: 'exec-failure-test',
        workflowId: 'workflow-booking',
        data: {
          customer: {
            name: 'ลูกค้าทดสอบ failure',
            lineUserId: TestUtils.randomLineUserId()
          },
          booking: {
            serviceType: 'บริการทดสอบ failure'
          }
        }
      };

      const response = await fetch(`${BASE_URL}/api/webhook/n8n`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'test-api-key'
        },
        body: JSON.stringify(webhookPayload)
      });

      // Should either succeed or fail gracefully
      expect([200, 500]).toContain(response.status);

      if (response.status === 500) {
        const result = await response.json();
        expect(result).toHaveProperty('error');
      }
    });
  });
});