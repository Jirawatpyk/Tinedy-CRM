// Customer Database Unit Tests
// Generated by Database Agent (Alex)

import { describe, it, expect, beforeEach } from '@jest/globals';
import { TestDatabaseManager, TestUtils, TestAssertions } from '../../setup/test-config';
import { validateEntity } from '../../../lib/validation/schema-validator';
import { DataTypeValidator } from '../../../lib/validation/data-type-validator';

const prisma = TestDatabaseManager.getPrisma();

describe('Customer Database Operations', () => {
  beforeEach(async () => {
    await TestDatabaseManager.reset();
  });

  describe('Customer Creation', () => {
    it('should create customer with valid data', async () => {
      const customerData = TestUtils.generateCustomerData({
        name: 'สมชาย ใจดี',
        phone: '+66812345678',
        email: 'somchai@example.com'
      });

      const customer = await prisma.customer.create({
        data: customerData
      });

      expect(customer).toBeDefined();
      TestAssertions.assertCUID(customer.id);
      expect(customer.name).toBe(customerData.name);
      expect(customer.phone).toBe(customerData.phone);
      expect(customer.email).toBe(customerData.email);
      expect(customer.status).toBe('ACTIVE');
      TestAssertions.assertTimestamp(customer.createdAt);
      TestAssertions.assertTimestamp(customer.updatedAt);
    });

    it('should create customer with minimal required data', async () => {
      const customerData = {
        name: 'ลูกค้าขั้นต่ำ'
      };

      const customer = await prisma.customer.create({
        data: customerData
      });

      expect(customer).toBeDefined();
      expect(customer.name).toBe(customerData.name);
      expect(customer.phone).toBeNull();
      expect(customer.email).toBeNull();
      expect(customer.status).toBe('ACTIVE');
    });

    it('should create customer with LINE User ID', async () => {
      const lineUserId = TestUtils.randomLineUserId();
      const customerData = TestUtils.generateCustomerData({
        lineUserId
      });

      const customer = await prisma.customer.create({
        data: customerData
      });

      expect(customer.lineUserId).toBe(lineUserId);
      TestAssertions.assertLineUserId(customer.lineUserId!);
    });

    it('should enforce unique LINE User ID constraint', async () => {
      const lineUserId = TestUtils.randomLineUserId();
      const customerData1 = TestUtils.generateCustomerData({
        name: 'ลูกค้า 1',
        lineUserId
      });
      const customerData2 = TestUtils.generateCustomerData({
        name: 'ลูกค้า 2',
        lineUserId // Same LINE User ID
      });

      await prisma.customer.create({ data: customerData1 });

      await expect(
        prisma.customer.create({ data: customerData2 })
      ).rejects.toThrow();
    });

    it('should reject invalid phone number format', async () => {
      const customerData = TestUtils.generateCustomerData({
        phone: 'invalid-phone'
      });

      // Should be caught by application validation, not database
      const validation = await DataTypeValidator.validateEntity('customer', customerData);
      expect(validation.valid).toBe(false);
      expect(validation.errors).toContain(expect.stringContaining('phone'));
    });

    it('should reject invalid email format', async () => {
      const customerData = TestUtils.generateCustomerData({
        email: 'invalid-email'
      });

      const validation = await DataTypeValidator.validateEntity('customer', customerData);
      expect(validation.valid).toBe(false);
      expect(validation.errors).toContain(expect.stringContaining('email'));
    });
  });

  describe('Customer Retrieval', () => {
    it('should find customer by ID', async () => {
      const customerData = TestUtils.generateCustomerData();
      const createdCustomer = await prisma.customer.create({
        data: customerData
      });

      const foundCustomer = await prisma.customer.findUnique({
        where: { id: createdCustomer.id }
      });

      expect(foundCustomer).toBeDefined();
      expect(foundCustomer!.id).toBe(createdCustomer.id);
      expect(foundCustomer!.name).toBe(customerData.name);
    });

    it('should find customer by LINE User ID', async () => {
      const lineUserId = TestUtils.randomLineUserId();
      const customerData = TestUtils.generateCustomerData({ lineUserId });
      await prisma.customer.create({ data: customerData });

      const foundCustomer = await prisma.customer.findUnique({
        where: { lineUserId }
      });

      expect(foundCustomer).toBeDefined();
      expect(foundCustomer!.lineUserId).toBe(lineUserId);
    });

    it('should find customers by status', async () => {
      // Create customers with different statuses
      await Promise.all([
        prisma.customer.create({
          data: TestUtils.generateCustomerData({ name: 'Active 1', status: 'ACTIVE' })
        }),
        prisma.customer.create({
          data: TestUtils.generateCustomerData({ name: 'Active 2', status: 'ACTIVE' })
        }),
        prisma.customer.create({
          data: TestUtils.generateCustomerData({ name: 'Inactive 1', status: 'INACTIVE' })
        })
      ]);

      const activeCustomers = await prisma.customer.findMany({
        where: { status: 'ACTIVE' }
      });

      expect(activeCustomers).toHaveLength(2);
      activeCustomers.forEach(customer => {
        expect(customer.status).toBe('ACTIVE');
      });
    });

    it('should search customers by name', async () => {
      await Promise.all([
        prisma.customer.create({
          data: TestUtils.generateCustomerData({ name: 'สมชาย ใจดี' })
        }),
        prisma.customer.create({
          data: TestUtils.generateCustomerData({ name: 'สมหญิง ดีใจ' })
        }),
        prisma.customer.create({
          data: TestUtils.generateCustomerData({ name: 'อนันต์ มั่นคง' })
        })
      ]);

      const searchResults = await prisma.customer.findMany({
        where: {
          name: {
            contains: 'สม',
            mode: 'insensitive'
          }
        }
      });

      expect(searchResults).toHaveLength(2);
      searchResults.forEach(customer => {
        expect(customer.name).toContain('สม');
      });
    });
  });

  describe('Customer Updates', () => {
    it('should update customer information', async () => {
      const customerData = TestUtils.generateCustomerData();
      const customer = await prisma.customer.create({ data: customerData });

      const updatedData = {
        name: 'ชื่อใหม่',
        phone: '+66898765432',
        email: 'new@example.com'
      };

      const updatedCustomer = await prisma.customer.update({
        where: { id: customer.id },
        data: updatedData
      });

      expect(updatedCustomer.name).toBe(updatedData.name);
      expect(updatedCustomer.phone).toBe(updatedData.phone);
      expect(updatedCustomer.email).toBe(updatedData.email);
      expect(updatedCustomer.updatedAt.getTime()).toBeGreaterThan(
        customer.updatedAt.getTime()
      );
    });

    it('should update customer status', async () => {
      const customerData = TestUtils.generateCustomerData({ status: 'ACTIVE' });
      const customer = await prisma.customer.create({ data: customerData });

      const updatedCustomer = await prisma.customer.update({
        where: { id: customer.id },
        data: { status: 'INACTIVE' }
      });

      expect(updatedCustomer.status).toBe('INACTIVE');
    });

    it('should validate status transitions', async () => {
      const customerData = TestUtils.generateCustomerData({ status: 'ACTIVE' });

      // This should be validated at application level
      const validation = await DataTypeValidator.validateEnumTransition(
        'CustomerStatus',
        'ACTIVE',
        'BLOCKED'
      );

      expect(validation.valid).toBe(true);
    });
  });

  describe('Customer Deletion', () => {
    it('should delete customer without jobs', async () => {
      const customerData = TestUtils.generateCustomerData();
      const customer = await prisma.customer.create({ data: customerData });

      await prisma.customer.delete({
        where: { id: customer.id }
      });

      const deletedCustomer = await prisma.customer.findUnique({
        where: { id: customer.id }
      });

      expect(deletedCustomer).toBeNull();
    });

    it('should prevent deletion of customer with jobs', async () => {
      const customerData = TestUtils.generateCustomerData();
      const customer = await prisma.customer.create({ data: customerData });

      // Create a job for the customer
      await prisma.job.create({
        data: TestUtils.generateJobData(customer.id)
      });

      // Should fail due to foreign key constraint
      await expect(
        prisma.customer.delete({
          where: { id: customer.id }
        })
      ).rejects.toThrow();
    });
  });

  describe('Customer Relationships', () => {
    it('should include jobs in customer query', async () => {
      const customerData = TestUtils.generateCustomerData();
      const customer = await prisma.customer.create({ data: customerData });

      // Create jobs for the customer
      await Promise.all([
        prisma.job.create({
          data: TestUtils.generateJobData(customer.id, { serviceType: 'งาน 1' })
        }),
        prisma.job.create({
          data: TestUtils.generateJobData(customer.id, { serviceType: 'งาน 2' })
        })
      ]);

      const customerWithJobs = await prisma.customer.findUnique({
        where: { id: customer.id },
        include: { jobs: true }
      });

      expect(customerWithJobs).toBeDefined();
      expect(customerWithJobs!.jobs).toHaveLength(2);
      customerWithJobs!.jobs.forEach(job => {
        expect(job.customerId).toBe(customer.id);
      });
    });

    it('should count customer jobs', async () => {
      const customerData = TestUtils.generateCustomerData();
      const customer = await prisma.customer.create({ data: customerData });

      // Create multiple jobs
      await Promise.all(
        Array.from({ length: 5 }, () =>
          prisma.job.create({
            data: TestUtils.generateJobData(customer.id)
          })
        )
      );

      const jobCount = await prisma.job.count({
        where: { customerId: customer.id }
      });

      expect(jobCount).toBe(5);
    });
  });

  describe('Customer Validation', () => {
    it('should validate complete customer data', async () => {
      const customerData = TestUtils.generateCustomerData({
        name: 'สมชาย ใจดี',
        phone: '+66812345678',
        email: 'somchai@example.com',
        lineUserId: TestUtils.randomLineUserId()
      });

      const validation = validateEntity('customer', customerData);

      expect(validation.valid).toBe(true);
      expect(validation.data).toBeDefined();
    });

    it('should reject customer with invalid data', async () => {
      const customerData = {
        name: '', // Empty name
        phone: 'invalid-phone',
        email: 'invalid-email',
        lineUserId: 'invalid-line-id'
      };

      const validation = validateEntity('customer', customerData);

      expect(validation.valid).toBe(false);
      expect(validation.errors).toBeDefined();
      expect(validation.errors!.length).toBeGreaterThan(0);
    });

    it('should validate Thai name characters', async () => {
      const validNames = [
        'สมชาย ใจดี',
        'John Smith',
        'สมชาย Smith',
        'นาย A. Johnson'
      ];

      const invalidNames = [
        'สมชาย@gmail',
        'John#Smith',
        'สมชาย123',
        '<script>alert()</script>'
      ];

      for (const name of validNames) {
        const validation = await DataTypeValidator.validateDataType('thaiName', name);
        expect(validation.valid).toBe(true);
      }

      for (const name of invalidNames) {
        const validation = await DataTypeValidator.validateDataType('thaiName', name);
        expect(validation.valid).toBe(false);
      }
    });

    it('should validate Thai phone numbers', async () => {
      const validPhones = [
        '+66812345678',
        '+66898765432',
        '0812345678',
        '0898765432'
      ];

      const invalidPhones = [
        '+1234567890',
        '812345678',
        '+66123',
        'phone-number'
      ];

      for (const phone of validPhones) {
        const validation = await DataTypeValidator.validateDataType('thaiPhone', phone);
        expect(validation.valid).toBe(true);
      }

      for (const phone of invalidPhones) {
        const validation = await DataTypeValidator.validateDataType('thaiPhone', phone);
        expect(validation.valid).toBe(false);
      }
    });
  });

  describe('Customer Performance', () => {
    it('should create customer quickly', async () => {
      const customerData = TestUtils.generateCustomerData();

      const { duration } = await TestUtils.measureTime(async () => {
        return prisma.customer.create({ data: customerData });
      });

      TestAssertions.assertPerformance(duration, 500); // Should complete within 500ms
    });

    it('should search customers efficiently', async () => {
      // Create multiple customers for search testing
      await Promise.all(
        Array.from({ length: 50 }, (_, i) =>
          prisma.customer.create({
            data: TestUtils.generateCustomerData({
              name: `ลูกค้า ${i + 1}`,
              email: `customer${i + 1}@test.com`
            })
          })
        )
      );

      const { duration } = await TestUtils.measureTime(async () => {
        return prisma.customer.findMany({
          where: {
            name: { contains: 'ลูกค้า' }
          },
          take: 10
        });
      });

      TestAssertions.assertPerformance(duration, 300); // Should complete within 300ms
    });
  });
});