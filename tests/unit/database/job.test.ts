// Job Database Unit Tests
// Generated by Database Agent (Alex)

import { describe, it, expect, beforeEach } from '@jest/globals';
import { TestDatabaseManager, TestUtils, TestAssertions } from '../../setup/test-config';
import { DataTypeValidator } from '../../../lib/validation/data-type-validator';
import { BusinessValidation } from '../../../lib/validation/schema-validator';

const prisma = TestDatabaseManager.getPrisma();

describe('Job Database Operations', () => {
  let testCustomer: any;
  let testUser: any;

  beforeEach(async () => {
    await TestDatabaseManager.reset();

    // Create test customer and user for jobs
    testCustomer = await prisma.customer.create({
      data: TestUtils.generateCustomerData({ name: 'ลูกค้าทดสอบงาน' })
    });

    testUser = await prisma.user.create({
      data: TestUtils.generateUserData({ name: 'พนักงานทดสอบ', role: 'OPERATIONS' })
    });
  });

  describe('Job Creation', () => {
    it('should create job with required data', async () => {
      const jobData = TestUtils.generateJobData(testCustomer.id, {
        serviceType: 'บริการทำความสะอาด',
        description: 'ทำความสะอาดออฟฟิศ'
      });

      const job = await prisma.job.create({
        data: jobData
      });

      expect(job).toBeDefined();
      TestAssertions.assertCUID(job.id);
      expect(job.customerId).toBe(testCustomer.id);
      expect(job.serviceType).toBe(jobData.serviceType);
      expect(job.description).toBe(jobData.description);
      expect(job.status).toBe('NEW');
      expect(job.priority).toBe('MEDIUM');
      TestAssertions.assertTimestamp(job.createdAt);
    });

    it('should create job with assignment', async () => {
      const jobData = TestUtils.generateJobData(testCustomer.id, {
        assignedToId: testUser.id,
        status: 'IN_PROGRESS'
      });

      const job = await prisma.job.create({
        data: jobData
      });

      expect(job.assignedToId).toBe(testUser.id);
      expect(job.status).toBe('IN_PROGRESS');
    });

    it('should create job with scheduled date', async () => {
      const scheduledAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // Tomorrow
      const jobData = TestUtils.generateJobData(testCustomer.id, {
        scheduledAt
      });

      const job = await prisma.job.create({
        data: jobData
      });

      expect(job.scheduledAt).toEqual(scheduledAt);
    });

    it('should enforce foreign key constraint for customer', async () => {
      const jobData = TestUtils.generateJobData('invalid-customer-id');

      await expect(
        prisma.job.create({ data: jobData })
      ).rejects.toThrow();
    });

    it('should enforce foreign key constraint for assigned user', async () => {
      const jobData = TestUtils.generateJobData(testCustomer.id, {
        assignedToId: 'invalid-user-id'
      });

      await expect(
        prisma.job.create({ data: jobData })
      ).rejects.toThrow();
    });
  });

  describe('Job Status Management', () => {
    let testJob: any;

    beforeEach(async () => {
      testJob = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id)
      });
    });

    it('should update job status from NEW to IN_PROGRESS', async () => {
      const updatedJob = await prisma.job.update({
        where: { id: testJob.id },
        data: { status: 'IN_PROGRESS' }
      });

      expect(updatedJob.status).toBe('IN_PROGRESS');
    });

    it('should update job status to COMPLETED with completion date', async () => {
      const completedAt = new Date();
      const updatedJob = await prisma.job.update({
        where: { id: testJob.id },
        data: {
          status: 'COMPLETED',
          completedAt
        }
      });

      expect(updatedJob.status).toBe('COMPLETED');
      expect(updatedJob.completedAt).toEqual(completedAt);
    });

    it('should validate status transitions', async () => {
      // Valid transition: NEW -> IN_PROGRESS
      const validTransition = await DataTypeValidator.validateEnumTransition(
        'JobStatus',
        'NEW',
        'IN_PROGRESS'
      );
      expect(validTransition.valid).toBe(true);

      // Invalid transition: NEW -> COMPLETED
      const invalidTransition = await DataTypeValidator.validateEnumTransition(
        'JobStatus',
        'NEW',
        'COMPLETED'
      );
      expect(invalidTransition.valid).toBe(false);
    });

    it('should validate completion requirements', async () => {
      const jobData = {
        status: 'COMPLETED',
        completedAt: null // Missing completion date
      };

      const validation = await DataTypeValidator.validateBusinessLogic('job', jobData);
      expect(validation.valid).toBe(false);
      expect(validation.violations).toContain('Completed jobs must have a completion date');
    });
  });

  describe('Job Assignment', () => {
    it('should assign job to user', async () => {
      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id)
      });

      const updatedJob = await prisma.job.update({
        where: { id: job.id },
        data: {
          assignedToId: testUser.id,
          status: 'IN_PROGRESS'
        }
      });

      expect(updatedJob.assignedToId).toBe(testUser.id);
    });

    it('should validate job assignment rules', async () => {
      // Create training user
      const trainingUser = await prisma.user.create({
        data: TestUtils.generateUserData({ role: 'TRAINING' })
      });

      // Test assignment validation
      const validation = await BusinessValidation.validateJobAssignment(
        'test-job-id',
        trainingUser.id
      );

      // This would normally check business rules in a real implementation
      expect(validation).toBeDefined();
    });

    it('should unassign job', async () => {
      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id, {
          assignedToId: testUser.id,
          status: 'IN_PROGRESS'
        })
      });

      const unassignedJob = await prisma.job.update({
        where: { id: job.id },
        data: {
          assignedToId: null,
          status: 'NEW'
        }
      });

      expect(unassignedJob.assignedToId).toBeNull();
      expect(unassignedJob.status).toBe('NEW');
    });
  });

  describe('Job Retrieval and Filtering', () => {
    beforeEach(async () => {
      // Create jobs with different statuses and priorities
      await Promise.all([
        prisma.job.create({
          data: TestUtils.generateJobData(testCustomer.id, {
            serviceType: 'บริการทำความสะอาด',
            status: 'NEW',
            priority: 'HIGH'
          })
        }),
        prisma.job.create({
          data: TestUtils.generateJobData(testCustomer.id, {
            serviceType: 'บริการฝึกอบรม',
            status: 'IN_PROGRESS',
            priority: 'MEDIUM',
            assignedToId: testUser.id
          })
        }),
        prisma.job.create({
          data: TestUtils.generateJobData(testCustomer.id, {
            serviceType: 'บริการตรวจสอบคุณภาพ',
            status: 'COMPLETED',
            priority: 'LOW',
            completedAt: new Date()
          })
        })
      ]);
    });

    it('should find jobs by status', async () => {
      const newJobs = await prisma.job.findMany({
        where: { status: 'NEW' }
      });

      expect(newJobs).toHaveLength(1);
      expect(newJobs[0].status).toBe('NEW');
    });

    it('should find jobs by priority', async () => {
      const highPriorityJobs = await prisma.job.findMany({
        where: { priority: 'HIGH' }
      });

      expect(highPriorityJobs).toHaveLength(1);
      expect(highPriorityJobs[0].priority).toBe('HIGH');
    });

    it('should find assigned jobs', async () => {
      const assignedJobs = await prisma.job.findMany({
        where: {
          assignedToId: { not: null }
        }
      });

      expect(assignedJobs).toHaveLength(1);
      expect(assignedJobs[0].assignedToId).toBe(testUser.id);
    });

    it('should find jobs by service type', async () => {
      const cleaningJobs = await prisma.job.findMany({
        where: {
          serviceType: { contains: 'ทำความสะอาด' }
        }
      });

      expect(cleaningJobs).toHaveLength(1);
      expect(cleaningJobs[0].serviceType).toContain('ทำความสะอาด');
    });

    it('should find jobs within date range', async () => {
      const today = new Date();
      const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);

      const jobsToday = await prisma.job.findMany({
        where: {
          createdAt: {
            gte: today,
            lt: tomorrow
          }
        }
      });

      expect(jobsToday.length).toBeGreaterThan(0);
    });
  });

  describe('Job Relationships', () => {
    it('should include customer information', async () => {
      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id)
      });

      const jobWithCustomer = await prisma.job.findUnique({
        where: { id: job.id },
        include: { customer: true }
      });

      expect(jobWithCustomer).toBeDefined();
      expect(jobWithCustomer!.customer).toBeDefined();
      expect(jobWithCustomer!.customer.id).toBe(testCustomer.id);
      expect(jobWithCustomer!.customer.name).toBe(testCustomer.name);
    });

    it('should include assigned user information', async () => {
      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id, {
          assignedToId: testUser.id
        })
      });

      const jobWithUser = await prisma.job.findUnique({
        where: { id: job.id },
        include: { assignedTo: true }
      });

      expect(jobWithUser).toBeDefined();
      expect(jobWithUser!.assignedTo).toBeDefined();
      expect(jobWithUser!.assignedTo!.id).toBe(testUser.id);
    });

    it('should include quality checks', async () => {
      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id)
      });

      // Create quality checklist
      const checklist = await prisma.qualityChecklist.create({
        data: {
          name: 'Test Checklist',
          items: [{ id: '1', text: 'Test item', required: true }],
          isActive: true
        }
      });

      // Create quality check
      await prisma.qualityCheck.create({
        data: {
          jobId: job.id,
          checklistId: checklist.id,
          status: 'PENDING'
        }
      });

      const jobWithQC = await prisma.job.findUnique({
        where: { id: job.id },
        include: { qualityChecks: true }
      });

      expect(jobWithQC!.qualityChecks).toHaveLength(1);
      expect(jobWithQC!.qualityChecks[0].status).toBe('PENDING');
    });
  });

  describe('Job Priority Management', () => {
    it('should order jobs by priority and creation date', async () => {
      const now = new Date();

      // Create jobs with different priorities
      const jobs = await Promise.all([
        prisma.job.create({
          data: TestUtils.generateJobData(testCustomer.id, {
            priority: 'LOW',
            createdAt: new Date(now.getTime() - 3000)
          })
        }),
        prisma.job.create({
          data: TestUtils.generateJobData(testCustomer.id, {
            priority: 'HIGH',
            createdAt: new Date(now.getTime() - 2000)
          })
        }),
        prisma.job.create({
          data: TestUtils.generateJobData(testCustomer.id, {
            priority: 'URGENT',
            createdAt: new Date(now.getTime() - 1000)
          })
        })
      ]);

      const orderedJobs = await prisma.job.findMany({
        orderBy: [
          { priority: 'desc' },
          { createdAt: 'asc' }
        ]
      });

      expect(orderedJobs[0].priority).toBe('URGENT');
      expect(orderedJobs[1].priority).toBe('HIGH');
      expect(orderedJobs[2].priority).toBe('LOW');
    });

    it('should update job priority', async () => {
      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id, {
          priority: 'LOW'
        })
      });

      const updatedJob = await prisma.job.update({
        where: { id: job.id },
        data: { priority: 'URGENT' }
      });

      expect(updatedJob.priority).toBe('URGENT');
    });
  });

  describe('Job Validation', () => {
    it('should validate complete job data', async () => {
      const jobData = TestUtils.generateJobData(testCustomer.id, {
        serviceType: 'บริการทดสอบ',
        description: 'รายละเอียดงานทดสอบ',
        priority: 'HIGH'
      });

      const validation = await DataTypeValidator.validateEntity('job', jobData);

      expect(validation.valid).toBe(true);
      expect(validation.data).toBeDefined();
    });

    it('should reject job with missing required fields', async () => {
      const jobData = {
        // Missing customerId and serviceType
        description: 'งานไม่สมบูรณ์'
      };

      const validation = await DataTypeValidator.validateEntity('job', jobData);

      expect(validation.valid).toBe(false);
      expect(validation.errors).toBeDefined();
    });

    it('should validate service type format', async () => {
      const validServiceTypes = [
        'บริการทำความสะอาด',
        'บริการฝึกอบรม',
        'General Cleaning Service',
        'Training Service (Basic)'
      ];

      const invalidServiceTypes = [
        '', // Empty
        'Service<script>alert()</script>', // XSS attempt
        'Service@#$%^&*()', // Invalid characters
      ];

      for (const serviceType of validServiceTypes) {
        const validation = await DataTypeValidator.validateDataType('serviceType', serviceType);
        expect(validation.valid).toBe(true);
      }

      for (const serviceType of invalidServiceTypes) {
        const validation = await DataTypeValidator.validateDataType('serviceType', serviceType);
        expect(validation.valid).toBe(false);
      }
    });
  });

  describe('Job Performance', () => {
    it('should create job quickly', async () => {
      const jobData = TestUtils.generateJobData(testCustomer.id);

      const { duration } = await TestUtils.measureTime(async () => {
        return prisma.job.create({ data: jobData });
      });

      TestAssertions.assertPerformance(duration, 500);
    });

    it('should query jobs efficiently', async () => {
      // Create multiple jobs
      await Promise.all(
        Array.from({ length: 20 }, () =>
          prisma.job.create({
            data: TestUtils.generateJobData(testCustomer.id)
          })
        )
      );

      const { duration } = await TestUtils.measureTime(async () => {
        return prisma.job.findMany({
          where: { customerId: testCustomer.id },
          include: {
            customer: true,
            assignedTo: true
          },
          take: 10
        });
      });

      TestAssertions.assertPerformance(duration, 400);
    });
  });

  describe('Job Webhook Integration', () => {
    it('should store webhook data in job', async () => {
      const webhookData = {
        n8nExecutionId: 'exec-123',
        sourceWorkflow: 'line-booking',
        originalPayload: {
          customer: 'ลูกค้าจาก LINE',
          service: 'บริการทำความสะอาด'
        }
      };

      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id, {
          n8nWorkflowId: 'workflow-123',
          webhookData
        })
      });

      expect(job.webhookData).toEqual(webhookData);
      expect(job.n8nWorkflowId).toBe('workflow-123');
    });

    it('should handle null webhook data', async () => {
      const job = await prisma.job.create({
        data: TestUtils.generateJobData(testCustomer.id, {
          webhookData: null
        })
      });

      expect(job.webhookData).toBeNull();
    });
  });
});