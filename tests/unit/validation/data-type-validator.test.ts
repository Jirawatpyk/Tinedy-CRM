// Data Type Validator Unit Tests
// Generated by Database Agent (Alex)

import { describe, it, expect, beforeEach } from '@jest/globals';
import { TestUtils, TestAssertions } from '../../setup/test-config';

// Mock the data type validator functions since they may not be implemented yet
const mockValidateDataType = jest.fn();
const mockValidateEntity = jest.fn();
const mockValidateEnumTransition = jest.fn();
const mockValidateBusinessLogic = jest.fn();

jest.mock('../../../lib/validation/data-type-validator', () => ({
  DataTypeValidator: {
    validateDataType: mockValidateDataType,
    validateEntity: mockValidateEntity,
    validateEnumTransition: mockValidateEnumTransition,
    validateBusinessLogic: mockValidateBusinessLogic
  }
}));

describe('Data Type Validator Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();

    // Set up default mock responses
    mockValidateDataType.mockResolvedValue({
      valid: true,
      sanitizedValue: null,
      errors: []
    });

    mockValidateEntity.mockResolvedValue({
      valid: true,
      data: {},
      errors: []
    });

    mockValidateEnumTransition.mockResolvedValue({
      valid: true,
      errors: []
    });

    mockValidateBusinessLogic.mockResolvedValue({
      valid: true,
      violations: []
    });
  });

  describe('Thai Name Validation', () => {
    it('should validate Thai names', async () => {
      const validNames = [
        'สมชาย ใจดี',
        'นางสาวสมหญิง ดีใจ',
        'นายอนันต์ มั่นคง',
        'ศรีสุดา วงศ์ใหญ่'
      ];

      for (const name of validNames) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: name,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiName', name);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(name);
      }
    });

    it('should validate mixed Thai-English names', async () => {
      const validMixedNames = [
        'สมชาย Smith',
        'John ใจดี',
        'นาย A. Johnson',
        'Ms. สุดา วงศ์'
      ];

      for (const name of validMixedNames) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: name,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiName', name);

        expect(result.valid).toBe(true);
      }
    });

    it('should reject names with invalid characters', async () => {
      const invalidNames = [
        'สมชาย@gmail',
        'John#Smith',
        'สมชาย123',
        '<script>alert()</script>',
        'สมชาย<>',
        'นาย&อนันต์'
      ];

      for (const name of invalidNames) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: ['Name contains invalid characters']
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiName', name);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Name contains invalid characters');
      }
    });

    it('should reject empty or too short names', async () => {
      const invalidNames = ['', ' ', 'a'];

      for (const name of invalidNames) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: ['Name must be at least 2 characters long']
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiName', name);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Name must be at least 2 characters long');
      }
    });
  });

  describe('Thai Phone Number Validation', () => {
    it('should validate Thai phone numbers with +66 prefix', async () => {
      const validPhones = [
        '+66812345678',
        '+66898765432',
        '+66623456789',
        '+66887654321'
      ];

      for (const phone of validPhones) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: phone,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiPhone', phone);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(phone);
      }
    });

    it('should validate Thai phone numbers with 0 prefix', async () => {
      const validPhones = [
        '0812345678',
        '0898765432',
        '0623456789',
        '0887654321'
      ];

      for (const phone of validPhones) {
        // Expect sanitized to +66 format
        const expectedSanitized = phone.replace(/^0/, '+66');

        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: expectedSanitized,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiPhone', phone);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(expectedSanitized);
      }
    });

    it('should reject invalid Thai phone numbers', async () => {
      const invalidPhones = [
        '+1234567890', // US number
        '812345678',   // Missing prefix
        '+66123',      // Too short
        '+661234567890', // Too long
        'phone-number', // Text
        '+66000000000', // Invalid area code
        ''             // Empty
      ];

      for (const phone of invalidPhones) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: ['Phone number must be a valid Thai phone number']
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiPhone', phone);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Phone number must be a valid Thai phone number');
      }
    });

    it('should validate mobile phone number patterns', async () => {
      const validMobilePatterns = [
        '+66812345678', // AIS
        '+66898765432', // True Move
        '+66623456789', // DTAC
        '+66887654321'  // CAT
      ];

      for (const phone of validMobilePatterns) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: phone,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiMobile', phone);

        expect(result.valid).toBe(true);
      }
    });
  });

  describe('LINE User ID Validation', () => {
    it('should validate LINE User ID format', async () => {
      const validLineUserIds = [
        'U' + 'a'.repeat(32),
        'U' + '1'.repeat(32),
        'U' + 'f'.repeat(32),
        TestUtils.randomLineUserId()
      ];

      for (const lineUserId of validLineUserIds) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: lineUserId,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('lineUserId', lineUserId);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(lineUserId);
      }
    });

    it('should reject invalid LINE User ID formats', async () => {
      const invalidLineUserIds = [
        'U123',                    // Too short
        'u' + 'a'.repeat(32),     // Lowercase U
        'A' + 'a'.repeat(32),     // Wrong prefix
        'U' + 'g'.repeat(32),     // Invalid hex
        'U' + 'a'.repeat(31),     // Too short hex
        'U' + 'a'.repeat(33),     // Too long hex
        '',                        // Empty
        'invalid-line-id'          // Wrong format
      ];

      for (const lineUserId of invalidLineUserIds) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: ['LINE User ID must be in format U followed by 32 hex characters']
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('lineUserId', lineUserId);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain('LINE User ID must be in format U followed by 32 hex characters');
      }
    });
  });

  describe('Email Validation', () => {
    it('should validate email addresses', async () => {
      const validEmails = [
        'test@example.com',
        'user.name@domain.co.th',
        'สมชาย@บริษัท.ไทย',
        'admin+test@company.org',
        'firstname.lastname@subdomain.example.com'
      ];

      for (const email of validEmails) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: email.toLowerCase(),
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('email', email);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(email.toLowerCase());
      }
    });

    it('should reject invalid email addresses', async () => {
      const invalidEmails = [
        'invalid-email',
        '@example.com',
        'test@',
        'test..test@example.com',
        'test@example',
        '',
        'test@.com',
        'test@example.'
      ];

      for (const email of invalidEmails) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: ['Email must be a valid email address']
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('email', email);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Email must be a valid email address');
      }
    });
  });

  describe('Service Type Validation', () => {
    it('should validate service type format', async () => {
      const validServiceTypes = [
        'บริการทำความสะอาด',
        'บริการฝึกอบรม',
        'บริการตรวจสอบคุณภาพ',
        'General Cleaning Service',
        'Training Service (Basic)',
        'Quality Control & Inspection'
      ];

      for (const serviceType of validServiceTypes) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: serviceType,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('serviceType', serviceType);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(serviceType);
      }
    });

    it('should reject invalid service types', async () => {
      const invalidServiceTypes = [
        '',                                    // Empty
        'Service<script>alert()</script>',     // XSS attempt
        'Service@#$%^&*()',                   // Special characters
        'a'.repeat(256),                      // Too long
        'Service\nwith\nnewlines'             // Newlines
      ];

      for (const serviceType of invalidServiceTypes) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: ['Service type contains invalid characters or format']
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('serviceType', serviceType);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Service type contains invalid characters or format');
      }
    });
  });

  describe('Enum Validation', () => {
    it('should validate job status enum values', async () => {
      const validStatuses = ['NEW', 'IN_PROGRESS', 'ON_HOLD', 'COMPLETED', 'CANCELLED'];

      for (const status of validStatuses) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: status,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('jobStatus', status);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(status);
      }
    });

    it('should validate job priority enum values', async () => {
      const validPriorities = ['LOW', 'MEDIUM', 'HIGH', 'URGENT'];

      for (const priority of validPriorities) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: priority,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('jobPriority', priority);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(priority);
      }
    });

    it('should validate customer status enum values', async () => {
      const validStatuses = ['ACTIVE', 'INACTIVE', 'BLOCKED'];

      for (const status of validStatuses) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: status,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('customerStatus', status);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(status);
      }
    });

    it('should validate user role enum values', async () => {
      const validRoles = ['ADMIN', 'OPERATIONS', 'QC_MANAGER', 'TRAINING'];

      for (const role of validRoles) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: true,
          sanitizedValue: role,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('userRole', role);

        expect(result.valid).toBe(true);
        expect(result.sanitizedValue).toBe(role);
      }
    });

    it('should reject invalid enum values', async () => {
      const testCases = [
        { type: 'jobStatus', value: 'INVALID_STATUS' },
        { type: 'jobPriority', value: 'SUPER_HIGH' },
        { type: 'customerStatus', value: 'DELETED' },
        { type: 'userRole', value: 'SUPER_ADMIN' }
      ];

      for (const testCase of testCases) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: [`${testCase.value} is not a valid ${testCase.type}`]
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType(testCase.type, testCase.value);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain(`${testCase.value} is not a valid ${testCase.type}`);
      }
    });
  });

  describe('Enum Transitions', () => {
    it('should validate valid job status transitions', async () => {
      const validTransitions = [
        { from: 'NEW', to: 'IN_PROGRESS' },
        { from: 'IN_PROGRESS', to: 'COMPLETED' },
        { from: 'IN_PROGRESS', to: 'ON_HOLD' },
        { from: 'ON_HOLD', to: 'IN_PROGRESS' },
        { from: 'NEW', to: 'CANCELLED' },
        { from: 'IN_PROGRESS', to: 'CANCELLED' }
      ];

      for (const transition of validTransitions) {
        mockValidateEnumTransition.mockResolvedValueOnce({
          valid: true,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateEnumTransition('JobStatus', transition.from, transition.to);

        expect(result.valid).toBe(true);
      }
    });

    it('should reject invalid job status transitions', async () => {
      const invalidTransitions = [
        { from: 'NEW', to: 'COMPLETED' },      // Skip IN_PROGRESS
        { from: 'COMPLETED', to: 'IN_PROGRESS' }, // Can't reopen completed
        { from: 'CANCELLED', to: 'IN_PROGRESS' }, // Can't reopen cancelled
        { from: 'COMPLETED', to: 'CANCELLED' }    // Can't cancel completed
      ];

      for (const transition of invalidTransitions) {
        mockValidateEnumTransition.mockResolvedValueOnce({
          valid: false,
          errors: [`Cannot transition from ${transition.from} to ${transition.to}`]
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateEnumTransition('JobStatus', transition.from, transition.to);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain(`Cannot transition from ${transition.from} to ${transition.to}`);
      }
    });

    it('should validate customer status transitions', async () => {
      const validTransitions = [
        { from: 'ACTIVE', to: 'INACTIVE' },
        { from: 'ACTIVE', to: 'BLOCKED' },
        { from: 'INACTIVE', to: 'ACTIVE' },
        { from: 'BLOCKED', to: 'ACTIVE' }
      ];

      for (const transition of validTransitions) {
        mockValidateEnumTransition.mockResolvedValueOnce({
          valid: true,
          errors: []
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateEnumTransition('CustomerStatus', transition.from, transition.to);

        expect(result.valid).toBe(true);
      }
    });
  });

  describe('Entity Validation', () => {
    it('should validate complete customer entity', async () => {
      const customerData = TestUtils.generateCustomerData({
        name: 'สมชาย ใจดี',
        phone: '+66812345678',
        email: 'somchai@example.com',
        lineUserId: TestUtils.randomLineUserId()
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: true,
        data: customerData,
        errors: []
      });

      const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
      const result = await DataTypeValidator.validateEntity('customer', customerData);

      expect(result.valid).toBe(true);
      expect(result.data).toEqual(customerData);
    });

    it('should validate complete job entity', async () => {
      const jobData = TestUtils.generateJobData('customer-id', {
        serviceType: 'บริการทำความสะอาด',
        description: 'ทำความสะอาดออฟฟิศ',
        priority: 'HIGH',
        status: 'NEW'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: true,
        data: jobData,
        errors: []
      });

      const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
      const result = await DataTypeValidator.validateEntity('job', jobData);

      expect(result.valid).toBe(true);
      expect(result.data).toEqual(jobData);
    });

    it('should collect multiple validation errors', async () => {
      const invalidData = {
        name: '',                    // Invalid name
        phone: 'invalid-phone',      // Invalid phone
        email: 'invalid-email',      // Invalid email
        lineUserId: 'invalid-line'   // Invalid LINE ID
      };

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: [
          'Name is required',
          'Phone number must be a valid Thai phone number',
          'Email must be a valid email address',
          'LINE User ID must be in format U followed by 32 hex characters'
        ]
      });

      const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
      const result = await DataTypeValidator.validateEntity('customer', invalidData);

      expect(result.valid).toBe(false);
      expect(result.errors).toHaveLength(4);
      expect(result.data).toBeNull();
    });
  });

  describe('Performance', () => {
    it('should validate data types quickly', async () => {
      const testData = TestUtils.generateCustomerData();

      mockValidateDataType.mockResolvedValue({
        valid: true,
        sanitizedValue: 'test',
        errors: []
      });

      const { duration } = await TestUtils.measureTime(async () => {
        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');

        await Promise.all([
          DataTypeValidator.validateDataType('thaiName', testData.name),
          DataTypeValidator.validateDataType('thaiPhone', testData.phone),
          DataTypeValidator.validateDataType('email', testData.email),
          DataTypeValidator.validateDataType('lineUserId', testData.lineUserId)
        ]);
      });

      TestAssertions.assertPerformance(duration, 100); // Should complete within 100ms
    });

    it('should handle bulk validation efficiently', async () => {
      const testCustomers = Array.from({ length: 20 }, () => TestUtils.generateCustomerData());

      mockValidateEntity.mockResolvedValue({
        valid: true,
        data: {},
        errors: []
      });

      const { duration } = await TestUtils.measureTime(async () => {
        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');

        return Promise.all(
          testCustomers.map(customer =>
            DataTypeValidator.validateEntity('customer', customer)
          )
        );
      });

      TestAssertions.assertPerformance(duration, 400); // Should complete within 400ms
    });
  });

  describe('Error Handling', () => {
    it('should handle validation service errors', async () => {
      mockValidateDataType.mockRejectedValueOnce(new Error('Validation service down'));

      const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');

      await expect(
        DataTypeValidator.validateDataType('thaiName', 'สมชาย')
      ).rejects.toThrow('Validation service down');
    });

    it('should handle malformed input gracefully', async () => {
      const malformedInputs = [null, undefined, {}, [], 123];

      for (const input of malformedInputs) {
        mockValidateDataType.mockResolvedValueOnce({
          valid: false,
          sanitizedValue: null,
          errors: ['Input must be a string']
        });

        const { DataTypeValidator } = await import('../../../lib/validation/data-type-validator');
        const result = await DataTypeValidator.validateDataType('thaiName', input as any);

        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Input must be a string');
      }
    });
  });
});