// Database Constraints Validation Unit Tests
// Generated by Database Agent (Alex)

import { describe, it, expect, beforeEach } from '@jest/globals';
import { TestDatabaseManager, TestUtils, TestAssertions } from '../../setup/test-config';

// Mock the database constraints validator since it may not be implemented yet
const mockValidateConstraints = jest.fn();
const mockCheckForeignKeys = jest.fn();
const mockCheckUniqueConstraints = jest.fn();
const mockValidateDataIntegrity = jest.fn();

jest.mock('../../../lib/validation/database-constraints', () => ({
  DatabaseConstraintsValidator: {
    validateConstraints: mockValidateConstraints,
    checkForeignKeys: mockCheckForeignKeys,
    checkUniqueConstraints: mockCheckUniqueConstraints,
    validateDataIntegrity: mockValidateDataIntegrity
  }
}));

const prisma = TestDatabaseManager.getPrisma();

describe('Database Constraints Validation Tests', () => {
  beforeEach(async () => {
    await TestDatabaseManager.reset();
    jest.clearAllMocks();

    // Set up default mock responses
    mockValidateConstraints.mockResolvedValue({
      valid: true,
      violations: []
    });

    mockCheckForeignKeys.mockResolvedValue({
      valid: true,
      missingReferences: []
    });

    mockCheckUniqueConstraints.mockResolvedValue({
      valid: true,
      duplicates: []
    });

    mockValidateDataIntegrity.mockResolvedValue({
      valid: true,
      issues: []
    });
  });

  describe('Foreign Key Constraints', () => {
    it('should validate job references existing customer', async () => {
      // Create test customer
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData({ name: 'ลูกค้าทดสอบ' })
      });

      const jobData = TestUtils.generateJobData(customer.id);

      mockCheckForeignKeys.mockResolvedValueOnce({
        valid: true,
        missingReferences: []
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkForeignKeys('job', jobData);

      expect(result.valid).toBe(true);
      expect(result.missingReferences).toHaveLength(0);
    });

    it('should detect job referencing non-existent customer', async () => {
      const jobData = TestUtils.generateJobData('non-existent-customer-id');

      mockCheckForeignKeys.mockResolvedValueOnce({
        valid: false,
        missingReferences: [
          {
            field: 'customerId',
            value: 'non-existent-customer-id',
            referencedTable: 'customer'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkForeignKeys('job', jobData);

      expect(result.valid).toBe(false);
      expect(result.missingReferences).toHaveLength(1);
      expect(result.missingReferences[0].field).toBe('customerId');
    });

    it('should validate job assignment references existing user', async () => {
      // Create test customer and user
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      const user = await prisma.user.create({
        data: TestUtils.generateUserData({ role: 'OPERATIONS' })
      });

      const jobData = TestUtils.generateJobData(customer.id, {
        assignedToId: user.id
      });

      mockCheckForeignKeys.mockResolvedValueOnce({
        valid: true,
        missingReferences: []
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkForeignKeys('job', jobData);

      expect(result.valid).toBe(true);
    });

    it('should detect job assignment referencing non-existent user', async () => {
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      const jobData = TestUtils.generateJobData(customer.id, {
        assignedToId: 'non-existent-user-id'
      });

      mockCheckForeignKeys.mockResolvedValueOnce({
        valid: false,
        missingReferences: [
          {
            field: 'assignedToId',
            value: 'non-existent-user-id',
            referencedTable: 'user'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkForeignKeys('job', jobData);

      expect(result.valid).toBe(false);
      expect(result.missingReferences[0].field).toBe('assignedToId');
    });

    it('should validate quality check references existing job and checklist', async () => {
      // Create test data
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      const job = await prisma.job.create({
        data: TestUtils.generateJobData(customer.id)
      });

      const checklist = await prisma.qualityChecklist.create({
        data: {
          name: 'Test Checklist',
          items: [{ id: '1', text: 'Test item', required: true }],
          isActive: true
        }
      });

      const qualityCheckData = {
        jobId: job.id,
        checklistId: checklist.id,
        status: 'PENDING'
      };

      mockCheckForeignKeys.mockResolvedValueOnce({
        valid: true,
        missingReferences: []
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkForeignKeys('qualityCheck', qualityCheckData);

      expect(result.valid).toBe(true);
    });
  });

  describe('Unique Constraints', () => {
    it('should validate unique LINE User ID for customers', async () => {
      const lineUserId = TestUtils.randomLineUserId();

      // First customer with LINE User ID
      await prisma.customer.create({
        data: TestUtils.generateCustomerData({
          name: 'ลูกค้า 1',
          lineUserId
        })
      });

      // Try to create second customer with same LINE User ID
      const duplicateCustomerData = TestUtils.generateCustomerData({
        name: 'ลูกค้า 2',
        lineUserId // Same LINE User ID
      });

      mockCheckUniqueConstraints.mockResolvedValueOnce({
        valid: false,
        duplicates: [
          {
            field: 'lineUserId',
            value: lineUserId,
            existingId: 'existing-customer-id'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkUniqueConstraints('customer', duplicateCustomerData);

      expect(result.valid).toBe(false);
      expect(result.duplicates).toHaveLength(1);
      expect(result.duplicates[0].field).toBe('lineUserId');
    });

    it('should validate unique email for users', async () => {
      const email = 'test@example.com';

      // First user with email
      await prisma.user.create({
        data: TestUtils.generateUserData({
          name: 'User 1',
          email
        })
      });

      // Try to create second user with same email
      const duplicateUserData = TestUtils.generateUserData({
        name: 'User 2',
        email // Same email
      });

      mockCheckUniqueConstraints.mockResolvedValueOnce({
        valid: false,
        duplicates: [
          {
            field: 'email',
            value: email,
            existingId: 'existing-user-id'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkUniqueConstraints('user', duplicateUserData);

      expect(result.valid).toBe(false);
      expect(result.duplicates[0].field).toBe('email');
    });

    it('should allow multiple customers without LINE User ID', async () => {
      // Create customers without LINE User ID
      const customer1Data = TestUtils.generateCustomerData({
        name: 'ลูกค้า 1',
        lineUserId: null
      });

      const customer2Data = TestUtils.generateCustomerData({
        name: 'ลูกค้า 2',
        lineUserId: null
      });

      await prisma.customer.create({ data: customer1Data });

      mockCheckUniqueConstraints.mockResolvedValueOnce({
        valid: true,
        duplicates: []
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkUniqueConstraints('customer', customer2Data);

      expect(result.valid).toBe(true);
    });

    it('should validate unique webhook execution IDs', async () => {
      const executionId = 'exec-12345';

      // First webhook with execution ID
      await prisma.webhookLog.create({
        data: TestUtils.generateWebhookData({
          executionId
        })
      });

      // Try to create second webhook with same execution ID
      const duplicateWebhookData = TestUtils.generateWebhookData({
        executionId // Same execution ID
      });

      mockCheckUniqueConstraints.mockResolvedValueOnce({
        valid: false,
        duplicates: [
          {
            field: 'executionId',
            value: executionId,
            existingId: 'existing-webhook-id'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.checkUniqueConstraints('webhookLog', duplicateWebhookData);

      expect(result.valid).toBe(false);
      expect(result.duplicates[0].field).toBe('executionId');
    });
  });

  describe('Data Integrity Constraints', () => {
    it('should validate customer cannot be deleted with active jobs', async () => {
      // Create customer with jobs
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      await prisma.job.create({
        data: TestUtils.generateJobData(customer.id, { status: 'IN_PROGRESS' })
      });

      mockValidateDataIntegrity.mockResolvedValueOnce({
        valid: false,
        issues: [
          {
            type: 'constraint_violation',
            message: 'Customer has active jobs and cannot be deleted',
            affectedEntity: 'customer',
            affectedId: customer.id
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateDataIntegrity('customer', customer.id, 'delete');

      expect(result.valid).toBe(false);
      expect(result.issues).toHaveLength(1);
      expect(result.issues[0].message).toContain('active jobs');
    });

    it('should allow customer deletion without jobs', async () => {
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      mockValidateDataIntegrity.mockResolvedValueOnce({
        valid: true,
        issues: []
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateDataIntegrity('customer', customer.id, 'delete');

      expect(result.valid).toBe(true);
      expect(result.issues).toHaveLength(0);
    });

    it('should validate job completion requires completion date', async () => {
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      const jobData = {
        id: 'job-123',
        status: 'COMPLETED',
        completedAt: null // Missing completion date
      };

      mockValidateDataIntegrity.mockResolvedValueOnce({
        valid: false,
        issues: [
          {
            type: 'business_rule_violation',
            message: 'Completed jobs must have a completion date',
            affectedEntity: 'job',
            affectedId: 'job-123'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateDataIntegrity('job', jobData.id, 'update', jobData);

      expect(result.valid).toBe(false);
      expect(result.issues[0].message).toContain('completion date');
    });

    it('should validate user deactivation with active job assignments', async () => {
      // Create user with active assignments
      const user = await prisma.user.create({
        data: TestUtils.generateUserData({ role: 'OPERATIONS' })
      });

      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      await prisma.job.create({
        data: TestUtils.generateJobData(customer.id, {
          assignedToId: user.id,
          status: 'IN_PROGRESS'
        })
      });

      mockValidateDataIntegrity.mockResolvedValueOnce({
        valid: false,
        issues: [
          {
            type: 'constraint_violation',
            message: 'User has active job assignments and cannot be deactivated',
            affectedEntity: 'user',
            affectedId: user.id
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateDataIntegrity('user', user.id, 'update', { isActive: false });

      expect(result.valid).toBe(false);
      expect(result.issues[0].message).toContain('active job assignments');
    });

    it('should validate quality checklist deactivation with pending checks', async () => {
      // Create checklist with pending quality checks
      const checklist = await prisma.qualityChecklist.create({
        data: {
          name: 'Test Checklist',
          items: [{ id: '1', text: 'Test item', required: true }],
          isActive: true
        }
      });

      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      const job = await prisma.job.create({
        data: TestUtils.generateJobData(customer.id)
      });

      await prisma.qualityCheck.create({
        data: {
          jobId: job.id,
          checklistId: checklist.id,
          status: 'PENDING'
        }
      });

      mockValidateDataIntegrity.mockResolvedValueOnce({
        valid: false,
        issues: [
          {
            type: 'constraint_violation',
            message: 'Checklist has pending quality checks and cannot be deactivated',
            affectedEntity: 'qualityChecklist',
            affectedId: checklist.id
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateDataIntegrity('qualityChecklist', checklist.id, 'update', { isActive: false });

      expect(result.valid).toBe(false);
      expect(result.issues[0].message).toContain('pending quality checks');
    });
  });

  describe('Comprehensive Constraint Validation', () => {
    it('should validate all constraints for customer creation', async () => {
      const customerData = TestUtils.generateCustomerData({
        name: 'สมชาย ใจดี',
        lineUserId: TestUtils.randomLineUserId()
      });

      mockValidateConstraints.mockResolvedValueOnce({
        valid: true,
        violations: []
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateConstraints('customer', customerData, 'create');

      expect(result.valid).toBe(true);
      expect(result.violations).toHaveLength(0);
    });

    it('should validate all constraints for job creation', async () => {
      const customer = await prisma.customer.create({
        data: TestUtils.generateCustomerData()
      });

      const user = await prisma.user.create({
        data: TestUtils.generateUserData({ role: 'OPERATIONS' })
      });

      const jobData = TestUtils.generateJobData(customer.id, {
        assignedToId: user.id
      });

      mockValidateConstraints.mockResolvedValueOnce({
        valid: true,
        violations: []
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateConstraints('job', jobData, 'create');

      expect(result.valid).toBe(true);
    });

    it('should collect multiple constraint violations', async () => {
      const invalidJobData = {
        customerId: 'non-existent-customer',   // Foreign key violation
        assignedToId: 'non-existent-user',     // Foreign key violation
        serviceType: '',                        // Invalid data
        status: 'INVALID_STATUS'               // Invalid enum
      };

      mockValidateConstraints.mockResolvedValueOnce({
        valid: false,
        violations: [
          {
            type: 'foreign_key',
            field: 'customerId',
            message: 'Referenced customer does not exist'
          },
          {
            type: 'foreign_key',
            field: 'assignedToId',
            message: 'Referenced user does not exist'
          },
          {
            type: 'data_validation',
            field: 'serviceType',
            message: 'Service type cannot be empty'
          },
          {
            type: 'enum_validation',
            field: 'status',
            message: 'Invalid job status'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateConstraints('job', invalidJobData, 'create');

      expect(result.valid).toBe(false);
      expect(result.violations).toHaveLength(4);
    });
  });

  describe('Performance', () => {
    it('should validate constraints quickly', async () => {
      const customerData = TestUtils.generateCustomerData();

      mockValidateConstraints.mockResolvedValue({
        valid: true,
        violations: []
      });

      const { duration } = await TestUtils.measureTime(async () => {
        const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
        return DatabaseConstraintsValidator.validateConstraints('customer', customerData, 'create');
      });

      TestAssertions.assertPerformance(duration, 200); // Should complete within 200ms
    });

    it('should handle bulk constraint validation efficiently', async () => {
      const customers = Array.from({ length: 10 }, () => TestUtils.generateCustomerData());

      mockValidateConstraints.mockResolvedValue({
        valid: true,
        violations: []
      });

      const { duration } = await TestUtils.measureTime(async () => {
        const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');

        return Promise.all(
          customers.map(customer =>
            DatabaseConstraintsValidator.validateConstraints('customer', customer, 'create')
          )
        );
      });

      TestAssertions.assertPerformance(duration, 500); // Should complete within 500ms
    });
  });

  describe('Error Handling', () => {
    it('should handle database connection errors', async () => {
      mockValidateConstraints.mockRejectedValueOnce(new Error('Database connection failed'));

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');

      await expect(
        DatabaseConstraintsValidator.validateConstraints('customer', {}, 'create')
      ).rejects.toThrow('Database connection failed');
    });

    it('should handle malformed constraint data', async () => {
      const malformedData = { invalid: 'data structure' };

      mockValidateConstraints.mockResolvedValueOnce({
        valid: false,
        violations: [
          {
            type: 'data_structure',
            message: 'Invalid data structure for constraint validation'
          }
        ]
      });

      const { DatabaseConstraintsValidator } = await import('../../../lib/validation/database-constraints');
      const result = await DatabaseConstraintsValidator.validateConstraints('customer', malformedData, 'create');

      expect(result.valid).toBe(false);
      expect(result.violations[0].message).toContain('Invalid data structure');
    });
  });
});