// Schema Validator Unit Tests
// Generated by Database Agent (Alex)

import { describe, it, expect, beforeEach } from '@jest/globals';
import { TestUtils, TestAssertions } from '../../setup/test-config';

// Mock the schema validator functions since they may not be implemented yet
const mockValidateEntity = jest.fn();
const mockValidateBusinessLogic = jest.fn();
const mockValidateDataIntegrity = jest.fn();

jest.mock('../../../lib/validation/schema-validator', () => ({
  validateEntity: mockValidateEntity,
  BusinessValidation: {
    validateJobAssignment: jest.fn(),
    validateCustomerStatusTransition: jest.fn(),
    validateJobStatusTransition: jest.fn(),
    validateWorkflowTrigger: jest.fn()
  }
}));

describe('Schema Validator Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();

    // Set up default mock responses
    mockValidateEntity.mockResolvedValue({
      valid: true,
      data: {},
      errors: []
    });

    mockValidateBusinessLogic.mockResolvedValue({
      valid: true,
      violations: []
    });

    mockValidateDataIntegrity.mockResolvedValue({
      valid: true,
      issues: []
    });
  });

  describe('Customer Validation', () => {
    it('should validate complete customer data', async () => {
      const customerData = TestUtils.generateCustomerData({
        name: 'สมชาย ใจดี',
        phone: '+66812345678',
        email: 'somchai@example.com',
        lineUserId: TestUtils.randomLineUserId()
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: true,
        data: customerData,
        errors: []
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('customer', customerData);

      expect(result.valid).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.errors).toHaveLength(0);
      expect(mockValidateEntity).toHaveBeenCalledWith('customer', customerData);
    });

    it('should reject customer with invalid name', async () => {
      const customerData = {
        name: '', // Empty name
        phone: '+66812345678',
        email: 'test@example.com'
      };

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Name is required', 'Name must be at least 1 character']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('customer', customerData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Name is required');
    });

    it('should reject customer with invalid phone number', async () => {
      const customerData = TestUtils.generateCustomerData({
        phone: 'invalid-phone'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Phone number must be in Thai format (+66 or 0)']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('customer', customerData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Phone number must be in Thai format (+66 or 0)');
    });

    it('should reject customer with invalid email', async () => {
      const customerData = TestUtils.generateCustomerData({
        email: 'invalid-email'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Email must be a valid email address']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('customer', customerData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Email must be a valid email address');
    });

    it('should reject customer with invalid LINE User ID', async () => {
      const customerData = TestUtils.generateCustomerData({
        lineUserId: 'invalid-line-id'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['LINE User ID must start with U followed by 32 hex characters']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('customer', customerData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('LINE User ID must start with U followed by 32 hex characters');
    });

    it('should validate customer status transitions', async () => {
      const mockBusinessValidation = jest.fn().mockResolvedValue({
        valid: true,
        violations: []
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        BusinessValidation: {
          validateCustomerStatusTransition: mockBusinessValidation
        }
      }));

      const { BusinessValidation } = await import('../../../lib/validation/schema-validator');
      const result = await BusinessValidation.validateCustomerStatusTransition('ACTIVE', 'INACTIVE');

      expect(result.valid).toBe(true);
      expect(mockBusinessValidation).toHaveBeenCalledWith('ACTIVE', 'INACTIVE');
    });
  });

  describe('Job Validation', () => {
    it('should validate complete job data', async () => {
      const jobData = TestUtils.generateJobData('customer-id', {
        serviceType: 'บริการทำความสะอาด',
        description: 'ทำความสะอาดออฟฟิศ',
        priority: 'HIGH'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: true,
        data: jobData,
        errors: []
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('job', jobData);

      expect(result.valid).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should reject job with missing required fields', async () => {
      const jobData = {
        description: 'งานไม่สมบูรณ์'
        // Missing customerId and serviceType
      };

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Customer ID is required', 'Service type is required']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('job', jobData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Customer ID is required');
      expect(result.errors).toContain('Service type is required');
    });

    it('should validate job status transitions', async () => {
      const mockBusinessValidation = jest.fn().mockResolvedValue({
        valid: true,
        violations: []
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        BusinessValidation: {
          validateJobStatusTransition: mockBusinessValidation
        }
      }));

      const { BusinessValidation } = await import('../../../lib/validation/schema-validator');
      const result = await BusinessValidation.validateJobStatusTransition('NEW', 'IN_PROGRESS');

      expect(result.valid).toBe(true);
      expect(mockBusinessValidation).toHaveBeenCalledWith('NEW', 'IN_PROGRESS');
    });

    it('should reject invalid job status transition', async () => {
      const mockBusinessValidation = jest.fn().mockResolvedValue({
        valid: false,
        violations: ['Cannot transition directly from NEW to COMPLETED']
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        BusinessValidation: {
          validateJobStatusTransition: mockBusinessValidation
        }
      }));

      const { BusinessValidation } = await import('../../../lib/validation/schema-validator');
      const result = await BusinessValidation.validateJobStatusTransition('NEW', 'COMPLETED');

      expect(result.valid).toBe(false);
      expect(result.violations).toContain('Cannot transition directly from NEW to COMPLETED');
    });

    it('should validate job assignment rules', async () => {
      const mockBusinessValidation = jest.fn().mockResolvedValue({
        valid: true,
        violations: []
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        BusinessValidation: {
          validateJobAssignment: mockBusinessValidation
        }
      }));

      const { BusinessValidation } = await import('../../../lib/validation/schema-validator');
      const result = await BusinessValidation.validateJobAssignment('job-id', 'user-id');

      expect(result.valid).toBe(true);
      expect(mockBusinessValidation).toHaveBeenCalledWith('job-id', 'user-id');
    });
  });

  describe('User Validation', () => {
    it('should validate complete user data', async () => {
      const userData = TestUtils.generateUserData({
        name: 'สมชาย พนักงาน',
        email: 'employee@test.com',
        role: 'OPERATIONS'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: true,
        data: userData,
        errors: []
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('user', userData);

      expect(result.valid).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should reject user with invalid email', async () => {
      const userData = TestUtils.generateUserData({
        email: 'invalid-email'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Email must be a valid email address']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('user', userData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Email must be a valid email address');
    });

    it('should reject user with invalid role', async () => {
      const userData = TestUtils.generateUserData({
        role: 'INVALID_ROLE'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Role must be one of: ADMIN, OPERATIONS, QC_MANAGER, TRAINING']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('user', userData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Role must be one of: ADMIN, OPERATIONS, QC_MANAGER, TRAINING');
    });
  });

  describe('Webhook Validation', () => {
    it('should validate N8N webhook payload', async () => {
      const webhookData = TestUtils.generateWebhookData({
        source: 'N8N',
        workflowId: 'workflow-123',
        payload: {
          customer: {
            name: 'ลูกค้าจาก LINE',
            lineUserId: TestUtils.randomLineUserId()
          },
          booking: {
            serviceType: 'บริการทำความสะอาด'
          }
        }
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: true,
        data: webhookData,
        errors: []
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('webhook', webhookData);

      expect(result.valid).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should reject webhook with invalid source', async () => {
      const webhookData = TestUtils.generateWebhookData({
        source: 'UNKNOWN_SOURCE'
      });

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Source must be one of: N8N, LINE_OA, MANUAL']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('webhook', webhookData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Source must be one of: N8N, LINE_OA, MANUAL');
    });

    it('should validate workflow trigger conditions', async () => {
      const mockBusinessValidation = jest.fn().mockResolvedValue({
        valid: true,
        violations: []
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        BusinessValidation: {
          validateWorkflowTrigger: mockBusinessValidation
        }
      }));

      const triggerData = {
        workflowId: 'booking-workflow',
        triggerType: 'line_message',
        conditions: {
          messageType: 'booking_request'
        }
      };

      const { BusinessValidation } = await import('../../../lib/validation/schema-validator');
      const result = await BusinessValidation.validateWorkflowTrigger(triggerData);

      expect(result.valid).toBe(true);
      expect(mockBusinessValidation).toHaveBeenCalledWith(triggerData);
    });
  });

  describe('Business Logic Validation', () => {
    it('should validate data integrity constraints', async () => {
      const testData = {
        entityType: 'job',
        entityId: 'job-123',
        constraints: ['customer_exists', 'no_duplicate_assignment']
      };

      mockValidateDataIntegrity.mockResolvedValueOnce({
        valid: true,
        issues: []
      });

      // Mock the function since it may not exist yet
      const mockDataIntegrity = jest.fn().mockResolvedValue({
        valid: true,
        issues: []
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        validateDataIntegrity: mockDataIntegrity
      }));

      const { validateDataIntegrity } = await import('../../../lib/validation/schema-validator');
      const result = await validateDataIntegrity(testData);

      expect(result.valid).toBe(true);
      expect(result.issues).toHaveLength(0);
    });

    it('should detect data integrity violations', async () => {
      const testData = {
        entityType: 'customer',
        entityId: 'customer-123',
        constraints: ['unique_line_user_id', 'no_orphaned_jobs']
      };

      const mockDataIntegrity = jest.fn().mockResolvedValue({
        valid: false,
        issues: ['Duplicate LINE User ID found', 'Customer has orphaned jobs']
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        validateDataIntegrity: mockDataIntegrity
      }));

      const { validateDataIntegrity } = await import('../../../lib/validation/schema-validator');
      const result = await validateDataIntegrity(testData);

      expect(result.valid).toBe(false);
      expect(result.issues).toContain('Duplicate LINE User ID found');
      expect(result.issues).toContain('Customer has orphaned jobs');
    });

    it('should validate completion requirements', async () => {
      const jobData = {
        status: 'COMPLETED',
        completedAt: null // Missing completion date
      };

      mockValidateBusinessLogic.mockResolvedValueOnce({
        valid: false,
        violations: ['Completed jobs must have a completion date']
      });

      // Mock the function
      const mockBusinessLogic = jest.fn().mockResolvedValue({
        valid: false,
        violations: ['Completed jobs must have a completion date']
      });

      jest.doMock('../../../lib/validation/schema-validator', () => ({
        validateBusinessLogic: mockBusinessLogic
      }));

      const { validateBusinessLogic } = await import('../../../lib/validation/schema-validator');
      const result = await validateBusinessLogic('job', jobData);

      expect(result.valid).toBe(false);
      expect(result.violations).toContain('Completed jobs must have a completion date');
    });
  });

  describe('Error Handling', () => {
    it('should handle validation errors gracefully', async () => {
      mockValidateEntity.mockRejectedValueOnce(new Error('Validation service unavailable'));

      const { validateEntity } = await import('../../../lib/validation/schema-validator');

      await expect(validateEntity('customer', {})).rejects.toThrow('Validation service unavailable');
    });

    it('should return structured error responses', async () => {
      const invalidData = {
        name: '',
        phone: 'invalid',
        email: 'invalid'
      };

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: [
          'Name is required',
          'Phone number must be in Thai format',
          'Email must be a valid email address'
        ]
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('customer', invalidData);

      expect(result.valid).toBe(false);
      expect(result.errors).toHaveLength(3);
      expect(result.data).toBeNull();
    });

    it('should handle missing required fields', async () => {
      const incompleteData = {}; // No required fields

      mockValidateEntity.mockResolvedValueOnce({
        valid: false,
        data: null,
        errors: ['Missing required fields: name, email']
      });

      const { validateEntity } = await import('../../../lib/validation/schema-validator');
      const result = await validateEntity('customer', incompleteData);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Missing required fields: name, email');
    });
  });

  describe('Performance', () => {
    it('should validate data within reasonable time', async () => {
      const customerData = TestUtils.generateCustomerData();

      mockValidateEntity.mockResolvedValueOnce({
        valid: true,
        data: customerData,
        errors: []
      });

      const { duration } = await TestUtils.measureTime(async () => {
        const { validateEntity } = await import('../../../lib/validation/schema-validator');
        return validateEntity('customer', customerData);
      });

      TestAssertions.assertPerformance(duration, 200); // Should complete within 200ms
    });

    it('should handle batch validation efficiently', async () => {
      const customers = Array.from({ length: 10 }, () => TestUtils.generateCustomerData());

      mockValidateEntity.mockResolvedValue({
        valid: true,
        data: {},
        errors: []
      });

      const { duration } = await TestUtils.measureTime(async () => {
        const { validateEntity } = await import('../../../lib/validation/schema-validator');
        return Promise.all(
          customers.map(customer => validateEntity('customer', customer))
        );
      });

      TestAssertions.assertPerformance(duration, 500); // Should complete within 500ms
    });
  });
});