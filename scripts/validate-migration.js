// Migration Validation Script for Tinedy CRM
// Generated by Database Agent (Alex)

const { PrismaClient } = require('@prisma/client');

class MigrationValidator {
  constructor() {
    this.prisma = new PrismaClient();
    this.errors = [];
    this.warnings = [];
  }

  async validateMigration() {
    console.log('🔍 Starting migration validation...\n');

    try {
      await this.validateSchemaStructure();
      await this.validateIndexes();
      await this.validateConstraints();
      await this.validateEnums();
      await this.testBasicOperations();

      this.printResults();
      return this.errors.length === 0;

    } catch (error) {
      console.error('❌ Validation failed with unexpected error:', error);
      return false;
    } finally {
      await this.prisma.$disconnect();
    }
  }

  async validateSchemaStructure() {
    console.log('📋 Validating schema structure...');

    const expectedTables = [
      'customers', 'jobs', 'users', 'quality_checks', 'quality_checklists',
      'training_workflows', 'webhook_logs', 'failed_webhooks', 'audit_logs'
    ];

    // Check if all tables exist
    const tables = await this.prisma.$queryRaw`
      SELECT table_name
      FROM information_schema.tables
      WHERE table_schema = 'public'
    `;

    const tableNames = tables.map(t => t.table_name);

    for (const table of expectedTables) {
      if (tableNames.includes(table)) {
        console.log(`  ✅ Table '${table}' exists`);
      } else {
        this.errors.push(`Missing table: ${table}`);
        console.log(`  ❌ Table '${table}' missing`);
      }
    }

    // Check for unexpected tables
    const unexpectedTables = tableNames.filter(name =>
      !expectedTables.includes(name) &&
      !name.startsWith('_') // Ignore Prisma internal tables
    );

    if (unexpectedTables.length > 0) {
      this.warnings.push(`Unexpected tables found: ${unexpectedTables.join(', ')}`);
    }
  }

  async validateIndexes() {
    console.log('\n📈 Validating indexes...');

    const criticalIndexes = [
      'customers_lineUserId_key',
      'customers_status_idx',
      'jobs_customerId_status_idx',
      'jobs_assignedToId_status_idx',
      'users_email_key',
      'webhook_logs_status_idx'
    ];

    const indexes = await this.prisma.$queryRaw`
      SELECT indexname
      FROM pg_indexes
      WHERE schemaname = 'public'
    `;

    const indexNames = indexes.map(i => i.indexname);

    for (const index of criticalIndexes) {
      if (indexNames.includes(index)) {
        console.log(`  ✅ Index '${index}' exists`);
      } else {
        this.errors.push(`Missing critical index: ${index}`);
        console.log(`  ❌ Index '${index}' missing`);
      }
    }

    console.log(`  📊 Total indexes created: ${indexNames.length}`);
  }

  async validateConstraints() {
    console.log('\n🔗 Validating foreign key constraints...');

    const expectedConstraints = [
      'jobs_customerId_fkey',
      'jobs_assignedToId_fkey',
      'quality_checks_jobId_fkey',
      'quality_checks_checklistId_fkey',
      'training_workflows_jobId_fkey',
      'webhook_logs_createdJobId_fkey'
    ];

    const constraints = await this.prisma.$queryRaw`
      SELECT constraint_name
      FROM information_schema.table_constraints
      WHERE constraint_type = 'FOREIGN KEY'
        AND table_schema = 'public'
    `;

    const constraintNames = constraints.map(c => c.constraint_name);

    for (const constraint of expectedConstraints) {
      if (constraintNames.includes(constraint)) {
        console.log(`  ✅ Constraint '${constraint}' exists`);
      } else {
        this.errors.push(`Missing foreign key constraint: ${constraint}`);
        console.log(`  ❌ Constraint '${constraint}' missing`);
      }
    }
  }

  async validateEnums() {
    console.log('\n🏷️ Validating enums...');

    const expectedEnums = [
      'CustomerStatus', 'JobStatus', 'Priority', 'UserRole',
      'QCStatus', 'TrainingStatus', 'WebhookStatus'
    ];

    const enums = await this.prisma.$queryRaw`
      SELECT typname
      FROM pg_type
      WHERE typtype = 'e'
    `;

    const enumNames = enums.map(e => e.typname);

    for (const enumName of expectedEnums) {
      if (enumNames.includes(enumName)) {
        console.log(`  ✅ Enum '${enumName}' exists`);
      } else {
        this.errors.push(`Missing enum: ${enumName}`);
        console.log(`  ❌ Enum '${enumName}' missing`);
      }
    }
  }

  async testBasicOperations() {
    console.log('\n🧪 Testing basic CRUD operations...');

    try {
      // Test Customer creation
      const customer = await this.prisma.customer.create({
        data: {
          id: 'test-customer-validation',
          name: 'Test Customer',
          lineUserId: 'test-line-user-validation',
          status: 'ACTIVE'
        }
      });
      console.log('  ✅ Customer creation successful');

      // Test User creation
      const user = await this.prisma.user.create({
        data: {
          id: 'test-user-validation',
          email: 'test-validation@example.com',
          name: 'Test User',
          role: 'OPERATIONS'
        }
      });
      console.log('  ✅ User creation successful');

      // Test Job creation with relationships
      const job = await this.prisma.job.create({
        data: {
          id: 'test-job-validation',
          customerId: customer.id,
          assignedToId: user.id,
          serviceType: 'Test Service',
          description: 'Validation test job',
          status: 'NEW',
          priority: 'MEDIUM'
        }
      });
      console.log('  ✅ Job creation with relationships successful');

      // Test Quality Checklist creation
      const checklist = await this.prisma.qualityChecklist.create({
        data: {
          id: 'test-checklist-validation',
          name: 'Test Checklist',
          items: [
            { item: 'Test item 1', required: true },
            { item: 'Test item 2', required: false }
          ]
        }
      });
      console.log('  ✅ Quality checklist creation successful');

      // Test Quality Check creation
      await this.prisma.qualityCheck.create({
        data: {
          id: 'test-qc-validation',
          jobId: job.id,
          checklistId: checklist.id,
          status: 'PENDING'
        }
      });
      console.log('  ✅ Quality check creation successful');

      // Test Training Workflow creation
      await this.prisma.trainingWorkflow.create({
        data: {
          id: 'test-training-validation',
          jobId: job.id,
          status: 'AWAITING_DOCUMENTS'
        }
      });
      console.log('  ✅ Training workflow creation successful');

      // Test Webhook Log creation
      await this.prisma.webhookLog.create({
        data: {
          id: 'test-webhook-validation',
          source: 'N8N',
          payload: { test: 'validation data' },
          status: 'RECEIVED',
          createdJobId: job.id
        }
      });
      console.log('  ✅ Webhook log creation successful');

      // Test Audit Log creation
      await this.prisma.auditLog.create({
        data: {
          id: 'test-audit-validation',
          entityType: 'Customer',
          entityId: customer.id,
          action: 'CREATE',
          newValues: { name: customer.name, status: customer.status }
        }
      });
      console.log('  ✅ Audit log creation successful');

      // Cleanup test data
      await this.cleanupTestData();
      console.log('  🧹 Test data cleanup completed');

    } catch (error) {
      this.errors.push(`CRUD operations failed: ${error.message}`);
      console.log(`  ❌ CRUD operations failed: ${error.message}`);
    }
  }

  async cleanupTestData() {
    // Delete in reverse dependency order
    await this.prisma.auditLog.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });

    await this.prisma.webhookLog.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });

    await this.prisma.trainingWorkflow.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });

    await this.prisma.qualityCheck.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });

    await this.prisma.qualityChecklist.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });

    await this.prisma.job.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });

    await this.prisma.user.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });

    await this.prisma.customer.deleteMany({
      where: { id: { startsWith: 'test-' } }
    });
  }

  printResults() {
    console.log('\n📊 Validation Results');
    console.log('='.repeat(50));

    if (this.errors.length === 0) {
      console.log('🎉 ALL VALIDATIONS PASSED!');
      console.log('✅ Migration is ready for deployment');
    } else {
      console.log('❌ VALIDATION FAILURES DETECTED:');
      this.errors.forEach((error, index) => {
        console.log(`  ${index + 1}. ${error}`);
      });
    }

    if (this.warnings.length > 0) {
      console.log('\n⚠️  WARNINGS:');
      this.warnings.forEach((warning, index) => {
        console.log(`  ${index + 1}. ${warning}`);
      });
    }

    console.log(`\n📈 Summary:`);
    console.log(`  - Errors: ${this.errors.length}`);
    console.log(`  - Warnings: ${this.warnings.length}`);
    console.log('='.repeat(50));
  }
}

// Run validation if script is executed directly
if (require.main === module) {
  const validator = new MigrationValidator();
  validator.validateMigration()
    .then(success => {
      process.exit(success ? 0 : 1);
    })
    .catch(error => {
      console.error('Validation script failed:', error);
      process.exit(1);
    });
}

module.exports = MigrationValidator;