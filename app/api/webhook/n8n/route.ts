// N8N Webhook API Endpoint for Tinedy CRM
// Generated by Database Agent (Alex)

import { NextRequest, NextResponse } from 'next/server';
import { headers } from 'next/headers';
import { webhookProcessor } from '@/lib/services/webhook-processor';
import { webhookAuthService, RATE_LIMITS } from '@/lib/services/webhook-auth';
import { N8NWebhookPayload, WebhookAuthHeaders } from '@/lib/types/webhook-types';

// Disable body parsing เพื่อให้เราสามารถ validate signature ได้
export const runtime = 'nodejs';

/**
 * POST /api/webhook/n8n
 * รับ webhook จาก N8N workflows
 */
export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    // 1. อ่าน headers และ body
    const headersList = headers();
    const webhookHeaders: WebhookAuthHeaders = {
      'x-n8n-signature': headersList.get('x-n8n-signature') || undefined,
      'x-timestamp': headersList.get('x-timestamp') || undefined,
      'x-workflow-id': headersList.get('x-workflow-id') || undefined,
      'authorization': headersList.get('authorization') || undefined,
    };

    const clientIP = request.ip ||
                    headersList.get('x-forwarded-for')?.split(',')[0] ||
                    headersList.get('x-real-ip') ||
                    'unknown';

    const userAgent = headersList.get('user-agent') || 'unknown';

    // 2. Rate limiting check
    const rateLimit = await webhookAuthService.checkRateLimit(
      clientIP,
      RATE_LIMITS.perIP.maxRequests,
      RATE_LIMITS.perIP.windowMs
    );

    if (!rateLimit.allowed) {
      await webhookAuthService.logSecurityEvent('rate_limit', {
        ip: clientIP,
        userAgent
      });

      return NextResponse.json(
        { error: 'Rate limit exceeded' },
        {
          status: 429,
          headers: {
            'X-RateLimit-Limit': RATE_LIMITS.perIP.maxRequests.toString(),
            'X-RateLimit-Remaining': rateLimit.remaining.toString(),
            'X-RateLimit-Reset': rateLimit.resetTime.toString(),
            'Retry-After': Math.ceil(RATE_LIMITS.perIP.windowMs / 1000).toString()
          }
        }
      );
    }

    // 3. อ่าน request body
    const body = await request.text();

    if (!body) {
      return NextResponse.json(
        { error: 'Empty request body' },
        { status: 400 }
      );
    }

    // 4. Webhook authentication
    const authResult = await webhookAuthService.validateWebhookAuth(body, webhookHeaders);

    if (!authResult.isValid) {
      await webhookAuthService.logSecurityEvent('auth_failure', {
        ip: clientIP,
        userAgent,
        error: authResult.error
      });

      return NextResponse.json(
        { error: 'Authentication failed', details: authResult.error },
        { status: 401 }
      );
    }

    // 5. Parse JSON payload
    let payload: N8NWebhookPayload;
    try {
      payload = JSON.parse(body);
    } catch (error) {
      return NextResponse.json(
        { error: 'Invalid JSON payload' },
        { status: 400 }
      );
    }

    // 6. เพิ่ม metadata
    payload.metadata = {
      ...payload.metadata,
      ipAddress: clientIP,
      userAgent,
    };

    // 7. Process webhook
    console.log(`Processing N8N webhook from workflow: ${payload.workflow?.id}`);

    const result = await webhookProcessor.processWebhook(payload);

    // 8. Log successful authentication
    if (result.success) {
      await webhookAuthService.logSecurityEvent('auth_success', {
        ip: clientIP,
        userAgent
      });
    }

    // 9. Prepare response
    const processingTime = Date.now() - startTime;
    const responseHeaders = {
      'X-Processing-Time': processingTime.toString(),
      'X-RateLimit-Remaining': rateLimit.remaining.toString(),
    };

    if (result.success) {
      console.log(`Webhook processed successfully in ${processingTime}ms:`, {
        customerId: result.data?.customerId,
        jobId: result.data?.jobId,
        status: result.data?.status
      });

      return NextResponse.json(
        {
          success: true,
          data: result.data,
          warnings: result.warnings,
          processingTime
        },
        {
          status: 200,
          headers: responseHeaders
        }
      );
    } else {
      console.error('Webhook processing failed:', result.error);

      // ส่ง error details เฉพาะใน development
      const errorResponse = process.env.NODE_ENV === 'development'
        ? result.error
        : { code: result.error?.code, message: result.error?.message };

      return NextResponse.json(
        {
          success: false,
          error: errorResponse,
          processingTime
        },
        {
          status: 500,
          headers: responseHeaders
        }
      );
    }

  } catch (error) {
    console.error('Webhook endpoint error:', error);

    const processingTime = Date.now() - startTime;

    // Log unexpected errors
    await webhookAuthService.logSecurityEvent('suspicious_activity', {
      ip: request.ip || 'unknown',
      userAgent: headers().get('user-agent') || 'unknown',
      error: (error as Error).message
    });

    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Internal server error'
        },
        processingTime
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/webhook/n8n
 * Health check endpoint
 */
export async function GET() {
  return NextResponse.json({
    status: 'healthy',
    service: 'n8n-webhook',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
}

/**
 * OPTIONS /api/webhook/n8n
 * CORS preflight
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, x-n8n-signature, x-timestamp, x-workflow-id',
    },
  });
}