// Tinedy CRM Seed Data Script
// Generated by Database Agent (Alex)

import { PrismaClient } from '@prisma/client';
import SeedDataGenerator, { SEED_DATA, SeedDataConfig } from '../lib/utils/seed-generators';

const prisma = new PrismaClient();

// Configuration ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö seed data
const SEED_CONFIG: SeedDataConfig = {
  users: 8,           // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
  customers: 15,      // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
  jobs: 25,           // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏á‡∏≤‡∏ô
  qualityChecklists: 5, // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô quality checklists
  cleanExisting: true   // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
};

async function main() {
  console.log('üå± Starting Tinedy CRM seed data generation...\n');

  try {
    // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤ (‡∏ñ‡πâ‡∏≤ config ‡πÄ‡∏õ‡∏¥‡∏î)
    if (SEED_CONFIG.cleanExisting) {
      await cleanExistingData();
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
    const users = await createUsers();
    const customers = await createCustomers();
    const qualityChecklists = await createQualityChecklists();
    const jobs = await createJobs(customers, users);
    const qualityChecks = await createQualityChecks(jobs, qualityChecklists);
    const trainingWorkflows = await createTrainingWorkflows(jobs);
    const webhookLogs = await createWebhookLogs(jobs);
    const auditLogs = await createAuditLogs(customers, jobs, users);

    // ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•
    printSummary({
      users: users.length,
      customers: customers.length,
      qualityChecklists: qualityChecklists.length,
      jobs: jobs.length,
      qualityChecks: qualityChecks.length,
      trainingWorkflows: trainingWorkflows.length,
      webhookLogs: webhookLogs.length,
      auditLogs: auditLogs.length
    });

  } catch (error) {
    console.error('‚ùå Error during seed data generation:', error);
    throw error;
  }
}

async function cleanExistingData() {
  console.log('üßπ Cleaning existing data...');

  // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° dependencies
  await prisma.auditLog.deleteMany();
  await prisma.webhookLog.deleteMany();
  await prisma.trainingWorkflow.deleteMany();
  await prisma.qualityCheck.deleteMany();
  await prisma.job.deleteMany();
  await prisma.qualityChecklist.deleteMany();
  await prisma.customer.deleteMany();
  await prisma.user.deleteMany();

  console.log('‚úÖ Existing data cleaned\n');
}

async function createUsers() {
  console.log('üë• Creating users...');

  const users = [];
  const roles = ['ADMIN', 'OPERATIONS', 'TRAINING', 'QC_MANAGER'] as const;

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á Admin user
  const adminUser = await prisma.user.create({
    data: {
      id: SeedDataGenerator.generateId('admin-'),
      email: 'admin@tinedy.com',
      name: '‡∏ú‡∏π‡πâ‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏∞‡∏ö‡∏ö',
      role: 'ADMIN',
      isActive: true
    }
  });
  users.push(adminUser);

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á users ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
  for (let i = 0; i < SEED_CONFIG.users - 1; i++) {
    const userName = SeedDataGenerator.randomFrom(SEED_DATA.userNames);
    const role = SeedDataGenerator.randomFrom(roles);

    const user = await prisma.user.create({
      data: {
        id: SeedDataGenerator.generateId('user-'),
        email: SeedDataGenerator.generateEmail(userName),
        name: userName,
        role: role,
        isActive: Math.random() > 0.1 // 90% active
      }
    });
    users.push(user);
  }

  console.log(`‚úÖ Created ${users.length} users`);
  return users;
}

async function createCustomers() {
  console.log('üè¢ Creating customers...');

  const customers = [];
  const statuses = ['ACTIVE', 'INACTIVE', 'BLOCKED'] as const;

  for (let i = 0; i < SEED_CONFIG.customers; i++) {
    const companyName = SeedDataGenerator.randomFrom(SEED_DATA.companyNames);
    const status = i < SEED_CONFIG.customers * 0.8 ? 'ACTIVE' :
                  SeedDataGenerator.randomFrom(statuses);

    const customer = await prisma.customer.create({
      data: {
        id: SeedDataGenerator.generateId('customer-'),
        lineUserId: SeedDataGenerator.generateLineUserId(),
        name: companyName,
        phone: SeedDataGenerator.generatePhoneNumber(),
        email: SeedDataGenerator.generateEmail(companyName),
        address: SeedDataGenerator.randomFrom(SEED_DATA.addresses),
        notes: Math.random() > 0.5 ?
               `‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤${status === 'ACTIVE' ? '‡∏î‡∏µ' : '‡∏õ‡∏±‡∏ç‡∏´‡∏≤'} - ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£${SeedDataGenerator.randomFrom(['‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°', '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á', '‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡πÄ‡∏®‡∏©'])}` :
               null,
        status: status
      }
    });
    customers.push(customer);
  }

  console.log(`‚úÖ Created ${customers.length} customers`);
  return customers;
}

async function createQualityChecklists() {
  console.log('üìã Creating quality checklists...');

  const checklists = [];
  const checklistTemplates = [
    {
      name: '‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ',
      description: '‡πÄ‡∏ä‡πá‡∏Ñ‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó',
      serviceType: 'general'
    },
    {
      name: '‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡∏£‡∏∞‡∏ö‡∏ö IT',
      description: '‡πÄ‡∏ä‡πá‡∏Ñ‡∏•‡∏¥‡∏™‡∏ï‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡∏î‡πâ‡∏≤‡∏ô IT',
      serviceType: '‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡∏£‡∏∞‡∏ö‡∏ö IT'
    },
    {
      name: '‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°',
      description: '‡πÄ‡∏ä‡πá‡∏Ñ‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô',
      serviceType: '‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô'
    },
    {
      name: '‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û',
      description: '‡πÄ‡∏ä‡πá‡∏Ñ‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û',
      serviceType: '‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û'
    },
    {
      name: '‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö',
      description: '‡πÄ‡∏ä‡πá‡∏Ñ‡∏•‡∏¥‡∏™‡∏ï‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡∏∞‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå',
      serviceType: '‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢'
    }
  ];

  for (const template of checklistTemplates) {
    const items = SeedDataGenerator.generateQualityCheckItems(template.serviceType);

    const checklist = await prisma.qualityChecklist.create({
      data: {
        id: SeedDataGenerator.generateId('checklist-'),
        name: template.name,
        description: template.description,
        items: items,
        isActive: true
      }
    });
    checklists.push(checklist);
  }

  console.log(`‚úÖ Created ${checklists.length} quality checklists`);
  return checklists;
}

async function createJobs(customers: any[], users: any[]) {
  console.log('üíº Creating jobs...');

  const jobs = [];
  const statuses = ['NEW', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'ON_HOLD'] as const;
  const priorities = ['LOW', 'MEDIUM', 'HIGH', 'URGENT'] as const;
  const operationsUsers = users.filter(u => ['OPERATIONS', 'ADMIN'].includes(u.role));

  for (let i = 0; i < SEED_CONFIG.jobs; i++) {
    const customer = SeedDataGenerator.randomFrom(customers.filter(c => c.status === 'ACTIVE'));
    const serviceType = SeedDataGenerator.randomFrom(SEED_DATA.serviceTypes);
    const status = SeedDataGenerator.randomFrom(statuses);
    const priority = SeedDataGenerator.randomFrom(priorities);
    const assignedTo = Math.random() > 0.3 ? SeedDataGenerator.randomFrom(operationsUsers) : null;

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏° status
    let scheduledAt = null;
    let completedAt = null;

    if (status !== 'NEW') {
      scheduledAt = SeedDataGenerator.pastDateRange(14); // ‡∏à‡∏≠‡∏á‡πÑ‡∏ß‡πâ‡πÉ‡∏ô 2 ‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤
    } else {
      scheduledAt = SeedDataGenerator.futureDateRange(14); // ‡∏à‡∏≠‡∏á‡πÑ‡∏ß‡πâ‡πÉ‡∏ô 2 ‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤
    }

    if (status === 'COMPLETED') {
      completedAt = SeedDataGenerator.pastDateRange(7); // ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÉ‡∏ô 1 ‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤
    }

    const job = await prisma.job.create({
      data: {
        id: SeedDataGenerator.generateId('job-'),
        customerId: customer.id,
        assignedToId: assignedTo?.id || null,
        serviceType: serviceType,
        description: SeedDataGenerator.generateJobDescription(serviceType, customer.name),
        status: status,
        priority: priority,
        scheduledAt: scheduledAt,
        completedAt: completedAt,
        n8nWorkflowId: `workflow-${Math.floor(Math.random() * 1000)}`,
        webhookData: null // ‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á‡πÉ‡∏ô webhook logs
      }
    });
    jobs.push(job);
  }

  console.log(`‚úÖ Created ${jobs.length} jobs`);
  return jobs;
}

async function createQualityChecks(jobs: any[], qualityChecklists: any[]) {
  console.log('‚úÖ Creating quality checks...');

  const qualityChecks = [];
  const qcStatuses = ['PENDING', 'IN_PROGRESS', 'PASSED', 'FAILED', 'NEEDS_REVIEW'] as const;
  const qcUsers = await prisma.user.findMany({
    where: { role: { in: ['QC_MANAGER', 'ADMIN'] } }
  });

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á quality check ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà IN_PROGRESS ‡∏´‡∏£‡∏∑‡∏≠ COMPLETED
  const eligibleJobs = jobs.filter(j => ['IN_PROGRESS', 'COMPLETED'].includes(j.status));

  for (const job of eligibleJobs) {
    // ‡∏´‡∏≤ checklist ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    let checklist = qualityChecklists.find(c =>
      c.name.includes(job.serviceType) ||
      c.description?.includes(job.serviceType)
    );

    if (!checklist) {
      checklist = qualityChecklists.find(c => c.name.includes('‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ'));
    }

    const qcStatus = job.status === 'COMPLETED' ?
                    SeedDataGenerator.randomFrom(['PASSED', 'FAILED', 'NEEDS_REVIEW']) :
                    SeedDataGenerator.randomFrom(['PENDING', 'IN_PROGRESS']);

    const completedBy = qcStatus === 'PENDING' ? null :
                       SeedDataGenerator.randomFrom(qcUsers)?.id;

    const completedAt = completedBy ? SeedDataGenerator.pastDateRange(3) : null;

    const notes = qcStatus === 'FAILED' ?
                  '‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏ö‡∏Å‡∏û‡∏£‡πà‡∏≠‡∏á‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£ ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á' :
                  qcStatus === 'PASSED' ?
                  '‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢' :
                  qcStatus === 'NEEDS_REVIEW' ?
                  '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ó‡∏ö‡∏ó‡∏ß‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°' :
                  null;

    const qualityCheck = await prisma.qualityCheck.create({
      data: {
        id: SeedDataGenerator.generateId('qc-'),
        jobId: job.id,
        checklistId: checklist.id,
        status: qcStatus,
        completedBy: completedBy,
        completedAt: completedAt,
        notes: notes
      }
    });
    qualityChecks.push(qualityCheck);
  }

  console.log(`‚úÖ Created ${qualityChecks.length} quality checks`);
  return qualityChecks;
}

async function createTrainingWorkflows(jobs: any[]) {
  console.log('üéì Creating training workflows...');

  const trainingWorkflows = [];
  const trainingStatuses = [
    'AWAITING_DOCUMENTS', 'DOCUMENTS_RECEIVED',
    'TRAINING_IN_PROGRESS', 'TRAINING_COMPLETED', 'COMPLETED'
  ] as const;

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á training workflow ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°
  const trainingJobs = jobs.filter(j => j.serviceType.includes('‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°'));

  for (const job of trainingJobs) {
    const status = job.status === 'COMPLETED' ?
                  SeedDataGenerator.randomFrom(['TRAINING_COMPLETED', 'COMPLETED']) :
                  job.status === 'IN_PROGRESS' ?
                  SeedDataGenerator.randomFrom(['DOCUMENTS_RECEIVED', 'TRAINING_IN_PROGRESS']) :
                  'AWAITING_DOCUMENTS';

    const documentsReceived = !['AWAITING_DOCUMENTS'].includes(status);
    const trainingCompleted = ['TRAINING_COMPLETED', 'COMPLETED'].includes(status);

    const notes = status === 'COMPLETED' ?
                  '‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢ ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏î‡∏µ‡∏°‡∏≤‡∏Å' :
                  status === 'TRAINING_IN_PROGRESS' ?
                  '‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏° ‡∏Ñ‡∏≤‡∏î‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à‡πÉ‡∏ô‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏´‡∏ô‡πâ‡∏≤' :
                  status === 'DOCUMENTS_RECEIVED' ?
                  '‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢ ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏≠‡∏ö‡∏£‡∏°' :
                  null;

    const trainingWorkflow = await prisma.trainingWorkflow.create({
      data: {
        id: SeedDataGenerator.generateId('training-'),
        jobId: job.id,
        status: status,
        documentsReceived: documentsReceived,
        trainingCompleted: trainingCompleted,
        notes: notes
      }
    });
    trainingWorkflows.push(trainingWorkflow);
  }

  console.log(`‚úÖ Created ${trainingWorkflows.length} training workflows`);
  return trainingWorkflows;
}

async function createWebhookLogs(jobs: any[]) {
  console.log('üì° Creating webhook logs...');

  const webhookLogs = [];
  const webhookStatuses = ['RECEIVED', 'PROCESSING', 'PROCESSED', 'FAILED', 'RETRY_NEEDED'] as const;

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á webhook log ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å N8N
  for (const job of jobs) {
    const customer = await prisma.customer.findUnique({
      where: { id: job.customerId }
    });

    if (!customer) continue;

    const status = Math.random() > 0.1 ? 'PROCESSED' :
                  SeedDataGenerator.randomFrom(['FAILED', 'RETRY_NEEDED']);

    const processedAt = status === 'PROCESSED' ?
                       SeedDataGenerator.pastDateRange(1) : null;

    const errorMessage = status === 'FAILED' ?
                        'Customer creation failed due to invalid LINE user ID' :
                        status === 'RETRY_NEEDED' ?
                        'Database connection timeout - scheduled for retry' :
                        null;

    const retryCount = ['FAILED', 'RETRY_NEEDED'].includes(status) ?
                      Math.floor(Math.random() * 3) : 0;

    const payload = SeedDataGenerator.generateWebhookPayload(customer, job);

    const webhookLog = await prisma.webhookLog.create({
      data: {
        id: SeedDataGenerator.generateId('webhook-'),
        source: 'N8N',
        workflowId: job.n8nWorkflowId,
        executionId: `exec-${Math.floor(Math.random() * 10000)}`,
        payload: payload,
        status: status,
        processedAt: processedAt,
        errorMessage: errorMessage,
        createdJobId: status === 'PROCESSED' ? job.id : null,
        retryCount: retryCount
      }
    });
    webhookLogs.push(webhookLog);
  }

  console.log(`‚úÖ Created ${webhookLogs.length} webhook logs`);
  return webhookLogs;
}

async function createAuditLogs(customers: any[], jobs: any[], users: any[]) {
  console.log('üìã Creating audit logs...');

  const auditLogs = [];
  const actions = ['CREATE', 'UPDATE', 'DELETE'] as const;
  const entityTypes = ['Customer', 'Job', 'User'] as const;

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á audit logs ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ï‡πà‡∏≤‡∏á‡πÜ
  const entities = [
    ...customers.map(c => ({ type: 'Customer', entity: c })),
    ...jobs.map(j => ({ type: 'Job', entity: j })),
    ...users.map(u => ({ type: 'User', entity: u }))
  ];

  for (let i = 0; i < Math.min(50, entities.length); i++) {
    const { type, entity } = SeedDataGenerator.randomFrom(entities);
    const action = SeedDataGenerator.randomFrom(actions);
    const user = SeedDataGenerator.randomFrom(users);

    const oldValues = action === 'CREATE' ? null : {
      name: entity.name,
      status: entity.status,
      updatedAt: SeedDataGenerator.pastDateRange(7)
    };

    const newValues = action === 'DELETE' ? null : {
      name: entity.name,
      status: entity.status,
      updatedAt: new Date()
    };

    const auditLog = await prisma.auditLog.create({
      data: {
        id: SeedDataGenerator.generateId('audit-'),
        entityType: type,
        entityId: entity.id,
        action: action,
        oldValues: oldValues,
        newValues: newValues,
        userId: user.id,
        timestamp: SeedDataGenerator.pastDateRange(30)
      }
    });
    auditLogs.push(auditLog);
  }

  console.log(`‚úÖ Created ${auditLogs.length} audit logs`);
  return auditLogs;
}

function printSummary(counts: Record<string, number>) {
  console.log('\nüéâ Seed data generation completed successfully!');
  console.log('üìä Summary:');
  console.log('='.repeat(40));

  Object.entries(counts).forEach(([key, count]) => {
    const emoji = {
      users: 'üë•',
      customers: 'üè¢',
      qualityChecklists: 'üìã',
      jobs: 'üíº',
      qualityChecks: '‚úÖ',
      trainingWorkflows: 'üéì',
      webhookLogs: 'üì°',
      auditLogs: 'üìã'
    }[key] || 'üìå';

    console.log(`   ${emoji} ${key}: ${count}`);
  });

  console.log('='.repeat(40));
  console.log('üöÄ Tinedy CRM is ready for development and testing!');
}

// Execute seed script
main()
  .catch((e) => {
    console.error('‚ùå Seed script failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });